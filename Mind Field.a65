STACKWIDTH	= 16
CODEORIGIN	= $8000

TRUE		= 1
FALSE		= 0

	org $C0

	.print 'ZPFREE: $0000..',*-1

fxptr	.ds 2

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4
bp	.ds 2
bp2	.ds 2

ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

TMP	.ds 2

	org $0080

STACKORIGIN	.ds STACKWIDTH*4

	.print 'ZPFREE: ',*,'..',$ff

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

.local	RESOURCE
	icl 'res6502.asm'

	RCDATA 'MINDFIELD.FNT' CHARSET_GAME 0 0 0 0 0 0 0 0
	RCDATA 'MIND FIELD TITLE.FNT' CHARSET_TITLE 0 0 0 0 0 0 0 0
	RCDATA 'Mind Field Title Screen.txt' TITLE_DATA 0 0 0 0 0 0 0 0
.endl

; -----------------------------------------------------------

	org CODEORIGIN

	STATICDATA

START
	tsx
	stx MAIN.@halt+1

	.ifdef fmulinit
	fmulinit
	eif

	ift DATAORIGIN+VARINITSIZE > $BFFF
	ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
	els
	@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
	eif

	ldx #$0f
	mva:rpl $340,x MAIN.IOCB@COPY,x-

	mvx #$00 bp					; lo BP = 0, X = 0 !!!

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	ift l_0125-*>3
	jmp l_0125
	eif

; -----------------------------------------------------------

.local	SYSTEM						; UNIT

.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 021  ---------------------

	ldy #0
	mva value (edx),y


; -----------------------------------------------------------

A	= edx
VALUE	= ecx

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	FILLCHAR_014C					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 024  ---------------------

	jsr @fill


; -----------------------------------------------------------

A	= edx
COUNT	= ecx
VALUE	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	MOVE_015F					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x DEST
	mva :STACKORIGIN+STACKWIDTH,x DEST+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x SOURCE
	mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
	dex						; sub bx, 1


; ---------------------  ASM Block 033  ---------------------

	jsr @move


; -----------------------------------------------------------

SOURCE	= edx
DEST	= ecx
COUNT	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $0004
MGTIA	= $0000
MVBXE	= $0080
WINDOW	= $0010
NARROW	= $0020
VBXE_XDLADR	= $0000
VBXE_BCBADR	= $0100
VBXE_MAPADR	= $1000
VBXE_OVRADR	= $5000
VBXE_WINDOW	= $B000
IDLI	= $0000
IVBL	= $0001
CH_DELCHR	= $00FE
CH_ENTER	= $009B
CH_ESC	= $001B
CH_CURS_UP	= $001C
CH_CURS_DOWN	= $001D
CH_CURS_LEFT	= $001E
CH_CURS_RIGHT	= $001F
CH_TAB	= $007F
CH_EOL	= $009B
CH_CLR	= $007D
CH_BELL	= $00FD
CH_DEL	= $007E
CH_DELLINE	= $009C
CH_INSLINE	= $009D
COLOR_BLACK	= $0000
COLOR_WHITE	= $000E
COLOR_RED	= $0032
COLOR_CYAN	= $0096
COLOR_VIOLET	= $0068
COLOR_GREEN	= $00C4
COLOR_BLUE	= $0074
COLOR_YELLOW	= $00EE
COLOR_ORANGE	= $004A
COLOR_BROWN	= $00E4
COLOR_LIGHTRED	= $003C
COLOR_GRAY1	= $0004
COLOR_GRAY2	= $0006
COLOR_GRAY3	= $000A
COLOR_LIGHTGREEN	= $00CC
COLOR_LIGHTBLUE	= $007C
FMOPENREAD	= $0004
FMOPENWRITE	= $0008
FMOPENAPPEND	= $0009
FMOPENREADWRITE	= $000C
SCREENWIDTH	= DATAORIGIN+$0000
SCREENHEIGHT	= DATAORIGIN+$0002
FILEMODE	= DATAORIGIN+$0004
SCREENMODE	= DATAORIGIN+$0005
IORESULT	= DATAORIGIN+$0006
EOLN	= DATAORIGIN+$0007
RNDSEED	= DATAORIGIN+$0008

.endl							; UNIT SYSTEM

; -----------------------------------------------------------

.local	ATARI						; UNIT

; -----------------------------------------------------------

RTCLOK	= $0012
ATRACT	= $004D
LMARGIN	= $0052
RMARGIN	= $0053
ROWCRS	= $0054
COLCRS	= $0055
DINDEX	= $0057
SAVMSC	= $0058
VDSLST	= $0200
VPRCED	= $0202
VINTER	= $0204
VBREAK	= $0206
VKEYBD	= $0208
VSERIN	= $020A
VSEROR	= $020C
VSEROC	= $020E
VTIMR1	= $0210
VTIMR2	= $0212
VTIMR3	= $0214
VIMIRQ	= $0216
CDTMV1	= $0218
CDTMV2	= $021A
CDTMV3	= $021C
CDTMV4	= $022E
CDTMV5	= $0220
VVBLKI	= $0222
VVBLKD	= $0224
CDTMA1	= $0226
CDTMA2	= $0228
SDNCTK	= $022F
SDLSTW	= $0230
SDLSTL	= $0230
SDLSTH	= $0231
TXTROW	= $0290
TXTCOL	= $0291
TINDEX	= $0293
TXTMSC	= $0294
SDMCTL	= $022F
GPRIOR	= $026F
CRSINH	= $02F0
CHACT	= $02F3
CHBAS	= $02F4
CH	= $02FC
PCOLR0	= $02C0
PCOLR1	= $02C1
PCOLR2	= $02C2
PCOLR3	= $02C3
COLOR0	= $02C4
COLOR1	= $02C5
COLOR2	= $02C6
COLOR3	= $02C7
COLOR4	= $02C8
HPOSP0	= $D000
HPOSP1	= $D001
HPOSP2	= $D002
HPOSP3	= $D003
HPOSM0	= $D004
HPOSM1	= $D005
HPOSM2	= $D006
HPOSM3	= $D007
SIZEP0	= $D008
SIZEP1	= $D009
SIZEP2	= $D00A
SIZEP3	= $D00B
SIZEM	= $D00C
GRAFP0	= $D00D
GRAFP1	= $D00E
GRAFP2	= $D00F
GRAFP3	= $D010
GRAFM	= $D011
PAL	= $D014
COLPM0	= $D012
COLPM1	= $D013
COLPM2	= $D014
COLPM3	= $D015
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBK	= $D01A
PRIOR	= $D01B
GRACTL	= $D01D
HITCLR	= $D01E
CONSOL	= $D01F
AUDF1	= $D200
AUDC1	= $D201
AUDF2	= $D202
AUDC2	= $D203
AUDF3	= $D204
AUDC3	= $D205
AUDF4	= $D206
AUDC4	= $D207
AUDCTL	= $D208
STIMER	= $D209
SKRES	= $D20A
POTGO	= $D20B
SEROUT	= $D20D
IRQEN	= $D20E
SKCTL	= $D20F
SKSTAT	= $D20F
POT0	= $D200
POT1	= $D201
POT2	= $D202
POT3	= $D203
POT4	= $D204
POT5	= $D205
POT6	= $D206
POT7	= $D207
ALLPOT	= $D208
POTST	= $D208
KBCODE	= $D209
RANDOM	= $D20A
SERIN	= $D20D
IRQST	= $D20E
PORTA	= $D300
PORTB	= $D301
PCCTL	= $D302
PBCTL	= $D303
DMACTL	= $D400
CHACTL	= $D401
DLISTW	= $D402
DLISTL	= $D402
DLISTH	= $D403
HSCROL	= $D404
VSCROL	= $D405
PMBASE	= $D407
CHBASE	= $D409
WSYNC	= $D40A
VCOUNT	= $D40B
PENH	= $D40C
PENV	= $D40D
NMIEN	= $D40E
NMIRES	= $D40F
NMIST	= $D40F

.endl							; UNIT ATARI

; -----------------------------------------------------------

.local	B_SYSTEM					; UNIT

.local	SETCHARSET					; PROCEDURE

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x MSB
	dex						; sub bx, 1

	ift l_0185-*>3
	jmp l_0185
	eif

; IfThenEpilog
l_0185

; optimize OK (B_SYSTEM), line = 218

	mva MSB ATARI.CHBASE

; -----------------------------------------------------------

MSB	= DATAORIGIN+$000B

@VarData	= MSB
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

__NMIEN	= DATAORIGIN+$000A
PORTB_SELFTEST_OFF	= $0080
PORTB_BASIC_OFF	= $0002
PORTB_SYSTEM_ON	= $0001

.endl							; UNIT B_SYSTEM

; -----------------------------------------------------------

.local	SYSUTILS					; UNIT

.local	INTTOSTR					; FUNCTION | ASSEMBLER

; -----------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	mva :STACKORIGIN+STACKWIDTH*2,x A+2
	mva :STACKORIGIN+STACKWIDTH*3,x A+3
	dex						; sub bx, 1


; ---------------------  ASM Block 060  ---------------------

	txa:pha

	inx

	@ValueToStr #@printINT

	mwa #@buf Result

	pla:tax


@exit

; -----------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

A	= DATAORIGIN+$000C
RESULT	= DATAORIGIN+$0010

@VarData	= A
@VarDataSize	= 6

	rts						; ret
.endl

; -----------------------------------------------------------

FAREADONLY	= $0001
FAHIDDEN	= $0002
FASYSFILE	= $0004
FAVOLUMEID	= $0008
FADIRECTORY	= $0010
FAARCHIVE	= $0020
FAANYFILE	= $003F

.endl							; UNIT SYSUTILS

; -----------------------------------------------------------

.local	B_CRT						; UNIT

.local	ATASCII2ANTIC_01A6				; FUNCTION | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x C
	dex						; sub bx, 1

	ift l_01AF-*>3
	jmp l_01AF
	eif

; IfThenEpilog
l_01AF

; ---------------------  ASM Block 064  ---------------------


        lda c
        asl
        php
        cmp #2*$60
        bcs @+
        sbc #2*$20-1
        bcs @+
        adc #2*$60
@       plp
        ror
        sta result;
    

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

C	= DATAORIGIN+$001B
RESULT	= DATAORIGIN+$001C

@VarData	= C
@VarDataSize	= 2

	rts						; ret
.endl

.local	ATASCII2ANTIC_01B3				; FUNCTION | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x S
	mva :STACKORIGIN+STACKWIDTH,x S+1
	dex						; sub bx, 1
	@move S #adr.S #256
	mwa #adr.S S

	ift l_01BC-*>3
	jmp l_01BC
	eif

; IfThenEpilog
l_01BC

; optimize OK (B_CRT), line = 468

	lda adr.S+$00
	sta adr.RESULT+$00
; For

; optimize OK (B_CRT), line = 469

	mva #$01 I

; optimize OK (B_CRT), line = 469

	lda adr.S+$00
	sta @FORTMP_464
; To
l_01D6

; ForToDoCondition

; optimize OK (B_CRT), line = 469

	lda I
	cmp @FORTMP_464
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_01E4

; optimize FAIL ('ATASCII2ANTIC_01A6', B_CRT), line = 470
	inx
	mva I :STACKORIGIN,x
	inx
	ldy I 
	mva adr.S,y :STACKORIGIN,x
	jsr ATASCII2ANTIC_01A6
	ldy :STACKORIGIN-1,x
	mva :STACKORIGIN,x adr.RESULT,y
	dex
	dex

; ForToDoEpilog
c_01D6
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_01D6
l_01E4
b_01D6

@exit

; -----------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

adr.S	= DATAORIGIN+$001D
.var S	= adr.S .word
adr.RESULT	= DATAORIGIN+$011D
.var RESULT	= adr.RESULT .word
I	= DATAORIGIN+$021D
@FORTMP_464	= DATAORIGIN+$021E

@VarData	= S
@VarDataSize	= 514

	rts						; ret
.endl

.local	CRT_INIT_01FA					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x HEIGHT
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x WIDTH
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x VRAM_ADDRESS
	mva :STACKORIGIN+STACKWIDTH,x VRAM_ADDRESS+1
	dex						; sub bx, 1

	ift l_020F-*>3
	jmp l_020F
	eif

; IfThenEpilog
l_020F

; optimize OK (B_CRT), line = 483

	mva VRAM_ADDRESS CRT_VRAM
	mva VRAM_ADDRESS+1 CRT_VRAM+1

; optimize OK (B_CRT), line = 484

	mva WIDTH CRT_SCREENWIDTH

; optimize OK (B_CRT), line = 485

	mva HEIGHT CRT_SCREENHEIGHT

; optimize OK (B_CRT), line = 486

	lda HEIGHT
	sta :ecx
	lda WIDTH
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta CRT_SIZE
	lda :eax+1
	sta CRT_SIZE+1

; optimize OK (B_CRT), line = 487

	mva CRT_VRAM CRT_CURSOR
	mva CRT_VRAM+1 CRT_CURSOR+1

; optimize OK (B_CRT), line = 488

	mva #$00 CRT_LEFTMARGIN

; -----------------------------------------------------------

VRAM_ADDRESS	= DATAORIGIN+$021F
WIDTH	= DATAORIGIN+$0221
HEIGHT	= DATAORIGIN+$0222

@VarData	= VRAM_ADDRESS
@VarDataSize	= 4


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_CLEAR_0248					; PROCEDURE | OVERLOAD

	ift l_024B-*>3
	jmp l_024B
	eif

; IfThenEpilog
l_024B

; optimize OK (B_CRT), line = 504

	lda CRT_VRAM
	sta :edx
	lda CRT_VRAM+1
	sta :edx+1
	lda CRT_SIZE
	sta :ecx
	lda CRT_SIZE+1
	sta :ecx+1
	lda #$00
	sta :eax
	jsr @fill

; optimize OK (B_CRT), line = 505

	mva CRT_VRAM CRT_CURSOR
	mva CRT_VRAM+1 CRT_CURSOR+1

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_GOTOXY					; PROCEDURE

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x Y
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x X
	dex						; sub bx, 1

	ift l_0269-*>3
	jmp l_0269
	eif

; IfThenEpilog
l_0269

; optimize OK (B_CRT), line = 516

	lda CRT_SCREENWIDTH
	sta :ecx
	lda Y
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	add X
	sta :STACKORIGIN+9
	lda :eax+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add CRT_VRAM
	sta CRT_CURSOR
	lda :STACKORIGIN+STACKWIDTH+9
	adc CRT_VRAM+1
	sta CRT_CURSOR+1

; -----------------------------------------------------------

X	= DATAORIGIN+$0223
Y	= DATAORIGIN+$0224

@VarData	= X
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_0284					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x S
	mva :STACKORIGIN+STACKWIDTH,x S+1
	dex						; sub bx, 1
	@move S #adr.S #256
	mwa #adr.S S

	ift l_028D-*>3
	jmp l_028D
	eif

; IfThenEpilog
l_028D

; optimize OK (B_CRT), line = 531

	lda S
	add #$01
	sta :edx
	lda S+1
	adc #$00
	sta :edx+1
	lda adr.S+$00
	sta :eax
	lda CRT_CURSOR
	sta :ecx
	lda CRT_CURSOR+1
	sta :ecx+1
	lda #$00
	sta :eax+1
	jsr @move

; optimize OK (B_CRT), line = 532

	lda CRT_CURSOR
	add adr.S+$00
	sta CRT_CURSOR
	lda CRT_CURSOR+1
	adc #$00
	sta CRT_CURSOR+1

; -----------------------------------------------------------

adr.S	= DATAORIGIN+$0225
.var S	= adr.S .word

@VarData	= S
@VarDataSize	= 256


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_029A					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x C
	dex						; sub bx, 1

	ift l_02A3-*>3
	jmp l_02A3
	eif

; IfThenEpilog
l_02A3

; optimize OK (B_CRT), line = 537

	lda CRT_CURSOR+1
	sta :bp+1
	ldy CRT_CURSOR
	lda C
	sta (:bp),y

; optimize FAIL (0, B_CRT), line = 538
	inw CRT_CURSOR

; -----------------------------------------------------------

C	= DATAORIGIN+$0325

@VarData	= C
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02AE					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x NUM
	dex						; sub bx, 1

	ift l_02B7-*>3
	jmp l_02B7
	eif

; IfThenEpilog
l_02B7

; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 543
	inx
	mva NUM :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr SYSUTILS.INTTOSTR
	jsr ATASCII2ANTIC_01B3
	jsr CRT_WRITE_0284

; -----------------------------------------------------------

NUM	= DATAORIGIN+$0326

@VarData	= NUM
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02BE					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x NUM
	mva :STACKORIGIN+STACKWIDTH,x NUM+1
	dex						; sub bx, 1

	ift l_02C7-*>3
	jmp l_02C7
	eif

; IfThenEpilog
l_02C7

; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 548
	inx
	mva NUM :STACKORIGIN,x
	mva NUM+1 :STACKORIGIN+STACKWIDTH,x
	jsr @expandToCARD.WORD
	jsr SYSUTILS.INTTOSTR
	jsr ATASCII2ANTIC_01B3
	jsr CRT_WRITE_0284

; -----------------------------------------------------------

NUM	= DATAORIGIN+$0327

@VarData	= NUM
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_KEYPRESSED					; FUNCTION

	ift l_02D0-*>3
	jmp l_02D0
	eif

; IfThenEpilog
l_02D0

; optimize OK (B_CRT), line = 592

	mva #$00 RESULT

; optimize OK (B_CRT), line = 593

	lda ATARI.SKSTAT
	ldy #1
	and #$04
	beq @+
	dey
@
	.ifdef IFTMP_28
	sty IFTMP_28
	eif
	tya
	bne *+5
	jmp l_02ED

; optimize OK (B_CRT), line = 593

	mva #$01 RESULT

; IfThenEpilog
l_02ED

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

RESULT	= DATAORIGIN+$0329

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

.local	CRT_STARTPRESSED				; FUNCTION

	ift l_0307-*>3
	jmp l_0307
	eif

; IfThenEpilog
l_0307

; optimize OK (B_CRT), line = 749

	lda ATARI.CONSOL
	ldy #1
	and #$01
	beq @+
	dey
@
	sty RESULT

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

RESULT	= DATAORIGIN+$032A

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

; -----------------------------------------------------------

DEFAULT_SCREENWIDTH	= $0028
DEFAULT_SCREENHEIGHT	= $0018
CHAR_RETURN	= $009B
CHAR_ESCAPE	= $001B
CHAR_BACKSPACE	= $007E
CHAR_TAB	= $007F
CHAR_INVERSE	= $0081
CHAR_CAPS	= $0082
ICHAR_RETURN	= $00DB
ICHAR_ESCAPE	= $005B
ICHAR_BACKSPACE	= $007E
ICHAR_TAB	= $007F
ICHAR_INVERSE	= $00C1
ICHAR_CAPS	= $00C2
adr.CRT_KEYCODE	= CODEORIGIN+$011E
.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
CRT_VRAM	= DATAORIGIN+$0012
CRT_SIZE	= DATAORIGIN+$0014
CRT_SCREENWIDTH	= DATAORIGIN+$0016
CRT_SCREENHEIGHT	= DATAORIGIN+$0017
CRT_CURSOR	= DATAORIGIN+$0018
CRT_LEFTMARGIN	= DATAORIGIN+$001A
KBCODE	= $D209
CONSOL	= $D01F

.endl							; UNIT B_CRT

.local	TITLEVBI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 066  ---------------------


		lda #<title00dli
		sta vdslst+0
		lda #>title00dli
		sta vdslst+1
		jmp XITVBV
	
	rti						; ret
.endl

.local	GAMEVBI						; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 067  ---------------------


	rti						; ret
.endl

.local	PAUSEVBI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 068  ---------------------


	rti						; ret
.endl

.local	TITLE00DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 069  ---------------------


	pha	
	lda #$D8
	sta wsync
	sta colpf0
	lda #$06
	sta colpf1
	lda #$AA
	sta colpf2
	lda #>CHARSET_TITLE
	sta chbase
	lda #<title01dli
	sta vdslst+0
	lda #>title01dli
	sta vdslst+1
	pla
	rti
	rti						; ret
.endl

.local	TITLE01DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 070  ---------------------


	pha	
	lda #142
	sta wsync
	sta colpf0
	lda #10
	sta colpf1
	lda #186
	sta colpf2
	lda #>CHARSET_GAME
 	sta chbase
	lda #<title00dli
	sta vdslst+0
	lda #>title00dli
	sta vdslst+1
	pla
	rti
	rti						; ret
.endl

.local	TITLE02DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 071  ---------------------

phr
	plr
	rti						; ret
.endl

.local	TITLE03DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 072  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME00DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 073  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME01DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 074  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME02DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 075  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME03DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 076  ---------------------

phr
	plr
	rti						; ret
.endl

.local	SHOWTITLESCREEN					; PROCEDURE

	ift l_032C-*>3
	jmp l_032C
	eif

; IfThenEpilog
l_032C

; optimize OK (Mind Field.pas), line = 153

	lda #$00
	sta TOPMEM
	lda CHBASE1
	sta TOPMEM+1

; ---------------------  ASM Block 077  ---------------------


;	  ICL "Atari 8-bit Equates.asm"
		
    lda #0
    sta 82
    sta 710
    lda #12
    sta 709
    ; lda chbase1
    ; sta 756
    LDA #0
    STA NMIEN
    STA DMACTL
    STA PRIOR
    STA HITCLR

;    LDX #>RamSizeCode+1
    LDY #$00
    STY NDX0
    STY NDX2
    LDA #$38
    STA NDX1
    LDA #$A8
    STA NDX3
    

; optimize OK (Mind Field.pas), line = 179

	mva #$00 ATARI.DMACTL

; optimize OK (Mind Field.pas), line = 180

	sta ATARI.NMIEN

; optimize FAIL ('B_CRT.CRT_INIT_01FA', Mind Field.pas), line = 181
	inx
	mva #$00 :STACKORIGIN,x
	mva #$08 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$28 :STACKORIGIN,x
	inx
	mva #$19 :STACKORIGIN,x
	jsr B_CRT.CRT_INIT_01FA

; optimize OK (Mind Field.pas), line = 182

	mva <TITLE00DLI VDSLST
	mva >TITLE00DLI VDSLST+1

; optimize OK (Mind Field.pas), line = 183

	lda <TITLEVBI
	ldy #5
	sta wsync
	dey
	rne
	sta VVBLKD
	lda >TITLEVBI
	sta VVBLKD+1

; optimize FAIL ('B_CRT.CRT_CLEAR_0248', Mind Field.pas), line = 184
	jsr B_CRT.CRT_CLEAR_0248

; optimize OK (Mind Field.pas), line = 185

	mva #$1E ATARI.DLISTW
	mva #$82 ATARI.DLISTW+1

; optimize OK (Mind Field.pas), line = 186

	mva #$1E ATARI.SDLSTW
	mva #$82 ATARI.SDLSTW+1

; optimize OK (Mind Field.pas), line = 187

	mva #$00 ATARI.SAVMSC
	mva #$08 ATARI.SAVMSC+1

; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 188
	inx
	mva #$A4 :STACKORIGIN,x
	jsr B_SYSTEM.SETCHARSET

; optimize OK (Mind Field.pas), line = 189

	mva #$A4 ATARI.CHBAS

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 190
	inx
	mva #$00 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 191
	inx
	mva #$02 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 192
	inx
	mva #$2C :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 193
	inx
	mva #$56 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 194
	inx
	mva #$80 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 195
	inx
	mva #$AA :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284

; optimize OK (Mind Field.pas), line = 196

	mva #$00 TMP5

; optimize OK (Mind Field.pas), line = 198

	mva #$06 K

; optimize OK (Mind Field.pas), line = 199

	mva #$05 I

; optimize OK (Mind Field.pas), line = 201

	mva #$D8 ATARI.COLOR0

; optimize OK (Mind Field.pas), line = 202

	mva #$06 ATARI.COLOR1

; optimize OK (Mind Field.pas), line = 203

	mva #$AA ATARI.COLOR2

; optimize OK (Mind Field.pas), line = 204

	mva #$36 ATARI.COLOR3

; optimize OK (Mind Field.pas), line = 205

	mva #$22 ATARI.COLOR4

; optimize OK (Mind Field.pas), line = 206

	mva #$C0 ATARI.NMIEN

; optimize OK (Mind Field.pas), line = 207

	mva #$3E ATARI.DMACTL

; --- RepeatUntilProlog
l_03BE

; optimize OK (Mind Field.pas), line = 210

	lda I
	asl @
	tay
	lda adr.HISCORE,y
	sta :STACKORIGIN+10
	lda adr.HISCORE+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #1
	lda SCORE+1
	cmp :STACKORIGIN+STACKWIDTH+10
	bne @+
	lda SCORE
	cmp :STACKORIGIN+10
@
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_32
	sty IFTMP_32
	eif
	tya
	bne *+5
	jmp l_03D3

; optimize OK (Mind Field.pas), line = 212

	mva I K

; IfThenEpilog
l_03D3

; optimize OK (Mind Field.pas), line = 214

	dec I

; optimize OK (Mind Field.pas), line = 215

	ldy #1
	lda I
	beq @+
	dey
@
	tya
	bne *+5
c_03BE
	jmp l_03BE
b_03BE

; optimize OK (Mind Field.pas), line = 216

	ldy #1
	lda K
	cmp #$05
	bcc @+
	dey
@
	.ifdef IFTMP_33
	sty IFTMP_33
	eif
	tya
	bne *+5
	jmp l_040B

; optimize OK (Mind Field.pas), line = 218

	mva #$05 I

; --- RepeatUntilProlog
l_0414

; optimize OK (Mind Field.pas), line = 220

	lda I
	asl @
	sta :STACKORIGIN+9
	lda I
	sub #$01
	asl @
	tay
	lda adr.HISCORE,y
	sta :STACKORIGIN+10
	lda adr.HISCORE+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy :STACKORIGIN+9
	lda :STACKORIGIN+10
	sta adr.HISCORE,y
	lda :STACKORIGIN+STACKWIDTH+10
	sta adr.HISCORE+1,y

; optimize OK (Mind Field.pas), line = 221

	dec I

; optimize OK (Mind Field.pas), line = 222

	ldy #1
	lda I
	cmp K
	beq @+
	dey
@
	tya
	bne *+5
c_0414
	jmp l_0414
b_0414

; optimize OK (Mind Field.pas), line = 223

	lda K
	asl @
	tay
	lda SCORE
	sta adr.HISCORE,y
	lda SCORE+1
	sta adr.HISCORE+1,y

; IfThenEpilog
l_040B

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 225
	inx
	mva #$0A :STACKORIGIN,x
	inx
	mva #$06 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 226
	inx
	mva #$D4 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 227
	inx
	mva #$12 :STACKORIGIN,x
	inx
	mva #$06 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02BE', Mind Field.pas), line = 228
	inx
	mva SCORE :STACKORIGIN,x
	mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02BE

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 229
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 230
	inx
	mva #$DE :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284
; For

; optimize OK (Mind Field.pas), line = 231

	mva #$01 I

; optimize OK (Mind Field.pas), line = 231

; To
l_0468

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 231

	lda I
	cmp #$05
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0476

; optimize OK (Mind Field.pas), line = 233

	ldy #1
	lda K
	cmp I
	beq @+
	dey
@
	.ifdef IFTMP_34
	sty IFTMP_34
	eif
	tya
	bne *+5
	jmp l_048A

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 235
	inx
	mva #$0C :STACKORIGIN,x
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva I :STACKORIGIN,x
	jsr addAL_CL
	dex
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_029A', Mind Field.pas), line = 236
	inx
	mva #$0A :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_029A

; IfThenEpilog
l_048A

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 238
	inx
	mva #$0E :STACKORIGIN,x
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva I :STACKORIGIN,x
	jsr addAL_CL
	dex
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02AE', Mind Field.pas), line = 239
	inx
	mva I :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_02AE

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 240
	inx
	mva #$F3 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 241
	inx
	mva #$12 :STACKORIGIN,x
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva I :STACKORIGIN,x
	jsr addAL_CL
	dex
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02BE', Mind Field.pas), line = 242
	inx
	mva I :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	m@index2 0
	ldy :STACKORIGIN,x
	mva adr.HISCORE,y :STACKORIGIN,x
	mva adr.HISCORE+1,y :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02BE

; ForToDoEpilog
c_0468
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0468
l_0476
b_0468

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 244
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva #$0F :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 245
	inx
	mva #$F7 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284

; optimize OK (Mind Field.pas), line = 246

	lda #$00
	sta :bp+1
	ldy ATARI.HPOSP0
	lda #$7C
	sta (:bp),y

; --- RepeatUntilProlog
l_04C6

; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 257
	jsr B_CRT.CRT_STARTPRESSED
	.ifdef IFTMP_35
	lda :STACKORIGIN,x
	sta IFTMP_35
	eif
	dex
	lda :STACKORIGIN+1,x
	bne *+5
	jmp l_04D0

; optimize OK (Mind Field.pas), line = 257

	mva #$FF TMP5

; IfThenEpilog
l_04D0

; optimize OK (Mind Field.pas), line = 261

	ldy #1
	lda TMP5
	cmp #$FF
	beq @+
	dey
@
	tya
	bne *+5
c_04C6
	jmp l_04C6
b_04C6

; optimize OK (Mind Field.pas), line = 263

	mva #$40 ATARI.NMIEN

; --- RepeatUntilProlog
l_04EF

; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 265
	jsr B_CRT.CRT_STARTPRESSED
	inx
	mva #$00 :STACKORIGIN,x
	ldy #1
	lda :STACKORIGIN-1,x
	cmp :STACKORIGIN,x
	beq @+
	dey
@
	sty :STACKORIGIN-1,x
	dex
	dex
	lda :STACKORIGIN+1,x
	bne *+5
c_04EF
	jmp l_04EF
b_04EF

; ---------------------  ASM Block 078  ---------------------


//    ORG 32768
//    ICL "inflate_2017_ver4.asm"
//    ORG 46080
//    INS "roman10.fnt" 


; -----------------------------------------------------------

@FORTMP_1122	= $0005

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	INITIALIZE_LEVEL				; PROCEDURE

	ift l_04FE-*>3
	jmp l_04FE
	eif

; IfThenEpilog
l_04FE
; For

; optimize OK (Mind Field.pas), line = 280

	mva #$00 I

; optimize OK (Mind Field.pas), line = 280

; To
l_050D

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 280

	lda I
	cmp #$FF
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_051B

; ---------------------  ASM Block 079  ---------------------


	LDA RANDOM
	CLC
	ADC #<game_screen
	STA NDX0
	LDA RANDOM
	AND #3
	ADC #>game_screen
	STA NDX1
	LDA RANDOM
	AND #3
	ORA #68
	LDY #0
	STA (NDX0),Y


; ForToDoEpilog
c_050D
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_050D
l_051B
b_050D
; For

; optimize OK (Mind Field.pas), line = 300

	mva #$00 I

; optimize OK (Mind Field.pas), line = 300

; To
l_052F

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 300

	lda I
	cmp #$3F
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_053D

; ---------------------  ASM Block 080  ---------------------


	LDA RANDOM
	CLC
	ADC #<game_screen
	STA NDX0
	LDA RANDOM
	AND #3
	ADC #>game_screen
	STA NDX1
	LDA #193
	LDY #0
	STA (NDX0),Y


; ForToDoEpilog
c_052F
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_052F
l_053D
b_052F

; -----------------------------------------------------------

@FORTMP_1287	= $00FF
@FORTMP_1321	= $003F

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	DISPLAY_INFORMATION_LINE			; PROCEDURE

	ift l_0546-*>3
	jmp l_0546
	eif

; IfThenEpilog
l_0546

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 320
	inx
	mva #$00 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 321
	inx
	mva #$0E :STACKORIGIN,x
	mva #$81 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 322
	inx
	mva #$06 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02BE', Mind Field.pas), line = 323
	inx
	mva SCORE :STACKORIGIN,x
	mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02BE

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 325
	inx
	mva #$0E :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 326
	inx
	mva #$16 :STACKORIGIN,x
	mva #$81 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0284

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 327
	inx
	mva #$14 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02AE', Mind Field.pas), line = 328
	inx
	mva LIVES :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_02AE

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; IfThenEpilog
l_0125

; --- RepeatUntilProlog
l_055F

; optimize FAIL ('SHOWTITLESCREEN', Mind Field.pas), line = 341
	jsr SHOWTITLESCREEN

; optimize OK (Mind Field.pas), line = 344

	mva #$00 SCORE
	sta SCORE+1

; optimize OK (Mind Field.pas), line = 345

	mva #$05 LIVES

; optimize FAIL ('B_CRT.CRT_INIT_01FA', Mind Field.pas), line = 346
	inx
	mva #$00 :STACKORIGIN,x
	mva #$08 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$28 :STACKORIGIN,x
	inx
	mva #$1A :STACKORIGIN,x
	jsr B_CRT.CRT_INIT_01FA

; optimize FAIL ('B_CRT.CRT_CLEAR_0248', Mind Field.pas), line = 347
	jsr B_CRT.CRT_CLEAR_0248

; optimize FAIL ('DISPLAY_INFORMATION_LINE', Mind Field.pas), line = 348
	jsr DISPLAY_INFORMATION_LINE

; optimize OK (Mind Field.pas), line = 349

	mva #$53 ATARI.DLISTW
	mva #$82 ATARI.DLISTW+1

; optimize OK (Mind Field.pas), line = 350

	mva #$53 ATARI.SDLSTW
	mva #$82 ATARI.SDLSTW+1

; optimize OK (Mind Field.pas), line = 351

	mva #$00 ATARI.SAVMSC
	mva #$08 ATARI.SAVMSC+1

; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 352
	inx
	mva #$A4 :STACKORIGIN,x
	jsr B_SYSTEM.SETCHARSET

; optimize OK (Mind Field.pas), line = 353

	mva #$A4 ATARI.CHBAS

; optimize FAIL ('INITIALIZE_LEVEL', Mind Field.pas), line = 354
	jsr INITIALIZE_LEVEL

; optimize OK (Mind Field.pas), line = 355

	mva #$8E ATARI.COLOR0

; optimize OK (Mind Field.pas), line = 356

	mva #$D4 ATARI.COLOR1

; optimize OK (Mind Field.pas), line = 357

	mva #$46 ATARI.COLOR2

; optimize OK (Mind Field.pas), line = 358

	mva #$96 ATARI.COLOR3

; optimize OK (Mind Field.pas), line = 359

	mva #$22 ATARI.COLOR4

; --- RepeatUntilProlog
l_05B7

; optimize FAIL ('B_CRT.CRT_KEYPRESSED', Mind Field.pas), line = 366
	jsr B_CRT.CRT_KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	bne *+5
c_05B7
	jmp l_05B7
b_05B7

; optimize OK (Mind Field.pas), line = 368

	lda #$00
	bne *+5
c_055F
	jmp l_055F
b_055F

; -----------------------------------------------------------

SCREEN_ADDR	= $0800
GAME_SCREEN	= $0828
PMBANK	= $1000
VARBANK	= $1800
CHARSET_GAME	= $A400
CHARSET_TITLE	= $A800
TITLE_DATA	= $AC00
CHARSET_BASE	= $00A4
adr.DISPLAY_LIST_TITLE	= CODEORIGIN+$021E
.var DISPLAY_LIST_TITLE	= adr.DISPLAY_LIST_TITLE .word
adr.DISPLAY_LIST_GAME	= CODEORIGIN+$0253
.var DISPLAY_LIST_GAME	= adr.DISPLAY_LIST_GAME .word
PRIOR	= $D01B
TMP0	= $00E0
TMP1	= $00E1
TMP2	= $00E2
TMP3	= $00E3
TMP4	= $00E4
TMP5	= $00E5
TMP6	= $00E6
TMP7	= $00E7
TMP8	= $00E8
TMP9	= $00E9
NDX0	= $00EA
NDX1	= $00EB
NDX2	= $00EC
NDX3	= $00ED
HOLDX	= $00EE
HOLDY	= $00EF
SPRITENUM	= $1180
SETSP0COLOR	= $1190
SETSP1COLOR	= $11A0
SETSPWIDTH	= $11B0
SPRITENHOZ	= $11C0
SPRITENVRT	= $11E0
SPHOZNEXT	= $11F0
SCREEN_LINE_ADDR_LOW	= $1000
SCREEN_LINE_ADDR_HIGH	= $1020
SPRHZ0	= $1200
SPRHZ1	= $1210
SPRHZ2	= $1220
SPRHZ3	= $1230
SPZONT	= $1240
SPZONB	= $1250
SPSRC0	= $1260
SPSRC1	= $1278
SPSRC2	= $1290
SPSRC3	= $12A8
SPSRC4	= $12C0
SPRITEUSE	= $12D8
MIBANK	= $1300
PMBNK0	= $1400
PMBNK1	= $1500
PMBNK2	= $1600
PMBNK3	= $1700
A	= DATAORIGIN+$032B
B	= DATAORIGIN+$032C
C	= DATAORIGIN+$032D
D	= DATAORIGIN+$032E
E	= DATAORIGIN+$032F
F	= DATAORIGIN+$0330
G	= DATAORIGIN+$0331
H	= DATAORIGIN+$0332
I	= DATAORIGIN+$0333
J	= DATAORIGIN+$0334
K	= DATAORIGIN+$0335
L	= DATAORIGIN+$0336
TITLEPHASE	= DATAORIGIN+$0337
SCORE	= DATAORIGIN+$0338
LIVES	= DATAORIGIN+$033A
adr.HISCORE	= DATAORIGIN+$033B
.var HISCORE	= adr.HISCORE .word
TOPMEM	= DATAORIGIN+$0351
CHBASE1	= DATAORIGIN+$0353

@exit

@halt	ldx #0
	txs

	rts

IOCB@COPY	:16 brk

.local	@DEFINES
ATARI
PLATFORM_ATARI_ANTIC
PLATFORM_ATARI_8_BIT
.endl

.endl

; -----------------------------------------------------------

	icl 'cpu6502.asm'

; -----------------------------------------------------------

.macro UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	eif

	.ifdef MAIN.ATARI.@UnitInit
	jsr MAIN.ATARI.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_SYSTEM.@UnitInit
	jsr MAIN.B_SYSTEM.@UnitInit
	eif

	.ifdef MAIN.SYSUTILS.@UnitInit
	jsr MAIN.SYSUTILS.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_CRT.@UnitInit
	jsr MAIN.B_CRT.@UnitInit
	eif
.endm

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.ATARI) > 0
	.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
	eif

	ift .SIZEOF(MAIN.B_SYSTEM) > 0
	.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.SYSUTILS) > 0
	.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
	eif

	ift .SIZEOF(MAIN.B_CRT) > 0
	.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
	eif

	.print 'CODE: ',CODEORIGIN,'..',*-1

	org $A000

DATAORIGIN

.by  $28 $00 $18 $00 $0C $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $9A $10 $00 $00 $00 $4C $1D $7C  $15 $AC $0D $C4 $09 $F4 $01

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 852

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

	run START

; -----------------------------------------------------------

.macro	STATICDATA
.by  $00 $00 $28 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $21 $34  $21 $32 $29 $00 $18 $0D $22 $29
.by  $34 $00 $36 $25 $32 $33 $29 $2F  $2E $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $28 $00 $30 $32
.by  $2F $27 $32 $21 $2D $2D $29 $2E  $27 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $30 $25
.by  $34 $25 $32 $00 $2A $0E $00 $2D  $25 $39 $25 $32 $00 $00 $28 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $08 $39 $2F  $35 $32 $00 $2E $21 $2D $25 $00  $23 $2F $35 $2C $24 $00 $22 $25
.by  $00 $28 $25 $32 $25 $09 $00 $00  $28 $00 $27 $32 $21 $30 $28 $29  $23 $33 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $28 $00 $33 $2F $35 $2E  $24 $00 $21 $2E $24 $00 $2D $35  $33 $29 $23 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $08 $33 $23 $2F
.by  $32 $25 $00 $1A $00 $00 $13 $34  $2F $24 $21 $39 $33 $00 $28 $29  $27 $28 $00 $33 $23 $2F $32 $25
.by  $33 $0E $00 $02 $00 $1A $00 $15  $30 $32 $25 $33 $33 $00 $33 $34  $21 $32 $34 $00 $34 $2F $00 $22
.by  $25 $27 $29 $2E $0E $00 $06 $33  $23 $2F $32 $25 $1A $00 $06 $2C  $29 $36 $25 $33 $1A $00 $6C $6A
.by  $3B $FF $FF $6B $2B $2A $6F $FF  $70 $75 $9B $69 $2D $3D $76 $FF  $63 $FF $FF $62 $78 $7A $34 $FF
.by  $33 $36 $1B $35 $32 $31 $2C $20  $2E $6E $FF $6D $2F $81 $72 $FF  $65 $79 $7F $74 $77 $71 $39 $FF
.by  $30 $37 $7E $38 $3E $FF $66 $68  $64 $FF $82 $67 $73 $61 $4C $4A  $3A $FF $FF $4B $5C $5E $4F $FF
.by  $50 $55 $FF $49 $5F $7C $56 $FF  $43 $FF $FF $42 $58 $5A $24 $FF  $23 $26 $FF $25 $22 $21 $5B $3B
.by  $5D $4E $FF $4D $3F $FF $52 $FF  $45 $59 $FF $54 $57 $51 $28 $FF  $29 $27 $FF $40 $FF $FF $46 $48
.by  $44 $FF $FF $47 $53 $41 $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $70 $C0  $44 $00 $AC $04 $04 $04 $04 $04
.by  $04 $84 $00 $44 $00 $08 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04
.by  $00 $04 $00 $04 $00 $04 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04  $41 $1E $82 $70 $70 $44 $00 $08
.by  $10 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04
.by  $04 $04 $04 $41 $53 $82
.endm

	end
