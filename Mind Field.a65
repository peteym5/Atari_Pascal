STACKWIDTH	= 16
CODEORIGIN	= $8000

TRUE		= 1
FALSE		= 0

	org $C0

	.print 'ZPFREE: $0000..',*-1

fxptr	.ds 2

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4
bp	.ds 2
bp2	.ds 2

ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

TMP	.ds 2

	org $0080

STACKORIGIN	.ds STACKWIDTH*4

	.print 'ZPFREE: ',*,'..',$ff

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

.local	RESOURCE
	icl 'res6502.asm'

	RCDATA 'MINDFIELD.FNT' CHARSET_GAME 0 0 0 0 0 0 0 0
	RCDATA 'MIND FIELD TITLE.FNT' CHARSET_TITLE 0 0 0 0 0 0 0 0
	RCDATA 'Mind Field Title Screen.txt' TITLE_DATA 0 0 0 0 0 0 0 0
.endl

; -----------------------------------------------------------

	org CODEORIGIN

	STATICDATA

START
	tsx
	stx MAIN.@halt+1

	.ifdef fmulinit
	fmulinit
	eif

	ift DATAORIGIN+VARINITSIZE > $BFFF
	ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
	els
	@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
	eif

	ldx #$0f
	mva:rpl $340,x MAIN.IOCB@COPY,x-

	mvx #$00 bp					; lo BP = 0, X = 0 !!!

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	ift l_0125-*>3
	jmp l_0125
	eif

; -----------------------------------------------------------

.local	SYSTEM						; UNIT

.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 021  ---------------------

	ldy #0
	mva value (edx),y


; -----------------------------------------------------------

A	= edx
VALUE	= ecx

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	FILLCHAR_014C					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 024  ---------------------

	jsr @fill


; -----------------------------------------------------------

A	= edx
COUNT	= ecx
VALUE	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	FILLBYTE_015F					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 029  ---------------------

	jsr @fill


; -----------------------------------------------------------

A	= edx
COUNT	= ecx
VALUE	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	MOVE_0172					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x DEST
	mva :STACKORIGIN+STACKWIDTH,x DEST+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x SOURCE
	mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
	dex						; sub bx, 1


; ---------------------  ASM Block 031  ---------------------

	jsr @move


; -----------------------------------------------------------

SOURCE	= edx
DEST	= ecx
COUNT	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	MOVE_0185					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x DEST
	mva :STACKORIGIN+STACKWIDTH,x DEST+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x SOURCE
	mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
	dex						; sub bx, 1


; ---------------------  ASM Block 033  ---------------------

	jsr @move


; -----------------------------------------------------------

SOURCE	= edx
DEST	= ecx
COUNT	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $0004
MGTIA	= $0000
MVBXE	= $0080
WINDOW	= $0010
NARROW	= $0020
VBXE_XDLADR	= $0000
VBXE_BCBADR	= $0100
VBXE_MAPADR	= $1000
VBXE_OVRADR	= $5000
VBXE_WINDOW	= $B000
IDLI	= $0000
IVBL	= $0001
CH_DELCHR	= $00FE
CH_ENTER	= $009B
CH_ESC	= $001B
CH_CURS_UP	= $001C
CH_CURS_DOWN	= $001D
CH_CURS_LEFT	= $001E
CH_CURS_RIGHT	= $001F
CH_TAB	= $007F
CH_EOL	= $009B
CH_CLR	= $007D
CH_BELL	= $00FD
CH_DEL	= $007E
CH_DELLINE	= $009C
CH_INSLINE	= $009D
COLOR_BLACK	= $0000
COLOR_WHITE	= $000E
COLOR_RED	= $0032
COLOR_CYAN	= $0096
COLOR_VIOLET	= $0068
COLOR_GREEN	= $00C4
COLOR_BLUE	= $0074
COLOR_YELLOW	= $00EE
COLOR_ORANGE	= $004A
COLOR_BROWN	= $00E4
COLOR_LIGHTRED	= $003C
COLOR_GRAY1	= $0004
COLOR_GRAY2	= $0006
COLOR_GRAY3	= $000A
COLOR_LIGHTGREEN	= $00CC
COLOR_LIGHTBLUE	= $007C
FMOPENREAD	= $0004
FMOPENWRITE	= $0008
FMOPENAPPEND	= $0009
FMOPENREADWRITE	= $000C
SCREENWIDTH	= DATAORIGIN+$0000
SCREENHEIGHT	= DATAORIGIN+$0002
FILEMODE	= DATAORIGIN+$0004
SCREENMODE	= DATAORIGIN+$0005
IORESULT	= DATAORIGIN+$0006
EOLN	= DATAORIGIN+$0007
RNDSEED	= DATAORIGIN+$0008

.endl							; UNIT SYSTEM

; -----------------------------------------------------------

.local	ATARI						; UNIT

; -----------------------------------------------------------

RTCLOK	= $0012
ATRACT	= $004D
LMARGIN	= $0052
RMARGIN	= $0053
ROWCRS	= $0054
COLCRS	= $0055
DINDEX	= $0057
SAVMSC	= $0058
VDSLST	= $0200
VPRCED	= $0202
VINTER	= $0204
VBREAK	= $0206
VKEYBD	= $0208
VSERIN	= $020A
VSEROR	= $020C
VSEROC	= $020E
VTIMR1	= $0210
VTIMR2	= $0212
VTIMR3	= $0214
VIMIRQ	= $0216
CDTMV1	= $0218
CDTMV2	= $021A
CDTMV3	= $021C
CDTMV4	= $022E
CDTMV5	= $0220
VVBLKI	= $0222
VVBLKD	= $0224
CDTMA1	= $0226
CDTMA2	= $0228
SDNCTK	= $022F
SDLSTW	= $0230
SDLSTL	= $0230
SDLSTH	= $0231
TXTROW	= $0290
TXTCOL	= $0291
TINDEX	= $0293
TXTMSC	= $0294
SDMCTL	= $022F
GPRIOR	= $026F
CRSINH	= $02F0
CHACT	= $02F3
CHBAS	= $02F4
CH	= $02FC
PCOLR0	= $02C0
PCOLR1	= $02C1
PCOLR2	= $02C2
PCOLR3	= $02C3
COLOR0	= $02C4
COLOR1	= $02C5
COLOR2	= $02C6
COLOR3	= $02C7
COLOR4	= $02C8
HPOSP0	= $D000
HPOSP1	= $D001
HPOSP2	= $D002
HPOSP3	= $D003
HPOSM0	= $D004
HPOSM1	= $D005
HPOSM2	= $D006
HPOSM3	= $D007
SIZEP0	= $D008
SIZEP1	= $D009
SIZEP2	= $D00A
SIZEP3	= $D00B
SIZEM	= $D00C
GRAFP0	= $D00D
GRAFP1	= $D00E
GRAFP2	= $D00F
GRAFP3	= $D010
GRAFM	= $D011
PAL	= $D014
COLPM0	= $D012
COLPM1	= $D013
COLPM2	= $D014
COLPM3	= $D015
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBK	= $D01A
PRIOR	= $D01B
GRACTL	= $D01D
HITCLR	= $D01E
CONSOL	= $D01F
AUDF1	= $D200
AUDC1	= $D201
AUDF2	= $D202
AUDC2	= $D203
AUDF3	= $D204
AUDC3	= $D205
AUDF4	= $D206
AUDC4	= $D207
AUDCTL	= $D208
STIMER	= $D209
SKRES	= $D20A
POTGO	= $D20B
SEROUT	= $D20D
IRQEN	= $D20E
SKCTL	= $D20F
SKSTAT	= $D20F
POT0	= $D200
POT1	= $D201
POT2	= $D202
POT3	= $D203
POT4	= $D204
POT5	= $D205
POT6	= $D206
POT7	= $D207
ALLPOT	= $D208
POTST	= $D208
KBCODE	= $D209
RANDOM	= $D20A
SERIN	= $D20D
IRQST	= $D20E
PORTA	= $D300
PORTB	= $D301
PCCTL	= $D302
PBCTL	= $D303
DMACTL	= $D400
CHACTL	= $D401
DLISTW	= $D402
DLISTL	= $D402
DLISTH	= $D403
HSCROL	= $D404
VSCROL	= $D405
PMBASE	= $D407
CHBASE	= $D409
WSYNC	= $D40A
VCOUNT	= $D40B
PENH	= $D40C
PENV	= $D40D
NMIEN	= $D40E
NMIRES	= $D40F
NMIST	= $D40F

.endl							; UNIT ATARI

; -----------------------------------------------------------

.local	B_SYSTEM					; UNIT

.local	SETCHARSET					; PROCEDURE

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x MSB
	dex						; sub bx, 1

	ift l_01AB-*>3
	jmp l_01AB
	eif

; IfThenEpilog
l_01AB

; optimize OK (B_SYSTEM), line = 218

	mva MSB ATARI.CHBASE

; -----------------------------------------------------------

MSB	= DATAORIGIN+$000B

@VarData	= MSB
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

__NMIEN	= DATAORIGIN+$000A
PORTB_SELFTEST_OFF	= $0080
PORTB_BASIC_OFF	= $0002
PORTB_SYSTEM_ON	= $0001

.endl							; UNIT B_SYSTEM

; -----------------------------------------------------------

.local	SYSUTILS					; UNIT

.local	INTTOSTR					; FUNCTION | ASSEMBLER

; -----------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	mva :STACKORIGIN+STACKWIDTH*2,x A+2
	mva :STACKORIGIN+STACKWIDTH*3,x A+3
	dex						; sub bx, 1


; ---------------------  ASM Block 060  ---------------------

	txa:pha

	inx

	@ValueToStr #@printINT

	mwa #@buf Result

	pla:tax


@exit

; -----------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

A	= DATAORIGIN+$000C
RESULT	= DATAORIGIN+$0010

@VarData	= A
@VarDataSize	= 6

	rts						; ret
.endl

; -----------------------------------------------------------

FAREADONLY	= $0001
FAHIDDEN	= $0002
FASYSFILE	= $0004
FAVOLUMEID	= $0008
FADIRECTORY	= $0010
FAARCHIVE	= $0020
FAANYFILE	= $003F

.endl							; UNIT SYSUTILS

; -----------------------------------------------------------

.local	B_CRT						; UNIT

.local	ATASCII2ANTIC_01CC				; FUNCTION | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x C
	dex						; sub bx, 1

	ift l_01D5-*>3
	jmp l_01D5
	eif

; IfThenEpilog
l_01D5

; ---------------------  ASM Block 064  ---------------------


        lda c
        asl
        php
        cmp #2*$60
        bcs @+
        sbc #2*$20-1
        bcs @+
        adc #2*$60
@       plp
        ror
        sta result;
    

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

C	= DATAORIGIN+$001B
RESULT	= DATAORIGIN+$001C

@VarData	= C
@VarDataSize	= 2

	rts						; ret
.endl

.local	ATASCII2ANTIC_01D9				; FUNCTION | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x S
	mva :STACKORIGIN+STACKWIDTH,x S+1
	dex						; sub bx, 1
	@move S #adr.S #256
	mwa #adr.S S

	ift l_01E2-*>3
	jmp l_01E2
	eif

; IfThenEpilog
l_01E2

; optimize OK (B_CRT), line = 468

	lda adr.S+$00
	sta adr.RESULT+$00
; For

; optimize OK (B_CRT), line = 469

	mva #$01 I

; optimize OK (B_CRT), line = 469

	lda adr.S+$00
	sta @FORTMP_502
; To
l_01FC

; ForToDoCondition

; optimize OK (B_CRT), line = 469

	lda I
	cmp @FORTMP_502
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_020A

; optimize FAIL ('ATASCII2ANTIC_01CC', B_CRT), line = 470
	inx
	mva I :STACKORIGIN,x
	inx
	ldy I 
	mva adr.S,y :STACKORIGIN,x
	jsr ATASCII2ANTIC_01CC
	ldy :STACKORIGIN-1,x
	mva :STACKORIGIN,x adr.RESULT,y
	dex
	dex

; ForToDoEpilog
c_01FC
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_01FC
l_020A
b_01FC

@exit

; -----------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

adr.S	= DATAORIGIN+$001D
.var S	= adr.S .word
adr.RESULT	= DATAORIGIN+$011D
.var RESULT	= adr.RESULT .word
I	= DATAORIGIN+$021D
@FORTMP_502	= DATAORIGIN+$021E

@VarData	= S
@VarDataSize	= 514

	rts						; ret
.endl

.local	CRT_INIT_0220					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x HEIGHT
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x WIDTH
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x VRAM_ADDRESS
	mva :STACKORIGIN+STACKWIDTH,x VRAM_ADDRESS+1
	dex						; sub bx, 1

	ift l_0235-*>3
	jmp l_0235
	eif

; IfThenEpilog
l_0235

; optimize OK (B_CRT), line = 483

	mva VRAM_ADDRESS CRT_VRAM
	mva VRAM_ADDRESS+1 CRT_VRAM+1

; optimize OK (B_CRT), line = 484

	mva WIDTH CRT_SCREENWIDTH

; optimize OK (B_CRT), line = 485

	mva HEIGHT CRT_SCREENHEIGHT

; optimize OK (B_CRT), line = 486

	lda HEIGHT
	sta :ecx
	lda WIDTH
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta CRT_SIZE
	lda :eax+1
	sta CRT_SIZE+1

; optimize OK (B_CRT), line = 487

	mva CRT_VRAM CRT_CURSOR
	mva CRT_VRAM+1 CRT_CURSOR+1

; optimize OK (B_CRT), line = 488

	mva #$00 CRT_LEFTMARGIN

; -----------------------------------------------------------

VRAM_ADDRESS	= DATAORIGIN+$021F
WIDTH	= DATAORIGIN+$0221
HEIGHT	= DATAORIGIN+$0222

@VarData	= VRAM_ADDRESS
@VarDataSize	= 4


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_CLEAR_026E					; PROCEDURE | OVERLOAD

	ift l_0271-*>3
	jmp l_0271
	eif

; IfThenEpilog
l_0271

; optimize OK (B_CRT), line = 504

	lda CRT_VRAM
	sta :edx
	lda CRT_VRAM+1
	sta :edx+1
	lda CRT_SIZE
	sta :ecx
	lda CRT_SIZE+1
	sta :ecx+1
	lda #$00
	sta :eax
	jsr @fill

; optimize OK (B_CRT), line = 505

	mva CRT_VRAM CRT_CURSOR
	mva CRT_VRAM+1 CRT_CURSOR+1

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_GOTOXY					; PROCEDURE

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x Y
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x X
	dex						; sub bx, 1

	ift l_028F-*>3
	jmp l_028F
	eif

; IfThenEpilog
l_028F

; optimize OK (B_CRT), line = 516

	lda CRT_SCREENWIDTH
	sta :ecx
	lda Y
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	add X
	sta :STACKORIGIN+9
	lda :eax+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add CRT_VRAM
	sta CRT_CURSOR
	lda :STACKORIGIN+STACKWIDTH+9
	adc CRT_VRAM+1
	sta CRT_CURSOR+1

; -----------------------------------------------------------

X	= DATAORIGIN+$0223
Y	= DATAORIGIN+$0224

@VarData	= X
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02AA					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x S
	mva :STACKORIGIN+STACKWIDTH,x S+1
	dex						; sub bx, 1
	@move S #adr.S #256
	mwa #adr.S S

	ift l_02B3-*>3
	jmp l_02B3
	eif

; IfThenEpilog
l_02B3

; optimize OK (B_CRT), line = 531

	lda S
	add #$01
	sta :edx
	lda S+1
	adc #$00
	sta :edx+1
	lda adr.S+$00
	sta :eax
	lda CRT_CURSOR
	sta :ecx
	lda CRT_CURSOR+1
	sta :ecx+1
	lda #$00
	sta :eax+1
	jsr @move

; optimize OK (B_CRT), line = 532

	lda CRT_CURSOR
	add adr.S+$00
	sta CRT_CURSOR
	lda CRT_CURSOR+1
	adc #$00
	sta CRT_CURSOR+1

; -----------------------------------------------------------

adr.S	= DATAORIGIN+$0225
.var S	= adr.S .word

@VarData	= S
@VarDataSize	= 256


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02C0					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x C
	dex						; sub bx, 1

	ift l_02C9-*>3
	jmp l_02C9
	eif

; IfThenEpilog
l_02C9

; optimize OK (B_CRT), line = 537

	lda CRT_CURSOR+1
	sta :bp+1
	ldy CRT_CURSOR
	lda C
	sta (:bp),y

; optimize FAIL (0, B_CRT), line = 538
	inw CRT_CURSOR

; -----------------------------------------------------------

C	= DATAORIGIN+$0325

@VarData	= C
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02D4					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x NUM
	dex						; sub bx, 1

	ift l_02DD-*>3
	jmp l_02DD
	eif

; IfThenEpilog
l_02DD

; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 543
	inx
	mva NUM :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr SYSUTILS.INTTOSTR
	jsr ATASCII2ANTIC_01D9
	jsr CRT_WRITE_02AA

; -----------------------------------------------------------

NUM	= DATAORIGIN+$0326

@VarData	= NUM
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02E4					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x NUM
	mva :STACKORIGIN+STACKWIDTH,x NUM+1
	dex						; sub bx, 1

	ift l_02ED-*>3
	jmp l_02ED
	eif

; IfThenEpilog
l_02ED

; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 548
	inx
	mva NUM :STACKORIGIN,x
	mva NUM+1 :STACKORIGIN+STACKWIDTH,x
	jsr @expandToCARD.WORD
	jsr SYSUTILS.INTTOSTR
	jsr ATASCII2ANTIC_01D9
	jsr CRT_WRITE_02AA

; -----------------------------------------------------------

NUM	= DATAORIGIN+$0327

@VarData	= NUM
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_KEYPRESSED					; FUNCTION

	ift l_02F6-*>3
	jmp l_02F6
	eif

; IfThenEpilog
l_02F6

; optimize OK (B_CRT), line = 592

	mva #$00 RESULT

; optimize OK (B_CRT), line = 593

	lda ATARI.SKSTAT
	ldy #1
	and #$04
	beq @+
	dey
@
	.ifdef IFTMP_28
	sty IFTMP_28
	eif
	tya
	bne *+5
	jmp l_0313

; optimize OK (B_CRT), line = 593

	mva #$01 RESULT

; IfThenEpilog
l_0313

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

RESULT	= DATAORIGIN+$0329

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

.local	CRT_STARTPRESSED				; FUNCTION

	ift l_032D-*>3
	jmp l_032D
	eif

; IfThenEpilog
l_032D

; optimize OK (B_CRT), line = 749

	lda ATARI.CONSOL
	ldy #1
	and #$01
	beq @+
	dey
@
	sty RESULT

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

RESULT	= DATAORIGIN+$032A

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

; -----------------------------------------------------------

DEFAULT_SCREENWIDTH	= $0028
DEFAULT_SCREENHEIGHT	= $0018
CHAR_RETURN	= $009B
CHAR_ESCAPE	= $001B
CHAR_BACKSPACE	= $007E
CHAR_TAB	= $007F
CHAR_INVERSE	= $0081
CHAR_CAPS	= $0082
ICHAR_RETURN	= $00DB
ICHAR_ESCAPE	= $005B
ICHAR_BACKSPACE	= $007E
ICHAR_TAB	= $007F
ICHAR_INVERSE	= $00C1
ICHAR_CAPS	= $00C2
adr.CRT_KEYCODE	= CODEORIGIN+$011E
.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
CRT_VRAM	= DATAORIGIN+$0012
CRT_SIZE	= DATAORIGIN+$0014
CRT_SCREENWIDTH	= DATAORIGIN+$0016
CRT_SCREENHEIGHT	= DATAORIGIN+$0017
CRT_CURSOR	= DATAORIGIN+$0018
CRT_LEFTMARGIN	= DATAORIGIN+$001A
KBCODE	= $D209
CONSOL	= $D01F

.endl							; UNIT B_CRT

; -----------------------------------------------------------

.local	B_PMG						; UNIT

.local	PMG_INIT_0344					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x GRACTL
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SDMCTL
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x BASE
	dex						; sub bx, 1

	ift l_0359-*>3
	jmp l_0359
	eif

; IfThenEpilog
l_0359

; optimize OK (B_PMG), line = 159

	mva BASE PMG_PMBASE

; optimize OK (B_PMG), line = 160

	lda #$00
	sta PMG_BASE
	lda BASE
	sta PMG_BASE+1

; optimize OK (B_PMG), line = 161

	mva GRACTL PMG_GRACTL

; optimize OK (B_PMG), line = 162

	lda PMG_SDMCTL_S
	and #$E0
	ora SDMCTL
	sta SDMCTL_FLAGS

; optimize OK (B_PMG), line = 163

	mva SDMCTL_FLAGS PMG_SDMCTL

; optimize OK (B_PMG), line = 164

	mva SDMCTL_FLAGS PMG_SDMCTL_S

; optimize OK (B_PMG), line = 165

	lda SDMCTL
	ldy #1
	and #$10
	bne @+
	dey
@
	.ifdef IFTMP_32
	sty IFTMP_32
	eif
	tya
	bne *+5
	jmp l_03B3

; optimize OK (B_PMG), line = 166

	mva #$01 PMG_ONELINE

; optimize OK (B_PMG), line = 167

	mva #$00 PMG_SIZE
	mva #$08 PMG_SIZE+1

; IfThenEpilog
l_03B3

; Restore conditional expression
	lda IFTMP_32

; else condition
	beq *+5						; je
	jmp l_03CB

; optimize OK (B_PMG), line = 169

	mva #$00 PMG_ONELINE

; optimize OK (B_PMG), line = 170

	sta PMG_SIZE
	mva #$04 PMG_SIZE+1

; IfThenEpilog
l_03CB

; -----------------------------------------------------------

BASE	= DATAORIGIN+$0330
SDMCTL	= DATAORIGIN+$0331
GRACTL	= DATAORIGIN+$0332
SDMCTL_FLAGS	= DATAORIGIN+$0333
IFTMP_32	= DATAORIGIN+$0334

@VarData	= BASE
@VarDataSize	= 5


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	PMG_INIT_03DA					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SDMCTL
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x BASE
	dex						; sub bx, 1

	ift l_03E9-*>3
	jmp l_03E9
	eif

; IfThenEpilog
l_03E9

; optimize FAIL ('PMG_INIT_0344', B_PMG), line = 177
	inx
	mva BASE :STACKORIGIN,x
	inx
	mva SDMCTL :STACKORIGIN,x
	inx
	mva GRACTL :STACKORIGIN,x
	jsr PMG_INIT_0344

; -----------------------------------------------------------

BASE	= DATAORIGIN+$0335
SDMCTL	= DATAORIGIN+$0336
GRACTL	= DATAORIGIN+$0337

@VarData	= BASE
@VarDataSize	= 3


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

PMG_VDELAY_M0	= $0001
PMG_VDELAY_M1	= $0002
PMG_VDELAY_M2	= $0004
PMG_VDELAY_M3	= $0008
PMG_VDELAY_P0	= $0010
PMG_VDELAY_P1	= $0020
PMG_VDELAY_P2	= $0040
PMG_VDELAY_P3	= $0080
PMG_SIZE_NORMAL	= $0000
PMG_SIZE_X2	= $0001
PMG_SIZE_X4	= $0003
PMG_MSIZE0_X2	= $0001
PMG_MSIZE0_X4	= $0003
PMG_MSIZE1_X2	= $0004
PMG_MSIZE1_X4	= $000C
PMG_MSIZE2_X2	= $0010
PMG_MSIZE2_X4	= $0030
PMG_MSIZE3_X2	= $0040
PMG_MSIZE4_X4	= $00C0
PMG_GRACTL_MISSILES	= $0001
PMG_GRACTL_PLAYERS	= $0002
PMG_GRACTL_LATCH	= $0004
PMG_GRACTL_DEFAULT	= $0003
PMG_SDMCTL_DMA_MISSILE	= $0004
PMG_SDMCTL_DMA_PLAYER	= $0008
PMG_SDMCTL_DMA_BOTH	= $000C
PMG_SDMCTL_ONELINE	= $0010
PMG_SDMCTL_SCREEN_DISABLED	= $0000
PMG_SDMCTL_SCREEN_NARROW	= $0001
PMG_SDMCTL_SCREEN_NORMAL	= $0002
PMG_SDMCTL_SCREEN_WIDE	= $0003
PMG_SDMCTL_DEFAULT	= $000E
PMG_5PLAYER	= $0010
PMG_OVERLAP	= $0020
PMG_SDMCTL	= $D400
PMG_SDMCTL_S	= $022F
PMG_GPRIOR	= $D01B
PMG_GPRIOR_S	= $026F
PMG_PCOLR0	= $D012
PMG_PCOLR1	= $D013
PMG_PCOLR2	= $D014
PMG_PCOLR3	= $D015
PMG_PCOLR0_S	= $02C0
PMG_PCOLR1_S	= $02C1
PMG_PCOLR2_S	= $02C2
PMG_PCOLR3_S	= $02C3
PMG_HPOS0	= $D000
PMG_HPOS1	= $D001
PMG_HPOS2	= $D002
PMG_HPOS3	= $D003
PMG_HPOSM0	= $D004
PMG_HPOSM1	= $D005
PMG_HPOSM2	= $D006
PMG_HPOSM3	= $D007
PMG_SIZEP0	= $D008
PMG_SIZEP1	= $D009
PMG_SIZEP2	= $D00A
PMG_SIZEP3	= $D00B
PMG_SIZEM	= $D00C
PMG_GRAFP0	= $D00D
PMG_GRAFP1	= $D00E
PMG_GRAFP2	= $D00F
PMG_GRAFP3	= $D010
PMG_GRAFM	= $D011
PMG_P0PL	= $D00C
PMG_P1PL	= $D00D
PMG_P2PL	= $D00E
PMG_P3PL	= $D00F
PMG_VDELAY	= $D01C
PMG_GRACTL	= $D01D
PMG_HITCLR	= $D01E
PMG_PMBASE	= $D407
PMG_ONELINE	= DATAORIGIN+$032B
PMG_BASE	= DATAORIGIN+$032C
PMG_SIZE	= DATAORIGIN+$032E

.endl							; UNIT B_PMG

; -----------------------------------------------------------

.local	B_SET_INTERUPTS					; UNIT

.local	SETVBLI						; PROCEDURE | ASSEMBLER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x VBLPTR
	mva :STACKORIGIN+STACKWIDTH,x VBLPTR+1
	dex						; sub bx, 1


; ---------------------  ASM Block 066  ---------------------


	mwa vblptr vvblki


; -----------------------------------------------------------

VBLPTR	= DATAORIGIN+$0339

@VarData	= VBLPTR
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

__NMIEN	= DATAORIGIN+$0338
PORTB_SELFTEST_OFF	= $0080
PORTB_BASIC_OFF	= $0002
PORTB_SYSTEM_ON	= $0001

.endl							; UNIT B_SET_INTERUPTS

.local	TITLEVBI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 069  ---------------------


		lda #<title00dli
		sta vdslst+0
		lda #>title00dli
		sta vdslst+1
		lda #$22
		sta colbak
		lda #$36
		sta colpf3				
		inc rtclok+2
		jmp XITVBV
	
	rti						; ret
.endl

.local	GAMEVBI						; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 070  ---------------------


		lda #<title00dli
		sta vdslst+0
		lda #>title00dli
		sta vdslst+1
		lda #$22
		sta colbak
		lda #$36
		sta colpf3		
inc_rt_clock
		inc rtclok+2
		bne no_inc_other_clock
		inc rtclok+1
		bne no_inc_other_clock
		inc rtclok
no_inc_other_clock				
		jmp XITVBV
	
	rti						; ret
.endl

.local	PAUSEVBI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 071  ---------------------


	rti						; ret
.endl

.local	TITLE00DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 072  ---------------------


	pha	
	lda #$D8
	sta wsync
	sta colpf0
	lda #$06
	sta colpf1
	lda #$AA
	sta colpf2
	lda #>CHARSET_TITLE
	sta chbase
	lda #<title01dli
	sta vdslst+0
	lda #>title01dli
	sta vdslst+1
	pla
	rti
	rti						; ret
.endl

.local	TITLE01DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 073  ---------------------


	pha	
	lda #142
	sta wsync
	sta colpf0
	lda #10
	sta colpf1
	lda #186
	sta colpf2
	lda #>CHARSET_GAME
 	sta chbase
	lda #<title00dli
	sta vdslst+0
	lda #>title00dli
	sta vdslst+1
	pla
	rti
	rti						; ret
.endl

.local	TITLE02DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 074  ---------------------

phr
	plr
	rti						; ret
.endl

.local	TITLE03DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 075  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME00DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 076  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME01DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 077  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME02DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 078  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME03DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 079  ---------------------

phr
	plr
	rti						; ret
.endl

.local	SHOWTITLESCREEN					; PROCEDURE

	ift l_0409-*>3
	jmp l_0409
	eif

; IfThenEpilog
l_0409

; optimize OK (Mind Field.pas), line = 489

	lda #$00
	sta TOPMEM
	lda CHBASE1
	sta TOPMEM+1

; ---------------------  ASM Block 080  ---------------------


;	  ICL "Atari 8-bit Equates.asm"
		
    lda #0
    sta 82
    sta 710
    lda #12
    sta 709
    ; lda chbase1
    ; sta 756
    LDA #0
    STA NMIEN
    STA DMACTL
    STA PRIOR
    STA HITCLR

;    LDX #>RamSizeCode+1
    LDY #$00
    STY NDX0
    STY NDX2
    LDA #$38
    STA NDX1
    LDA #$A8
    STA NDX3
    

; optimize OK (Mind Field.pas), line = 515

	mva #$00 ATARI.DMACTL

; optimize OK (Mind Field.pas), line = 516

	sta ATARI.NMIEN

; optimize FAIL ('B_CRT.CRT_INIT_0220', Mind Field.pas), line = 517
	inx
	mva #$00 :STACKORIGIN,x
	mva #$08 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$28 :STACKORIGIN,x
	inx
	mva #$19 :STACKORIGIN,x
	jsr B_CRT.CRT_INIT_0220

; optimize OK (Mind Field.pas), line = 518

	mva <TITLE00DLI VDSLST
	mva >TITLE00DLI VDSLST+1

; optimize FAIL ('B_SET_INTERUPTS.SETVBLI', Mind Field.pas), line = 520
	inx
	mva <TITLEVBI :STACKORIGIN,x
	mva >TITLEVBI :STACKORIGIN+STACKWIDTH,x
	jsr B_SET_INTERUPTS.SETVBLI

; optimize FAIL ('B_CRT.CRT_CLEAR_026E', Mind Field.pas), line = 521
	jsr B_CRT.CRT_CLEAR_026E

; optimize OK (Mind Field.pas), line = 522

	mva #$1E ATARI.DLISTW
	mva #$82 ATARI.DLISTW+1

; optimize OK (Mind Field.pas), line = 523

	mva #$1E ATARI.SDLSTW
	mva #$82 ATARI.SDLSTW+1

; optimize OK (Mind Field.pas), line = 524

	mva #$00 ATARI.SAVMSC
	mva #$08 ATARI.SAVMSC+1

; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 525
	inx
	mva #$A4 :STACKORIGIN,x
	jsr B_SYSTEM.SETCHARSET

; optimize OK (Mind Field.pas), line = 526

	mva #$A4 ATARI.CHBAS

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 527
	inx
	mva #$00 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 528
	inx
	mva #$02 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 529
	inx
	mva #$2C :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 530
	inx
	mva #$56 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 531
	inx
	mva #$80 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 532
	inx
	mva #$AA :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA

; optimize OK (Mind Field.pas), line = 533

	mva #$00 TMP5

; optimize OK (Mind Field.pas), line = 534

	mva #$01 ATARI.GPRIOR

; optimize OK (Mind Field.pas), line = 535

	sta ATARI.PRIOR

; optimize OK (Mind Field.pas), line = 536

	mva #$06 K

; optimize OK (Mind Field.pas), line = 537

	mva #$05 I

; optimize OK (Mind Field.pas), line = 539

	mva #$D8 ATARI.COLOR0

; optimize OK (Mind Field.pas), line = 540

	mva #$06 ATARI.COLOR1

; optimize OK (Mind Field.pas), line = 541

	mva #$AA ATARI.COLOR2

; optimize OK (Mind Field.pas), line = 542

	mva #$36 ATARI.COLOR3

; optimize OK (Mind Field.pas), line = 543

	mva #$22 ATARI.COLOR4

; optimize FAIL ('B_PMG.PMG_INIT_03DA', Mind Field.pas), line = 545
	inx
	mva #$18 :STACKORIGIN,x
	inx
	mva #$3E :STACKORIGIN,x
	jsr B_PMG.PMG_INIT_03DA

; optimize OK (Mind Field.pas), line = 546

	mva #$C0 ATARI.NMIEN

; --- RepeatUntilProlog
l_04A6

; optimize OK (Mind Field.pas), line = 549

	lda I
	asl @
	tay
	lda adr.HISCORE,y
	sta :STACKORIGIN+10
	lda adr.HISCORE+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #1
	lda SCORE+1
	cmp :STACKORIGIN+STACKWIDTH+10
	bne @+
	lda SCORE
	cmp :STACKORIGIN+10
@
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_33
	sty IFTMP_33
	eif
	tya
	bne *+5
	jmp l_04BB

; optimize OK (Mind Field.pas), line = 551

	mva I K

; IfThenEpilog
l_04BB

; optimize OK (Mind Field.pas), line = 553

	dec I

; optimize OK (Mind Field.pas), line = 554

	ldy #1
	lda I
	beq @+
	dey
@
	tya
	bne *+5
c_04A6
	jmp l_04A6
b_04A6

; optimize OK (Mind Field.pas), line = 555

	ldy #1
	lda K
	cmp #$05
	bcc @+
	dey
@
	.ifdef IFTMP_34
	sty IFTMP_34
	eif
	tya
	bne *+5
	jmp l_04F3

; optimize OK (Mind Field.pas), line = 557

	mva #$05 I

; --- RepeatUntilProlog
l_04FC

; optimize OK (Mind Field.pas), line = 559

	lda I
	asl @
	sta :STACKORIGIN+9
	lda I
	sub #$01
	asl @
	tay
	lda adr.HISCORE,y
	sta :STACKORIGIN+10
	lda adr.HISCORE+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy :STACKORIGIN+9
	lda :STACKORIGIN+10
	sta adr.HISCORE,y
	lda :STACKORIGIN+STACKWIDTH+10
	sta adr.HISCORE+1,y

; optimize OK (Mind Field.pas), line = 560

	dec I

; optimize OK (Mind Field.pas), line = 561

	ldy #1
	lda I
	cmp K
	beq @+
	dey
@
	tya
	bne *+5
c_04FC
	jmp l_04FC
b_04FC

; optimize OK (Mind Field.pas), line = 562

	lda K
	asl @
	tay
	lda SCORE
	sta adr.HISCORE,y
	lda SCORE+1
	sta adr.HISCORE+1,y

; IfThenEpilog
l_04F3

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 564
	inx
	mva #$0A :STACKORIGIN,x
	inx
	mva #$06 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 565
	inx
	mva #$D4 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 566
	inx
	mva #$12 :STACKORIGIN,x
	inx
	mva #$06 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02E4', Mind Field.pas), line = 567
	inx
	mva SCORE :STACKORIGIN,x
	mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02E4

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 568
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 569
	inx
	mva #$DE :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA
; For

; optimize OK (Mind Field.pas), line = 570

	mva #$01 I

; optimize OK (Mind Field.pas), line = 570

; To
l_0550

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 570

	lda I
	cmp #$05
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_055E

; optimize OK (Mind Field.pas), line = 572

	ldy #1
	lda K
	cmp I
	beq @+
	dey
@
	.ifdef IFTMP_35
	sty IFTMP_35
	eif
	tya
	bne *+5
	jmp l_0572

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 574
	inx
	mva #$0C :STACKORIGIN,x
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva I :STACKORIGIN,x
	jsr addAL_CL
	dex
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02C0', Mind Field.pas), line = 575
	inx
	mva #$0A :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_02C0

; IfThenEpilog
l_0572

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 577
	inx
	mva #$0E :STACKORIGIN,x
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva I :STACKORIGIN,x
	jsr addAL_CL
	dex
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02D4', Mind Field.pas), line = 578
	inx
	mva I :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_02D4

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 579
	inx
	mva #$F3 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 580
	inx
	mva #$12 :STACKORIGIN,x
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva I :STACKORIGIN,x
	jsr addAL_CL
	dex
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02E4', Mind Field.pas), line = 581
	inx
	mva I :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	m@index2 0
	ldy :STACKORIGIN,x
	mva adr.HISCORE,y :STACKORIGIN,x
	mva adr.HISCORE+1,y :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02E4

; ForToDoEpilog
c_0550
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0550
l_055E
b_0550

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 583
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva #$0F :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 584
	inx
	mva #$F7 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA

; optimize OK (Mind Field.pas), line = 585

	lda #$00
	sta :bp+1
	ldy ATARI.HPOSP0
	lda #$7C
	sta (:bp),y

; --- RepeatUntilProlog
l_05AE

; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 596
	jsr B_CRT.CRT_STARTPRESSED
	.ifdef IFTMP_36
	lda :STACKORIGIN,x
	sta IFTMP_36
	eif
	dex
	lda :STACKORIGIN+1,x
	bne *+5
	jmp l_05B8

; optimize OK (Mind Field.pas), line = 596

	mva #$FF TMP5

; IfThenEpilog
l_05B8

; optimize OK (Mind Field.pas), line = 600

	ldy #1
	lda TMP5
	cmp #$FF
	beq @+
	dey
@
	tya
	bne *+5
c_05AE
	jmp l_05AE
b_05AE

; optimize OK (Mind Field.pas), line = 602

	mva #$40 ATARI.NMIEN

; --- RepeatUntilProlog
l_05D7

; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 604
	jsr B_CRT.CRT_STARTPRESSED
	inx
	mva #$00 :STACKORIGIN,x
	ldy #1
	lda :STACKORIGIN-1,x
	cmp :STACKORIGIN,x
	beq @+
	dey
@
	sty :STACKORIGIN-1,x
	dex
	dex
	lda :STACKORIGIN+1,x
	bne *+5
c_05D7
	jmp l_05D7
b_05D7

; ---------------------  ASM Block 081  ---------------------


//    ORG 32768
//    ICL "inflate_2017_ver4.asm"
//    ORG 46080
//    INS "roman10.fnt" 


; -----------------------------------------------------------

@FORTMP_1354	= $0005

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	INITIALIZE_LEVEL				; PROCEDURE

	ift l_05E6-*>3
	jmp l_05E6
	eif

; IfThenEpilog
l_05E6
; For

; optimize OK (Mind Field.pas), line = 619

	mva #$00 I

; optimize OK (Mind Field.pas), line = 619

; To
l_05F5

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 619

	lda I
	cmp #$FF
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0603

; ---------------------  ASM Block 082  ---------------------


	LDA RANDOM
	CLC
	ADC #<game_screen
	STA NDX0
	LDA RANDOM
	AND #3
	ADC #>game_screen
	STA NDX1
	LDA RANDOM
	AND #3
	ORA #68
	LDY #0
	STA (NDX0),Y


; ForToDoEpilog
c_05F5
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_05F5
l_0603
b_05F5
; For

; optimize OK (Mind Field.pas), line = 639

	mva #$00 I

; optimize OK (Mind Field.pas), line = 639

; To
l_0617

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 639

	lda I
	cmp #$3F
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0625

; ---------------------  ASM Block 083  ---------------------


	LDA RANDOM
	CLC
	ADC #<game_screen
	STA NDX0
	LDA RANDOM
	AND #3
	ADC #>game_screen
	STA NDX1
	LDA #193
	LDY #0
	STA (NDX0),Y


; ForToDoEpilog
c_0617
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0617
l_0625
b_0617

; -----------------------------------------------------------

@FORTMP_1519	= $00FF
@FORTMP_1553	= $003F

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	DISPLAY_INFORMATION_LINE			; PROCEDURE

	ift l_062E-*>3
	jmp l_062E
	eif

; IfThenEpilog
l_062E

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 659
	inx
	mva #$00 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 660
	inx
	mva #$0E :STACKORIGIN,x
	mva #$81 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 661
	inx
	mva #$06 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02E4', Mind Field.pas), line = 662
	inx
	mva SCORE :STACKORIGIN,x
	mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02E4

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 664
	inx
	mva #$0E :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02AA', Mind Field.pas), line = 665
	inx
	mva #$16 :STACKORIGIN,x
	mva #$81 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02AA

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 666
	inx
	mva #$14 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02D4', Mind Field.pas), line = 667
	inx
	mva LIVES :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_02D4

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; IfThenEpilog
l_0125

; --- RepeatUntilProlog
l_0647

; optimize FAIL ('SHOWTITLESCREEN', Mind Field.pas), line = 680
	jsr SHOWTITLESCREEN

; optimize OK (Mind Field.pas), line = 683

	mva #$00 SCORE
	sta SCORE+1

; optimize OK (Mind Field.pas), line = 684

	mva #$05 LIVES

; optimize FAIL ('B_CRT.CRT_INIT_0220', Mind Field.pas), line = 685
	inx
	mva #$00 :STACKORIGIN,x
	mva #$08 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$28 :STACKORIGIN,x
	inx
	mva #$1A :STACKORIGIN,x
	jsr B_CRT.CRT_INIT_0220

; optimize FAIL ('B_CRT.CRT_CLEAR_026E', Mind Field.pas), line = 686
	jsr B_CRT.CRT_CLEAR_026E

; optimize FAIL ('DISPLAY_INFORMATION_LINE', Mind Field.pas), line = 687
	jsr DISPLAY_INFORMATION_LINE

; optimize OK (Mind Field.pas), line = 688

	mva #$53 ATARI.DLISTW
	mva #$82 ATARI.DLISTW+1

; optimize OK (Mind Field.pas), line = 689

	mva #$53 ATARI.SDLSTW
	mva #$82 ATARI.SDLSTW+1

; optimize OK (Mind Field.pas), line = 690

	mva #$00 ATARI.SAVMSC
	mva #$08 ATARI.SAVMSC+1

; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 691
	inx
	mva #$A4 :STACKORIGIN,x
	jsr B_SYSTEM.SETCHARSET

; optimize OK (Mind Field.pas), line = 692

	mva #$A4 ATARI.CHBAS

; optimize FAIL ('INITIALIZE_LEVEL', Mind Field.pas), line = 693
	jsr INITIALIZE_LEVEL

; optimize OK (Mind Field.pas), line = 694

	mva #$8E ATARI.COLOR0

; optimize OK (Mind Field.pas), line = 695

	mva #$D4 ATARI.COLOR1

; optimize OK (Mind Field.pas), line = 696

	mva #$46 ATARI.COLOR2

; optimize OK (Mind Field.pas), line = 697

	mva #$96 ATARI.COLOR3

; optimize OK (Mind Field.pas), line = 698

	mva #$22 ATARI.COLOR4

; optimize OK (Mind Field.pas), line = 699

	mva #$CA ATARI.COLPM0

; optimize OK (Mind Field.pas), line = 700

	mva #$FA ATARI.COLPM1

; optimize OK (Mind Field.pas), line = 701

	mva #$88 ATARI.COLPM2

; optimize OK (Mind Field.pas), line = 702

	mva #$24 ATARI.COLPM3

; optimize OK (Mind Field.pas), line = 703

	mva #$00 ATARI.SIZEP0

; optimize OK (Mind Field.pas), line = 704

	sta ATARI.SIZEP1

; optimize OK (Mind Field.pas), line = 705

	sta ATARI.SIZEP2

; optimize OK (Mind Field.pas), line = 706

	sta ATARI.SIZEP3

; optimize FAIL ('B_SET_INTERUPTS.SETVBLI', Mind Field.pas), line = 707
	inx
	mva <GAMEVBI :STACKORIGIN,x
	mva >GAMEVBI :STACKORIGIN+STACKWIDTH,x
	jsr B_SET_INTERUPTS.SETVBLI

; optimize FAIL ('B_PMG.PMG_INIT_03DA', Mind Field.pas), line = 708
	inx
	mva #$18 :STACKORIGIN,x
	inx
	mva #$3E :STACKORIGIN,x
	jsr B_PMG.PMG_INIT_03DA

; optimize OK (Mind Field.pas), line = 709

	mva #$C0 ATARI.NMIEN

; optimize OK (Mind Field.pas), line = 712

	mva #$7C CHARACTER_PX

; optimize OK (Mind Field.pas), line = 713

	mva #$78 CHARACTER_PY

; optimize OK (Mind Field.pas), line = 714

	mva #$00 F

; optimize OK (Mind Field.pas), line = 719

	mva RT_CHECK PRIOR_RT_CLOCK

; --- RepeatUntilProlog
l_0700

; optimize OK (Mind Field.pas), line = 721

	ldy #1
	lda PRIOR_RT_CLOCK
	cmp RT_CHECK
	bne @+
	dey
@
	.ifdef IFTMP_37
	sty IFTMP_37
	eif
	tya
	bne *+5
	jmp l_0714

; optimize OK (Mind Field.pas), line = 722

	mva RT_CHECK PRIOR_RT_CLOCK

; optimize OK (Mind Field.pas), line = 723

	lda PRIOR_PY
	sta :edx
	lda #$1C
	sta :edx+1
	lda #$0E
	sta :ecx
	lda #$00
	sta :ecx+1
	sta :eax
	jsr @fill

; optimize OK (Mind Field.pas), line = 724

	lda F
	asl @
	tay
	lda adr.SPRITEFRAMES,y
	sta :edx
	lda adr.SPRITEFRAMES+1,y
	sta :edx+1
	lda CHARACTER_PY
	sta :ecx
	lda #$1C
	sta :ecx+1
	lda #$0E
	sta :eax
	lda #$00
	sta :eax+1
	jsr @move

; optimize OK (Mind Field.pas), line = 725

	mva CHARACTER_PX ATARI.HPOSP0

; optimize OK (Mind Field.pas), line = 726

	mva CHARACTER_PY PRIOR_PY

; optimize OK (Mind Field.pas), line = 727

	lda ATARI.PORTA
	and #$0F
	sta STICK_READ

; ---------------------  ASM Block 084  ---------------------


									lda RT_CHECK
									AND #4
									STA G
		            

; optimize OK (Mind Field.pas), line = 733

	mva #$00 F

; optimize OK (Mind Field.pas), line = 734

	lda STICK_READ
	ldy #1
	and #$01
	beq @+
	dey
@
	.ifdef IFTMP_38
	sty IFTMP_38
	eif
	tya
	bne *+5
	jmp l_0772

; optimize OK (Mind Field.pas), line = 735

	dec CHARACTER_PY

; optimize OK (Mind Field.pas), line = 736

	lda #$01
	add G
	sta F

; IfThenEpilog
l_0772

; optimize OK (Mind Field.pas), line = 738

	lda STICK_READ
	ldy #1
	and #$02
	beq @+
	dey
@
	.ifdef IFTMP_39
	sty IFTMP_39
	eif
	tya
	bne *+5
	jmp l_07A5

; optimize OK (Mind Field.pas), line = 739

	inc CHARACTER_PY

; optimize OK (Mind Field.pas), line = 740

	lda #$03
	add G
	sta F

; IfThenEpilog
l_07A5

; optimize OK (Mind Field.pas), line = 742

	lda STICK_READ
	ldy #1
	and #$04
	beq @+
	dey
@
	.ifdef IFTMP_40
	sty IFTMP_40
	eif
	tya
	bne *+5
	jmp l_07D8

; optimize OK (Mind Field.pas), line = 743

	dec CHARACTER_PX

; optimize OK (Mind Field.pas), line = 744

	lda #$02
	add G
	sta F

; IfThenEpilog
l_07D8

; optimize OK (Mind Field.pas), line = 746

	lda STICK_READ
	ldy #1
	and #$08
	beq @+
	dey
@
	.ifdef IFTMP_41
	sty IFTMP_41
	eif
	tya
	bne *+5
	jmp l_080B

; optimize OK (Mind Field.pas), line = 747

	inc CHARACTER_PX

; optimize OK (Mind Field.pas), line = 748

	lda #$04
	add G
	sta F

; IfThenEpilog
l_080B

; IfThenEpilog
l_0714

; optimize FAIL ('B_CRT.CRT_KEYPRESSED', Mind Field.pas), line = 751
	jsr B_CRT.CRT_KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	bne *+5
c_0700
	jmp l_0700
b_0700

; optimize OK (Mind Field.pas), line = 753

	lda #$00
	bne *+5
c_0647
	jmp l_0647
b_0647

; -----------------------------------------------------------

SCREEN_ADDR	= $0800
GAME_SCREEN	= $0828
PMBANK	= $1800
VARBANK	= $0600
CHARSET_GAME	= $A400
CHARSET_TITLE	= $A800
TITLE_DATA	= $AC00
CHARSET_BASE	= $00A4
MIBANK	= $1B00
PMBNK0	= $1C00
PMBNK1	= $1D00
PMBNK2	= $1E00
PMBNK3	= $1F00
adr.DISPLAY_LIST_TITLE	= CODEORIGIN+$021E
.var DISPLAY_LIST_TITLE	= adr.DISPLAY_LIST_TITLE .word
adr.DISPLAY_LIST_GAME	= CODEORIGIN+$0253
.var DISPLAY_LIST_GAME	= adr.DISPLAY_LIST_GAME .word
adr.P000	= CODEORIGIN+$0276
.var P000	= adr.P000 .word
adr.P001	= CODEORIGIN+$0284
.var P001	= adr.P001 .word
adr.P002	= CODEORIGIN+$0292
.var P002	= adr.P002 .word
adr.P003	= CODEORIGIN+$02A0
.var P003	= adr.P003 .word
adr.P004	= CODEORIGIN+$02AE
.var P004	= adr.P004 .word
adr.P005	= CODEORIGIN+$02BC
.var P005	= adr.P005 .word
adr.P006	= CODEORIGIN+$02CA
.var P006	= adr.P006 .word
adr.P007	= CODEORIGIN+$02D8
.var P007	= adr.P007 .word
adr.P008	= CODEORIGIN+$02E6
.var P008	= adr.P008 .word
adr.P009	= CODEORIGIN+$02F4
.var P009	= adr.P009 .word
adr.P010	= CODEORIGIN+$0302
.var P010	= adr.P010 .word
adr.P011	= CODEORIGIN+$0310
.var P011	= adr.P011 .word
adr.P012	= CODEORIGIN+$031E
.var P012	= adr.P012 .word
adr.P013	= CODEORIGIN+$032C
.var P013	= adr.P013 .word
adr.P014	= CODEORIGIN+$033A
.var P014	= adr.P014 .word
adr.P015	= CODEORIGIN+$0348
.var P015	= adr.P015 .word
adr.P016	= CODEORIGIN+$0356
.var P016	= adr.P016 .word
adr.P017	= CODEORIGIN+$0364
.var P017	= adr.P017 .word
adr.P018	= CODEORIGIN+$0372
.var P018	= adr.P018 .word
adr.P019	= CODEORIGIN+$0380
.var P019	= adr.P019 .word
adr.SPRITEFRAMES	= CODEORIGIN+$038E
.var SPRITEFRAMES	= adr.SPRITEFRAMES .word
RT_CHECK	= $0014
PRIOR	= $D01B
TMP0	= $00E0
TMP1	= $00E1
TMP2	= $00E2
TMP3	= $00E3
TMP4	= $00E4
TMP5	= $00E5
TMP6	= $00E6
TMP7	= $00E7
TMP8	= $00E8
TMP9	= $00E9
NDX0	= $00EA
NDX1	= $00EB
NDX2	= $00EC
NDX3	= $00ED
HOLDX	= $00EE
HOLDY	= $00EF
SPRITENUM	= $1980
SETSP0COLOR	= $1990
SETSP1COLOR	= $19A0
SETSPWIDTH	= $19B0
SPRITENHOZ	= $19C0
SPRITENVRT	= $19E0
SPHOZNEXT	= $19F0
SCREEN_LINE_ADDR_LOW	= $1800
SCREEN_LINE_ADDR_HIGH	= $1820
SPRHZ0	= $1A00
SPRHZ1	= $1A10
SPRHZ2	= $1A20
SPRHZ3	= $1A30
SPZONT	= $1A40
SPZONB	= $1A50
SPSRC0	= $1A60
SPSRC1	= $1A78
SPSRC2	= $1A90
SPSRC3	= $1AA8
SPSRC4	= $1AC0
SPRITEUSE	= $1AD8
A	= DATAORIGIN+$033B
B	= DATAORIGIN+$033C
C	= DATAORIGIN+$033D
D	= DATAORIGIN+$033E
E	= DATAORIGIN+$033F
F	= DATAORIGIN+$0340
G	= DATAORIGIN+$0341
H	= DATAORIGIN+$0342
I	= DATAORIGIN+$0343
J	= DATAORIGIN+$0344
K	= DATAORIGIN+$0345
L	= DATAORIGIN+$0346
CHARACTER_PX	= DATAORIGIN+$0347
CHARACTER_PY	= DATAORIGIN+$0348
PRIOR_PY	= DATAORIGIN+$0349
STICK_READ	= DATAORIGIN+$034A
PRIOR_RT_CLOCK	= DATAORIGIN+$034B
TITLEPHASE	= DATAORIGIN+$034C
SCORE	= DATAORIGIN+$034D
LIVES	= DATAORIGIN+$034F
adr.HISCORE	= DATAORIGIN+$0350
.var HISCORE	= adr.HISCORE .word
TOPMEM	= DATAORIGIN+$0366
CHBASE1	= DATAORIGIN+$0368

@exit

@halt	ldx #0
	txs

	rts

IOCB@COPY	:16 brk

.local	@DEFINES
ATARI
PLATFORM_ATARI_ANTIC
PLATFORM_ATARI_8_BIT
.endl

.endl

; -----------------------------------------------------------

	icl 'cpu6502.asm'

; -----------------------------------------------------------

.macro UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	eif

	.ifdef MAIN.ATARI.@UnitInit
	jsr MAIN.ATARI.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_SYSTEM.@UnitInit
	jsr MAIN.B_SYSTEM.@UnitInit
	eif

	.ifdef MAIN.SYSUTILS.@UnitInit
	jsr MAIN.SYSUTILS.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_CRT.@UnitInit
	jsr MAIN.B_CRT.@UnitInit
	eif

	.ifdef MAIN.B_PMG.@UnitInit
	jsr MAIN.B_PMG.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_SET_INTERUPTS.@UnitInit
	jsr MAIN.B_SET_INTERUPTS.@UnitInit
	eif
.endm

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.ATARI) > 0
	.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
	eif

	ift .SIZEOF(MAIN.B_SYSTEM) > 0
	.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.SYSUTILS) > 0
	.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
	eif

	ift .SIZEOF(MAIN.B_CRT) > 0
	.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
	eif

	ift .SIZEOF(MAIN.B_PMG) > 0
	.print 'B_PMG: ',MAIN.B_PMG,'..',MAIN.B_PMG+.SIZEOF(MAIN.B_PMG)-1
	eif

	ift .SIZEOF(MAIN.B_SET_INTERUPTS) > 0
	.print 'B_SET_INTERUPTS: ',MAIN.B_SET_INTERUPTS,'..',MAIN.B_SET_INTERUPTS+.SIZEOF(MAIN.B_SET_INTERUPTS)-1
	eif

	.print 'CODE: ',CODEORIGIN,'..',*-1

	org $A000

DATAORIGIN

.by  $28 $00 $18 $00 $0C $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $03  $0E $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $9A $10 $00  $00 $00 $4C $1D $7C $15 $AC $0D  $C4 $09 $F4 $01

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 873

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

	run START

; -----------------------------------------------------------

.macro	STATICDATA
.by  $00 $00 $28 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $21 $34  $21 $32 $29 $00 $18 $0D $22 $29
.by  $34 $00 $36 $25 $32 $33 $29 $2F  $2E $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $28 $00 $30 $32
.by  $2F $27 $32 $21 $2D $2D $29 $2E  $27 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $30 $25
.by  $34 $25 $32 $00 $2A $0E $00 $2D  $25 $39 $25 $32 $00 $00 $28 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $08 $39 $2F  $35 $32 $00 $2E $21 $2D $25 $00  $23 $2F $35 $2C $24 $00 $22 $25
.by  $00 $28 $25 $32 $25 $09 $00 $00  $28 $00 $27 $32 $21 $30 $28 $29  $23 $33 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $28 $00 $33 $2F $35 $2E  $24 $00 $21 $2E $24 $00 $2D $35  $33 $29 $23 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $08 $33 $23 $2F
.by  $32 $25 $00 $1A $00 $00 $13 $34  $2F $24 $21 $39 $33 $00 $28 $29  $27 $28 $00 $33 $23 $2F $32 $25
.by  $33 $0E $00 $02 $00 $1A $00 $15  $30 $32 $25 $33 $33 $00 $33 $34  $21 $32 $34 $00 $34 $2F $00 $22
.by  $25 $27 $29 $2E $0E $00 $06 $33  $23 $2F $32 $25 $1A $00 $06 $2C  $29 $36 $25 $33 $1A $00 $6C $6A
.by  $3B $FF $FF $6B $2B $2A $6F $FF  $70 $75 $9B $69 $2D $3D $76 $FF  $63 $FF $FF $62 $78 $7A $34 $FF
.by  $33 $36 $1B $35 $32 $31 $2C $20  $2E $6E $FF $6D $2F $81 $72 $FF  $65 $79 $7F $74 $77 $71 $39 $FF
.by  $30 $37 $7E $38 $3E $FF $66 $68  $64 $FF $82 $67 $73 $61 $4C $4A  $3A $FF $FF $4B $5C $5E $4F $FF
.by  $50 $55 $FF $49 $5F $7C $56 $FF  $43 $FF $FF $42 $58 $5A $24 $FF  $23 $26 $FF $25 $22 $21 $5B $3B
.by  $5D $4E $FF $4D $3F $FF $52 $FF  $45 $59 $FF $54 $57 $51 $28 $FF  $29 $27 $FF $40 $FF $FF $46 $48
.by  $44 $FF $FF $47 $53 $41 $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $70 $C0  $44 $00 $AC $04 $04 $04 $04 $04
.by  $04 $84 $00 $44 $00 $08 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04
.by  $00 $04 $00 $04 $00 $04 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04  $41 $1E $82 $70 $70 $44 $00 $08
.by  $10 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04
.by  $04 $04 $04 $41 $53 $82 $10 $38  $38 $7C $7C $7C $7C $38 $38 $38  $28 $28 $28 $28 $10 $38 $38 $78
.by  $78 $7C $7E $3A $3A $38 $28 $2C  $24 $20 $1C $1C $0C $1E $1E $1E  $1E $1C $18 $38 $38 $2C $24 $0C
.by  $10 $38 $38 $3C $3C $7C $FC $B8  $B8 $38 $28 $2C $24 $20 $1C $1C  $18 $3C $3C $3C $3C $1C $0C $0E
.by  $0E $1A $12 $18 $10 $38 $38 $3C  $3C $7C $FC $B8 $B8 $38 $28 $68  $48 $48 $1C $1C $0C $1C $1E $1F
.by  $7E $1C $18 $1C $14 $16 $12 $16  $10 $38 $38 $78 $78 $7C $7E $3A  $3A $38 $28 $68 $48 $48 $1C $1C
.by  $18 $1C $3C $7C $3F $1C $0C $1C  $14 $34 $24 $34 $C3 $C3 $66 $3C  $18 $3C $7E $7E $7E $7E $7E $7E
.by  $3C $18 $00 $C6 $C6 $6C $38 $38  $7C $7C $7C $7C $7C $7C $38 $10  $00 $66 $66 $3C $18 $18 $3C $3C
.by  $3C $3C $3C $3C $18 $00 $00 $00  $C3 $66 $3C $18 $3C $7E $7E $7E  $7E $18 $00 $00 $00 $00 $C6 $6C
.by  $38 $10 $38 $7C $7C $7C $7C $38  $00 $00 $00 $00 $00 $66 $3C $18  $18 $3C $3C $3C $18 $00 $00 $00
.by  $00 $00 $00 $00 $6C $38 $10 $38  $38 $38 $10 $00 $00 $00 $00 $00  $00 $00 $18 $24 $24 $24 $24 $18
.by  $00 $00 $00 $00 $00 $00 $18 $24  $42 $42 $42 $42 $42 $42 $24 $18  $00 $00 $00 $18 $24 $42 $81 $81
.by  $81 $81 $81 $81 $42 $24 $18 $00  $3C $42 $42 $81 $81 $81 $81 $81  $81 $81 $81 $42 $42 $3C $76 $82
.by  $84 $82 $92 $82 $A0 $82 $AE $82  $BC $82 $CA $82 $D8 $82 $E6 $82  $F4 $82 $02 $83 $10 $83 $1E $83
.by  $2C $83 $3A $83 $48 $83 $56 $83  $64 $83 $72 $83 $80 $83
.endm

	end
