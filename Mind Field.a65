STACKWIDTH	= 16
CODEORIGIN	= $8000

TRUE		= 1
FALSE		= 0

	org $C0

	.print 'ZPFREE: $0000..',*-1

fxptr	.ds 2

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4
bp	.ds 2
bp2	.ds 2

ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

TMP	.ds 2

	org $0080

STACKORIGIN	.ds STACKWIDTH*4

	.print 'ZPFREE: ',*,'..',$ff

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

.local	RESOURCE
	icl 'res6502.asm'

	RCDATA 'MINDFIELD.FNT' CHARSET_GAME 0 0 0 0 0 0 0 0
	RCDATA 'MIND FIELD TITLE.FNT' CHARSET_TITLE 0 0 0 0 0 0 0 0
	RCDATA 'Mind Field Title Screen.txt' TITLE_DATA 0 0 0 0 0 0 0 0
.endl

; -----------------------------------------------------------

	org CODEORIGIN

	STATICDATA

START
	tsx
	stx MAIN.@halt+1

	.ifdef fmulinit
	fmulinit
	eif

	ift DATAORIGIN+VARINITSIZE > $BFFF
	ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
	els
	@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
	eif

	ldx #$0f
	mva:rpl $340,x MAIN.IOCB@COPY,x-

	mvx #$00 bp					; lo BP = 0, X = 0 !!!

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	ift l_0125-*>3
	jmp l_0125
	eif

; -----------------------------------------------------------

.local	SYSTEM						; UNIT

.local	PEEK						; FUNCTION | ASSEMBLER | REGISTER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 004  ---------------------

	ldy #0
	mva (edx),y Result


@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

A	= edx
RESULT	= DATAORIGIN+$000A

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 021  ---------------------

	ldy #0
	mva value (edx),y


; -----------------------------------------------------------

A	= edx
VALUE	= ecx

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	FILLCHAR_0156					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 024  ---------------------

	jsr @fill


; -----------------------------------------------------------

A	= edx
COUNT	= ecx
VALUE	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	FILLBYTE_0169					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 029  ---------------------

	jsr @fill


; -----------------------------------------------------------

A	= edx
COUNT	= ecx
VALUE	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	MOVE_017C					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x DEST
	mva :STACKORIGIN+STACKWIDTH,x DEST+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x SOURCE
	mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
	dex						; sub bx, 1


; ---------------------  ASM Block 031  ---------------------

	jsr @move


; -----------------------------------------------------------

SOURCE	= edx
DEST	= ecx
COUNT	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	MOVE_018F					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x DEST
	mva :STACKORIGIN+STACKWIDTH,x DEST+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x SOURCE
	mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
	dex						; sub bx, 1


; ---------------------  ASM Block 033  ---------------------

	jsr @move


; -----------------------------------------------------------

SOURCE	= edx
DEST	= ecx
COUNT	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $0004
MGTIA	= $0000
MVBXE	= $0080
WINDOW	= $0010
NARROW	= $0020
VBXE_XDLADR	= $0000
VBXE_BCBADR	= $0100
VBXE_MAPADR	= $1000
VBXE_OVRADR	= $5000
VBXE_WINDOW	= $B000
IDLI	= $0000
IVBL	= $0001
CH_DELCHR	= $00FE
CH_ENTER	= $009B
CH_ESC	= $001B
CH_CURS_UP	= $001C
CH_CURS_DOWN	= $001D
CH_CURS_LEFT	= $001E
CH_CURS_RIGHT	= $001F
CH_TAB	= $007F
CH_EOL	= $009B
CH_CLR	= $007D
CH_BELL	= $00FD
CH_DEL	= $007E
CH_DELLINE	= $009C
CH_INSLINE	= $009D
COLOR_BLACK	= $0000
COLOR_WHITE	= $000E
COLOR_RED	= $0032
COLOR_CYAN	= $0096
COLOR_VIOLET	= $0068
COLOR_GREEN	= $00C4
COLOR_BLUE	= $0074
COLOR_YELLOW	= $00EE
COLOR_ORANGE	= $004A
COLOR_BROWN	= $00E4
COLOR_LIGHTRED	= $003C
COLOR_GRAY1	= $0004
COLOR_GRAY2	= $0006
COLOR_GRAY3	= $000A
COLOR_LIGHTGREEN	= $00CC
COLOR_LIGHTBLUE	= $007C
FMOPENREAD	= $0004
FMOPENWRITE	= $0008
FMOPENAPPEND	= $0009
FMOPENREADWRITE	= $000C
SCREENWIDTH	= DATAORIGIN+$0000
SCREENHEIGHT	= DATAORIGIN+$0002
FILEMODE	= DATAORIGIN+$0004
SCREENMODE	= DATAORIGIN+$0005
IORESULT	= DATAORIGIN+$0006
EOLN	= DATAORIGIN+$0007
RNDSEED	= DATAORIGIN+$0008

.endl							; UNIT SYSTEM

; -----------------------------------------------------------

.local	ATARI						; UNIT

; -----------------------------------------------------------

RTCLOK	= $0012
ATRACT	= $004D
LMARGIN	= $0052
RMARGIN	= $0053
ROWCRS	= $0054
COLCRS	= $0055
DINDEX	= $0057
SAVMSC	= $0058
VDSLST	= $0200
VPRCED	= $0202
VINTER	= $0204
VBREAK	= $0206
VKEYBD	= $0208
VSERIN	= $020A
VSEROR	= $020C
VSEROC	= $020E
VTIMR1	= $0210
VTIMR2	= $0212
VTIMR3	= $0214
VIMIRQ	= $0216
CDTMV1	= $0218
CDTMV2	= $021A
CDTMV3	= $021C
CDTMV4	= $022E
CDTMV5	= $0220
VVBLKI	= $0222
VVBLKD	= $0224
CDTMA1	= $0226
CDTMA2	= $0228
SDNCTK	= $022F
SDLSTW	= $0230
SDLSTL	= $0230
SDLSTH	= $0231
TXTROW	= $0290
TXTCOL	= $0291
TINDEX	= $0293
TXTMSC	= $0294
SDMCTL	= $022F
GPRIOR	= $026F
CRSINH	= $02F0
CHACT	= $02F3
CHBAS	= $02F4
CH	= $02FC
PCOLR0	= $02C0
PCOLR1	= $02C1
PCOLR2	= $02C2
PCOLR3	= $02C3
COLOR0	= $02C4
COLOR1	= $02C5
COLOR2	= $02C6
COLOR3	= $02C7
COLOR4	= $02C8
HPOSP0	= $D000
HPOSP1	= $D001
HPOSP2	= $D002
HPOSP3	= $D003
HPOSM0	= $D004
HPOSM1	= $D005
HPOSM2	= $D006
HPOSM3	= $D007
SIZEP0	= $D008
SIZEP1	= $D009
SIZEP2	= $D00A
SIZEP3	= $D00B
SIZEM	= $D00C
GRAFP0	= $D00D
GRAFP1	= $D00E
GRAFP2	= $D00F
GRAFP3	= $D010
GRAFM	= $D011
PAL	= $D014
COLPM0	= $D012
COLPM1	= $D013
COLPM2	= $D014
COLPM3	= $D015
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBK	= $D01A
PRIOR	= $D01B
GRACTL	= $D01D
HITCLR	= $D01E
CONSOL	= $D01F
AUDF1	= $D200
AUDC1	= $D201
AUDF2	= $D202
AUDC2	= $D203
AUDF3	= $D204
AUDC3	= $D205
AUDF4	= $D206
AUDC4	= $D207
AUDCTL	= $D208
STIMER	= $D209
SKRES	= $D20A
POTGO	= $D20B
SEROUT	= $D20D
IRQEN	= $D20E
SKCTL	= $D20F
SKSTAT	= $D20F
POT0	= $D200
POT1	= $D201
POT2	= $D202
POT3	= $D203
POT4	= $D204
POT5	= $D205
POT6	= $D206
POT7	= $D207
ALLPOT	= $D208
POTST	= $D208
KBCODE	= $D209
RANDOM	= $D20A
SERIN	= $D20D
IRQST	= $D20E
PORTA	= $D300
PORTB	= $D301
PCCTL	= $D302
PBCTL	= $D303
DMACTL	= $D400
CHACTL	= $D401
DLISTW	= $D402
DLISTL	= $D402
DLISTH	= $D403
HSCROL	= $D404
VSCROL	= $D405
PMBASE	= $D407
CHBASE	= $D409
WSYNC	= $D40A
VCOUNT	= $D40B
PENH	= $D40C
PENV	= $D40D
NMIEN	= $D40E
NMIRES	= $D40F
NMIST	= $D40F

.endl							; UNIT ATARI

; -----------------------------------------------------------

.local	B_SYSTEM					; UNIT

.local	SETCHARSET					; PROCEDURE

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x MSB
	dex						; sub bx, 1

	ift l_01B5-*>3
	jmp l_01B5
	eif

; IfThenEpilog
l_01B5

; optimize OK (B_SYSTEM), line = 218

	mva MSB ATARI.CHBASE

; -----------------------------------------------------------

MSB	= DATAORIGIN+$000C

@VarData	= MSB
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

__NMIEN	= DATAORIGIN+$000B
PORTB_SELFTEST_OFF	= $0080
PORTB_BASIC_OFF	= $0002
PORTB_SYSTEM_ON	= $0001

.endl							; UNIT B_SYSTEM

; -----------------------------------------------------------

.local	SYSUTILS					; UNIT

.local	INTTOSTR					; FUNCTION | ASSEMBLER

; -----------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	mva :STACKORIGIN+STACKWIDTH*2,x A+2
	mva :STACKORIGIN+STACKWIDTH*3,x A+3
	dex						; sub bx, 1


; ---------------------  ASM Block 060  ---------------------

	txa:pha

	inx

	@ValueToStr #@printINT

	mwa #@buf Result

	pla:tax


@exit

; -----------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

A	= DATAORIGIN+$000D
RESULT	= DATAORIGIN+$0011

@VarData	= A
@VarDataSize	= 6

	rts						; ret
.endl

; -----------------------------------------------------------

FAREADONLY	= $0001
FAHIDDEN	= $0002
FASYSFILE	= $0004
FAVOLUMEID	= $0008
FADIRECTORY	= $0010
FAARCHIVE	= $0020
FAANYFILE	= $003F

.endl							; UNIT SYSUTILS

; -----------------------------------------------------------

.local	B_CRT						; UNIT

.local	ATASCII2ANTIC_01D6				; FUNCTION | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x C
	dex						; sub bx, 1

	ift l_01DF-*>3
	jmp l_01DF
	eif

; IfThenEpilog
l_01DF

; ---------------------  ASM Block 064  ---------------------


        lda c
        asl
        php
        cmp #2*$60
        bcs @+
        sbc #2*$20-1
        bcs @+
        adc #2*$60
@       plp
        ror
        sta result;
    

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

C	= DATAORIGIN+$001C
RESULT	= DATAORIGIN+$001D

@VarData	= C
@VarDataSize	= 2

	rts						; ret
.endl

.local	ATASCII2ANTIC_01E3				; FUNCTION | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x S
	mva :STACKORIGIN+STACKWIDTH,x S+1
	dex						; sub bx, 1
	@move S #adr.S #256
	mwa #adr.S S

	ift l_01EC-*>3
	jmp l_01EC
	eif

; IfThenEpilog
l_01EC

; optimize OK (B_CRT), line = 468

	lda adr.S+$00
	sta adr.RESULT+$00
; For

; optimize OK (B_CRT), line = 469

	mva #$01 I

; optimize OK (B_CRT), line = 469

	lda adr.S+$00
	sta @FORTMP_512
; To
l_0206

; ForToDoCondition

; optimize OK (B_CRT), line = 469

	lda I
	cmp @FORTMP_512
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0214

; optimize FAIL ('ATASCII2ANTIC_01D6', B_CRT), line = 470
	inx
	mva I :STACKORIGIN,x
	inx
	ldy I 
	mva adr.S,y :STACKORIGIN,x
	jsr ATASCII2ANTIC_01D6
	ldy :STACKORIGIN-1,x
	mva :STACKORIGIN,x adr.RESULT,y
	dex
	dex

; ForToDoEpilog
c_0206
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0206
l_0214
b_0206

@exit

; -----------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

adr.S	= DATAORIGIN+$001E
.var S	= adr.S .word
adr.RESULT	= DATAORIGIN+$011E
.var RESULT	= adr.RESULT .word
I	= DATAORIGIN+$021E
@FORTMP_512	= DATAORIGIN+$021F

@VarData	= S
@VarDataSize	= 514

	rts						; ret
.endl

.local	CRT_INIT_022A					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x HEIGHT
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x WIDTH
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x VRAM_ADDRESS
	mva :STACKORIGIN+STACKWIDTH,x VRAM_ADDRESS+1
	dex						; sub bx, 1

	ift l_023F-*>3
	jmp l_023F
	eif

; IfThenEpilog
l_023F

; optimize OK (B_CRT), line = 483

	mva VRAM_ADDRESS CRT_VRAM
	mva VRAM_ADDRESS+1 CRT_VRAM+1

; optimize OK (B_CRT), line = 484

	mva WIDTH CRT_SCREENWIDTH

; optimize OK (B_CRT), line = 485

	mva HEIGHT CRT_SCREENHEIGHT

; optimize OK (B_CRT), line = 486

	lda HEIGHT
	sta :ecx
	lda WIDTH
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta CRT_SIZE
	lda :eax+1
	sta CRT_SIZE+1

; optimize OK (B_CRT), line = 487

	mva CRT_VRAM CRT_CURSOR
	mva CRT_VRAM+1 CRT_CURSOR+1

; optimize OK (B_CRT), line = 488

	mva #$00 CRT_LEFTMARGIN

; -----------------------------------------------------------

VRAM_ADDRESS	= DATAORIGIN+$0220
WIDTH	= DATAORIGIN+$0222
HEIGHT	= DATAORIGIN+$0223

@VarData	= VRAM_ADDRESS
@VarDataSize	= 4


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_CLEAR_0278					; PROCEDURE | OVERLOAD

	ift l_027B-*>3
	jmp l_027B
	eif

; IfThenEpilog
l_027B

; optimize OK (B_CRT), line = 504

	lda CRT_VRAM
	sta :edx
	lda CRT_VRAM+1
	sta :edx+1
	lda CRT_SIZE
	sta :ecx
	lda CRT_SIZE+1
	sta :ecx+1
	lda #$00
	sta :eax
	jsr @fill

; optimize OK (B_CRT), line = 505

	mva CRT_VRAM CRT_CURSOR
	mva CRT_VRAM+1 CRT_CURSOR+1

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_GOTOXY					; PROCEDURE

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x Y
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x X
	dex						; sub bx, 1

	ift l_0299-*>3
	jmp l_0299
	eif

; IfThenEpilog
l_0299

; optimize OK (B_CRT), line = 516

	lda CRT_SCREENWIDTH
	sta :ecx
	lda Y
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	add X
	sta :STACKORIGIN+9
	lda :eax+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add CRT_VRAM
	sta CRT_CURSOR
	lda :STACKORIGIN+STACKWIDTH+9
	adc CRT_VRAM+1
	sta CRT_CURSOR+1

; -----------------------------------------------------------

X	= DATAORIGIN+$0224
Y	= DATAORIGIN+$0225

@VarData	= X
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02B4					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x S
	mva :STACKORIGIN+STACKWIDTH,x S+1
	dex						; sub bx, 1
	@move S #adr.S #256
	mwa #adr.S S

	ift l_02BD-*>3
	jmp l_02BD
	eif

; IfThenEpilog
l_02BD

; optimize OK (B_CRT), line = 531

	lda S
	add #$01
	sta :edx
	lda S+1
	adc #$00
	sta :edx+1
	lda adr.S+$00
	sta :eax
	lda CRT_CURSOR
	sta :ecx
	lda CRT_CURSOR+1
	sta :ecx+1
	lda #$00
	sta :eax+1
	jsr @move

; optimize OK (B_CRT), line = 532

	lda CRT_CURSOR
	add adr.S+$00
	sta CRT_CURSOR
	lda CRT_CURSOR+1
	adc #$00
	sta CRT_CURSOR+1

; -----------------------------------------------------------

adr.S	= DATAORIGIN+$0226
.var S	= adr.S .word

@VarData	= S
@VarDataSize	= 256


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02CA					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x NUM
	dex						; sub bx, 1

	ift l_02D3-*>3
	jmp l_02D3
	eif

; IfThenEpilog
l_02D3

; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 543
	inx
	mva NUM :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr SYSUTILS.INTTOSTR
	jsr ATASCII2ANTIC_01E3
	jsr CRT_WRITE_02B4

; -----------------------------------------------------------

NUM	= DATAORIGIN+$0326

@VarData	= NUM
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02DA					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x NUM
	mva :STACKORIGIN+STACKWIDTH,x NUM+1
	dex						; sub bx, 1

	ift l_02E3-*>3
	jmp l_02E3
	eif

; IfThenEpilog
l_02E3

; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 548
	inx
	mva NUM :STACKORIGIN,x
	mva NUM+1 :STACKORIGIN+STACKWIDTH,x
	jsr @expandToCARD.WORD
	jsr SYSUTILS.INTTOSTR
	jsr ATASCII2ANTIC_01E3
	jsr CRT_WRITE_02B4

; -----------------------------------------------------------

NUM	= DATAORIGIN+$0327

@VarData	= NUM
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_KEYPRESSED					; FUNCTION

	ift l_02EC-*>3
	jmp l_02EC
	eif

; IfThenEpilog
l_02EC

; optimize OK (B_CRT), line = 592

	mva #$00 RESULT

; optimize OK (B_CRT), line = 593

	lda ATARI.SKSTAT
	ldy #1
	and #$04
	beq @+
	dey
@
	.ifdef IFTMP_28
	sty IFTMP_28
	eif
	tya
	bne *+5
	jmp l_0309

; optimize OK (B_CRT), line = 593

	mva #$01 RESULT

; IfThenEpilog
l_0309

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

RESULT	= DATAORIGIN+$0329

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

.local	CRT_STARTPRESSED				; FUNCTION

	ift l_0323-*>3
	jmp l_0323
	eif

; IfThenEpilog
l_0323

; optimize OK (B_CRT), line = 749

	lda ATARI.CONSOL
	ldy #1
	and #$01
	beq @+
	dey
@
	sty RESULT

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

RESULT	= DATAORIGIN+$032A

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

; -----------------------------------------------------------

DEFAULT_SCREENWIDTH	= $0028
DEFAULT_SCREENHEIGHT	= $0018
CHAR_RETURN	= $009B
CHAR_ESCAPE	= $001B
CHAR_BACKSPACE	= $007E
CHAR_TAB	= $007F
CHAR_INVERSE	= $0081
CHAR_CAPS	= $0082
ICHAR_RETURN	= $00DB
ICHAR_ESCAPE	= $005B
ICHAR_BACKSPACE	= $007E
ICHAR_TAB	= $007F
ICHAR_INVERSE	= $00C1
ICHAR_CAPS	= $00C2
adr.CRT_KEYCODE	= CODEORIGIN+$011E
.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
CRT_VRAM	= DATAORIGIN+$0013
CRT_SIZE	= DATAORIGIN+$0015
CRT_SCREENWIDTH	= DATAORIGIN+$0017
CRT_SCREENHEIGHT	= DATAORIGIN+$0018
CRT_CURSOR	= DATAORIGIN+$0019
CRT_LEFTMARGIN	= DATAORIGIN+$001B
KBCODE	= $D209
CONSOL	= $D01F

.endl							; UNIT B_CRT

; -----------------------------------------------------------

.local	B_PMG						; UNIT

.local	PMG_INIT_033A					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x GRACTL
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SDMCTL
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x BASE
	dex						; sub bx, 1

	ift l_034F-*>3
	jmp l_034F
	eif

; IfThenEpilog
l_034F

; optimize OK (B_PMG), line = 159

	mva BASE PMG_PMBASE

; optimize OK (B_PMG), line = 160

	lda #$00
	sta PMG_BASE
	lda BASE
	sta PMG_BASE+1

; optimize OK (B_PMG), line = 161

	mva GRACTL PMG_GRACTL

; optimize OK (B_PMG), line = 162

	lda PMG_SDMCTL_S
	and #$E0
	ora SDMCTL
	sta SDMCTL_FLAGS

; optimize OK (B_PMG), line = 163

	mva SDMCTL_FLAGS PMG_SDMCTL

; optimize OK (B_PMG), line = 164

	mva SDMCTL_FLAGS PMG_SDMCTL_S

; optimize OK (B_PMG), line = 165

	lda SDMCTL
	ldy #1
	and #$10
	bne @+
	dey
@
	.ifdef IFTMP_32
	sty IFTMP_32
	eif
	tya
	bne *+5
	jmp l_03A9

; optimize OK (B_PMG), line = 166

	mva #$01 PMG_ONELINE

; optimize OK (B_PMG), line = 167

	mva #$00 PMG_SIZE
	mva #$08 PMG_SIZE+1

; IfThenEpilog
l_03A9

; Restore conditional expression
	lda IFTMP_32

; else condition
	beq *+5						; je
	jmp l_03C1

; optimize OK (B_PMG), line = 169

	mva #$00 PMG_ONELINE

; optimize OK (B_PMG), line = 170

	sta PMG_SIZE
	mva #$04 PMG_SIZE+1

; IfThenEpilog
l_03C1

; -----------------------------------------------------------

BASE	= DATAORIGIN+$0330
SDMCTL	= DATAORIGIN+$0331
GRACTL	= DATAORIGIN+$0332
SDMCTL_FLAGS	= DATAORIGIN+$0333
IFTMP_32	= DATAORIGIN+$0334

@VarData	= BASE
@VarDataSize	= 5


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	PMG_INIT_03D0					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SDMCTL
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x BASE
	dex						; sub bx, 1

	ift l_03DF-*>3
	jmp l_03DF
	eif

; IfThenEpilog
l_03DF

; optimize FAIL ('PMG_INIT_033A', B_PMG), line = 177
	inx
	mva BASE :STACKORIGIN,x
	inx
	mva SDMCTL :STACKORIGIN,x
	inx
	mva GRACTL :STACKORIGIN,x
	jsr PMG_INIT_033A

; -----------------------------------------------------------

BASE	= DATAORIGIN+$0335
SDMCTL	= DATAORIGIN+$0336
GRACTL	= DATAORIGIN+$0337

@VarData	= BASE
@VarDataSize	= 3


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

PMG_VDELAY_M0	= $0001
PMG_VDELAY_M1	= $0002
PMG_VDELAY_M2	= $0004
PMG_VDELAY_M3	= $0008
PMG_VDELAY_P0	= $0010
PMG_VDELAY_P1	= $0020
PMG_VDELAY_P2	= $0040
PMG_VDELAY_P3	= $0080
PMG_SIZE_NORMAL	= $0000
PMG_SIZE_X2	= $0001
PMG_SIZE_X4	= $0003
PMG_MSIZE0_X2	= $0001
PMG_MSIZE0_X4	= $0003
PMG_MSIZE1_X2	= $0004
PMG_MSIZE1_X4	= $000C
PMG_MSIZE2_X2	= $0010
PMG_MSIZE2_X4	= $0030
PMG_MSIZE3_X2	= $0040
PMG_MSIZE4_X4	= $00C0
PMG_GRACTL_MISSILES	= $0001
PMG_GRACTL_PLAYERS	= $0002
PMG_GRACTL_LATCH	= $0004
PMG_GRACTL_DEFAULT	= $0003
PMG_SDMCTL_DMA_MISSILE	= $0004
PMG_SDMCTL_DMA_PLAYER	= $0008
PMG_SDMCTL_DMA_BOTH	= $000C
PMG_SDMCTL_ONELINE	= $0010
PMG_SDMCTL_SCREEN_DISABLED	= $0000
PMG_SDMCTL_SCREEN_NARROW	= $0001
PMG_SDMCTL_SCREEN_NORMAL	= $0002
PMG_SDMCTL_SCREEN_WIDE	= $0003
PMG_SDMCTL_DEFAULT	= $000E
PMG_5PLAYER	= $0010
PMG_OVERLAP	= $0020
PMG_SDMCTL	= $D400
PMG_SDMCTL_S	= $022F
PMG_GPRIOR	= $D01B
PMG_GPRIOR_S	= $026F
PMG_PCOLR0	= $D012
PMG_PCOLR1	= $D013
PMG_PCOLR2	= $D014
PMG_PCOLR3	= $D015
PMG_PCOLR0_S	= $02C0
PMG_PCOLR1_S	= $02C1
PMG_PCOLR2_S	= $02C2
PMG_PCOLR3_S	= $02C3
PMG_HPOS0	= $D000
PMG_HPOS1	= $D001
PMG_HPOS2	= $D002
PMG_HPOS3	= $D003
PMG_HPOSM0	= $D004
PMG_HPOSM1	= $D005
PMG_HPOSM2	= $D006
PMG_HPOSM3	= $D007
PMG_SIZEP0	= $D008
PMG_SIZEP1	= $D009
PMG_SIZEP2	= $D00A
PMG_SIZEP3	= $D00B
PMG_SIZEM	= $D00C
PMG_GRAFP0	= $D00D
PMG_GRAFP1	= $D00E
PMG_GRAFP2	= $D00F
PMG_GRAFP3	= $D010
PMG_GRAFM	= $D011
PMG_P0PL	= $D00C
PMG_P1PL	= $D00D
PMG_P2PL	= $D00E
PMG_P3PL	= $D00F
PMG_VDELAY	= $D01C
PMG_GRACTL	= $D01D
PMG_HITCLR	= $D01E
PMG_PMBASE	= $D407
PMG_ONELINE	= DATAORIGIN+$032B
PMG_BASE	= DATAORIGIN+$032C
PMG_SIZE	= DATAORIGIN+$032E

.endl							; UNIT B_PMG

; -----------------------------------------------------------

.local	B_SET_INTERUPTS					; UNIT

.local	SETVBLI						; PROCEDURE | ASSEMBLER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x VBLPTR
	mva :STACKORIGIN+STACKWIDTH,x VBLPTR+1
	dex						; sub bx, 1


; ---------------------  ASM Block 066  ---------------------


	mwa vblptr vvblki


; -----------------------------------------------------------

VBLPTR	= DATAORIGIN+$0339

@VarData	= VBLPTR
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

__NMIEN	= DATAORIGIN+$0338
PORTB_SELFTEST_OFF	= $0080
PORTB_BASIC_OFF	= $0002
PORTB_SYSTEM_ON	= $0001

.endl							; UNIT B_SET_INTERUPTS

.local	TITLEVBI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 069  ---------------------


		lda #<title00dli
		sta vdslst+0
		lda #>title00dli
		sta vdslst+1
		lda #$22
		sta colbak
		lda #$36
		sta colpf3				
		inc rtclok+2
		jmp XITVBV
	
	rti						; ret
.endl

.local	GAMEVBI						; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 070  ---------------------


		lda #<title00dli
		sta vdslst+0
		lda #>title00dli
		sta vdslst+1
		lda #$22
		sta colbak
		lda mind_color
		sta colpf3		
inc_rt_clock
		inc rtclok+2
		bne no_inc_other_clock
		inc rtclok+1
		bne no_inc_other_clock
		inc rtclok
no_inc_other_clock				
		jmp XITVBV
	
	rti						; ret
.endl

.local	PAUSEVBI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 071  ---------------------


	rti						; ret
.endl

.local	TITLE00DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 072  ---------------------


	pha	
	lda #$D8
	sta wsync
	sta colpf0
	lda #$06
	sta colpf1
	lda #$AA
	sta colpf2
	lda #>CHARSET_TITLE
	sta chbase
	lda #<title01dli
	sta vdslst+0
	lda #>title01dli
	sta vdslst+1
	pla
	rti
	rti						; ret
.endl

.local	TITLE01DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 073  ---------------------


	pha	
	lda #142
	sta wsync
	sta colpf0
	lda #10
	sta colpf1
	lda #186
	sta colpf2
	lda #>CHARSET_GAME
 	sta chbase
	lda #<title00dli
	sta vdslst+0
	lda #>title00dli
	sta vdslst+1
	pla
	rti
	rti						; ret
.endl

.local	TITLE02DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 074  ---------------------

phr
	plr
	rti						; ret
.endl

.local	TITLE03DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 075  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME00DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 076  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME01DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 077  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME02DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 078  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME03DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 079  ---------------------

phr
	plr
	rti						; ret
.endl

.local	SHOWTITLESCREEN					; PROCEDURE

	ift l_03FF-*>3
	jmp l_03FF
	eif

; IfThenEpilog
l_03FF

; optimize OK (Mind Field.pas), line = 473

	lda #$00
	sta TOPMEM
	lda CHBASE1
	sta TOPMEM+1

; ---------------------  ASM Block 080  ---------------------


;	  ICL "Atari 8-bit Equates.asm"
		
    lda #0
    sta 82
    sta 710
    lda #12
    sta 709
    ; lda chbase1
    ; sta 756
    LDA #0
    STA NMIEN
    STA DMACTL
    STA PRIOR
    STA HITCLR

;    LDX #>RamSizeCode+1
    LDY #$00
    STY NDX0
    STY NDX2
    LDA #$38
    STA NDX1
    LDA #$A8
    STA NDX3
    

; optimize OK (Mind Field.pas), line = 499

	mva #$00 ATARI.DMACTL

; optimize OK (Mind Field.pas), line = 500

	sta ATARI.NMIEN

; optimize FAIL ('B_CRT.CRT_INIT_022A', Mind Field.pas), line = 501
	inx
	mva #$00 :STACKORIGIN,x
	mva #$08 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$28 :STACKORIGIN,x
	inx
	mva #$19 :STACKORIGIN,x
	jsr B_CRT.CRT_INIT_022A

; optimize OK (Mind Field.pas), line = 502

	mva <TITLE00DLI VDSLST
	mva >TITLE00DLI VDSLST+1

; optimize FAIL ('B_SET_INTERUPTS.SETVBLI', Mind Field.pas), line = 504
	inx
	mva <TITLEVBI :STACKORIGIN,x
	mva >TITLEVBI :STACKORIGIN+STACKWIDTH,x
	jsr B_SET_INTERUPTS.SETVBLI

; optimize FAIL ('B_CRT.CRT_CLEAR_0278', Mind Field.pas), line = 505
	jsr B_CRT.CRT_CLEAR_0278

; optimize OK (Mind Field.pas), line = 506

	mva #$1E ATARI.DLISTW
	mva #$82 ATARI.DLISTW+1

; optimize OK (Mind Field.pas), line = 507

	mva #$1E ATARI.SDLSTW
	mva #$82 ATARI.SDLSTW+1

; optimize OK (Mind Field.pas), line = 508

	mva #$00 ATARI.SAVMSC
	mva #$08 ATARI.SAVMSC+1

; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 509
	inx
	mva #$A4 :STACKORIGIN,x
	jsr B_SYSTEM.SETCHARSET

; optimize OK (Mind Field.pas), line = 510

	mva #$A4 ATARI.CHBAS

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 511
	inx
	mva #$00 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02B4', Mind Field.pas), line = 512
	inx
	mva #$02 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02B4

; optimize FAIL ('B_CRT.CRT_WRITE_02B4', Mind Field.pas), line = 513
	inx
	mva #$2C :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02B4

; optimize FAIL ('B_CRT.CRT_WRITE_02B4', Mind Field.pas), line = 514
	inx
	mva #$56 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02B4

; optimize FAIL ('B_CRT.CRT_WRITE_02B4', Mind Field.pas), line = 515
	inx
	mva #$80 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02B4

; optimize FAIL ('B_CRT.CRT_WRITE_02B4', Mind Field.pas), line = 516
	inx
	mva #$AA :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02B4

; optimize OK (Mind Field.pas), line = 517

	mva #$00 TMP5

; optimize OK (Mind Field.pas), line = 518

	mva #$01 ATARI.GPRIOR

; optimize OK (Mind Field.pas), line = 519

	sta ATARI.PRIOR

; optimize OK (Mind Field.pas), line = 520

	mva #$06 K

; optimize OK (Mind Field.pas), line = 521

	mva #$05 I

; optimize OK (Mind Field.pas), line = 523

	mva #$D8 ATARI.COLOR0

; optimize OK (Mind Field.pas), line = 524

	mva #$06 ATARI.COLOR1

; optimize OK (Mind Field.pas), line = 525

	mva #$AA ATARI.COLOR2

; optimize OK (Mind Field.pas), line = 526

	mva #$36 ATARI.COLOR3

; optimize OK (Mind Field.pas), line = 527

	mva #$22 ATARI.COLOR4

; optimize FAIL ('B_PMG.PMG_INIT_03D0', Mind Field.pas), line = 529
	inx
	mva #$18 :STACKORIGIN,x
	inx
	mva #$3E :STACKORIGIN,x
	jsr B_PMG.PMG_INIT_03D0

; optimize OK (Mind Field.pas), line = 530

	mva #$C0 ATARI.NMIEN

; --- RepeatUntilProlog
l_049C

; optimize OK (Mind Field.pas), line = 533

	lda I
	asl @
	tay
	lda adr.HISCORE,y
	sta :STACKORIGIN+10
	lda adr.HISCORE+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #1
	lda SCORE+1
	cmp :STACKORIGIN+STACKWIDTH+10
	bne @+
	lda SCORE
	cmp :STACKORIGIN+10
@
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_33
	sty IFTMP_33
	eif
	tya
	bne *+5
	jmp l_04B1

; optimize OK (Mind Field.pas), line = 535

	mva I K

; IfThenEpilog
l_04B1

; optimize OK (Mind Field.pas), line = 537

	dec I

; optimize OK (Mind Field.pas), line = 538

	ldy #1
	lda I
	beq @+
	dey
@
	tya
	bne *+5
c_049C
	jmp l_049C
b_049C

; optimize OK (Mind Field.pas), line = 539

	ldy #1
	lda K
	cmp #$05
	bcc @+
	dey
@
	.ifdef IFTMP_34
	sty IFTMP_34
	eif
	tya
	bne *+5
	jmp l_04E9

; optimize OK (Mind Field.pas), line = 541

	mva #$05 I

; --- RepeatUntilProlog
l_04F2

; optimize OK (Mind Field.pas), line = 543

	lda I
	asl @
	sta :STACKORIGIN+9
	lda I
	sub #$01
	asl @
	tay
	lda adr.HISCORE,y
	sta :STACKORIGIN+10
	lda adr.HISCORE+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy :STACKORIGIN+9
	lda :STACKORIGIN+10
	sta adr.HISCORE,y
	lda :STACKORIGIN+STACKWIDTH+10
	sta adr.HISCORE+1,y

; optimize OK (Mind Field.pas), line = 544

	dec I

; optimize OK (Mind Field.pas), line = 545

	ldy #1
	lda I
	cmp K
	beq @+
	dey
@
	tya
	bne *+5
c_04F2
	jmp l_04F2
b_04F2

; optimize OK (Mind Field.pas), line = 546

	lda K
	asl @
	tay
	lda SCORE
	sta adr.HISCORE,y
	lda SCORE+1
	sta adr.HISCORE+1,y

; IfThenEpilog
l_04E9

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 548
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva #$0F :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02B4', Mind Field.pas), line = 549
	inx
	mva #$D4 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02B4

; optimize OK (Mind Field.pas), line = 550

	lda #$00
	sta :bp+1
	ldy ATARI.HPOSP0
	lda #$7C
	sta (:bp),y

; --- RepeatUntilProlog
l_0532

; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 561
	jsr B_CRT.CRT_STARTPRESSED
	.ifdef IFTMP_35
	lda :STACKORIGIN,x
	sta IFTMP_35
	eif
	dex
	lda :STACKORIGIN+1,x
	bne *+5
	jmp l_053C

; optimize OK (Mind Field.pas), line = 561

	mva #$FF TMP5

; IfThenEpilog
l_053C

; optimize OK (Mind Field.pas), line = 565

	ldy #1
	lda TMP5
	cmp #$FF
	beq @+
	dey
@
	tya
	bne *+5
c_0532
	jmp l_0532
b_0532

; optimize OK (Mind Field.pas), line = 567

	mva #$40 ATARI.NMIEN

; --- RepeatUntilProlog
l_055B

; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 569
	jsr B_CRT.CRT_STARTPRESSED
	inx
	mva #$00 :STACKORIGIN,x
	ldy #1
	lda :STACKORIGIN-1,x
	cmp :STACKORIGIN,x
	beq @+
	dey
@
	sty :STACKORIGIN-1,x
	dex
	dex
	lda :STACKORIGIN+1,x
	bne *+5
c_055B
	jmp l_055B
b_055B

; ---------------------  ASM Block 081  ---------------------


//    ORG 32768
//    ICL "inflate_2017_ver4.asm"
//    ORG 46080
//    INS "roman10.fnt" 


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	INITIALIZE_LEVEL				; PROCEDURE

	ift l_056C-*>3
	jmp l_056C
	eif

; IfThenEpilog
l_056C

; optimize OK (Mind Field.pas), line = 616

	mva #$46 MIND_COLOR
; For

; optimize OK (Mind Field.pas), line = 617

	mva #$00 I

; optimize OK (Mind Field.pas), line = 617

; To
l_0582

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 617

	lda I
	cmp #$FF
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0590

; ---------------------  ASM Block 082  ---------------------


	LDA RANDOM
	CLC
	ADC #<game_screen
	STA NDX0
	LDA RANDOM
	AND #3
	ADC #>game_screen
	STA NDX1
	LDA RANDOM
	AND #3
	ORA #68
	LDY #0
	STA (NDX0),Y


; ForToDoEpilog
c_0582
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0582
l_0590
b_0582
; For

; optimize OK (Mind Field.pas), line = 638

	mva #$00 I

; optimize OK (Mind Field.pas), line = 638

; To
l_05A4

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 638

	lda I
	cmp #$3F
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_05B2

; ---------------------  ASM Block 083  ---------------------


			LDA RANDOM
			CLC
			ADC #<game_screen
			STA NDX0
			LDA RANDOM
			AND #3
			ADC #>game_screen
			STA NDX1
			LDA #193
			LDY #0
			STA (NDX0),Y


; ForToDoEpilog
c_05A4
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_05A4
l_05B2
b_05A4

; optimize OK (Mind Field.pas), line = 655

	mva #$7C CHARACTER_PX

; optimize OK (Mind Field.pas), line = 656

	mva #$D0 CHARACTER_PY

; optimize FAIL ('idivCARD', Mind Field.pas), line = 657
	inx
	mva CHARACTER_PX :STACKORIGIN,x
	inx
	mva #$30 :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$04 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x A
	dex

; optimize FAIL ('idivCARD', Mind Field.pas), line = 658
	inx
	mva CHARACTER_PY :STACKORIGIN,x
	inx
	mva #$18 :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$08 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x B
	dex
; For

; optimize OK (Mind Field.pas), line = 659

	lda B
	sub #$02
	sta J

; optimize OK (Mind Field.pas), line = 659

	lda B
	add #$03
	sta @FORTMP_1536
; To
l_0606

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 659

	lda J
	cmp @FORTMP_1536
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0614
; For

; optimize OK (Mind Field.pas), line = 660

	lda A
	sub #$02
	sta I

; optimize OK (Mind Field.pas), line = 660

	lda A
	add #$03
	sta @FORTMP_1577
; To
l_062F

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 660

	lda I
	cmp @FORTMP_1577
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_063D

; optimize OK (Mind Field.pas), line = 662

	lda #$28
	add I
	sta :STACKORIGIN+9
	lda #$08
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda J
	sta :ecx
	lda #$28
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :STACKORIGIN+9
	add :eax
	sta C
	lda :STACKORIGIN+STACKWIDTH+9
	adc :eax+1
	sta C+1

; optimize OK (Mind Field.pas), line = 663

	lda C+1
	sta :bp+1
	ldy C
	lda (:bp),y
	sta E

; optimize OK (Mind Field.pas), line = 664

	ldy #1
	lda E
	cmp #$C1
	beq @+
	dey
@
	.ifdef IFTMP_37
	sty IFTMP_37
	eif
	tya
	bne *+5
	jmp l_066F

; optimize OK (Mind Field.pas), line = 664

	lda C+1
	sta :bp+1
	ldy C
	lda #$00
	sta (:bp),y

; IfThenEpilog
l_066F

; ForToDoEpilog
c_062F
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_062F
l_063D
b_062F

; ForToDoEpilog
c_0606
	inc J						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0606
l_0614
b_0606

; -----------------------------------------------------------

@FORTMP_1404	= $00FF
@FORTMP_1438	= $003F
@FORTMP_1536	= DATAORIGIN+$0374
@FORTMP_1577	= DATAORIGIN+$0375

@VarData	= @FORTMP_1536
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	DISPLAY_INFORMATION_LINE			; PROCEDURE

	ift l_0684-*>3
	jmp l_0684
	eif

; IfThenEpilog
l_0684

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 676
	inx
	mva #$00 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02B4', Mind Field.pas), line = 677
	inx
	mva #$0E :STACKORIGIN,x
	mva #$81 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02B4

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 678
	inx
	mva #$06 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02DA', Mind Field.pas), line = 679
	inx
	mva SCORE :STACKORIGIN,x
	mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02DA

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 681
	inx
	mva #$0E :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02B4', Mind Field.pas), line = 682
	inx
	mva #$16 :STACKORIGIN,x
	mva #$81 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02B4

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 683
	inx
	mva #$14 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02CA', Mind Field.pas), line = 684
	inx
	mva LIVES :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_02CA

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; IfThenEpilog
l_0125

; --- RepeatUntilProlog
l_069D

; optimize FAIL ('SHOWTITLESCREEN', Mind Field.pas), line = 697
	jsr SHOWTITLESCREEN

; optimize OK (Mind Field.pas), line = 700

	mva #$00 SCORE
	sta SCORE+1

; optimize OK (Mind Field.pas), line = 701

	mva #$05 LIVES

; optimize FAIL ('B_CRT.CRT_INIT_022A', Mind Field.pas), line = 702
	inx
	mva #$00 :STACKORIGIN,x
	mva #$08 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$28 :STACKORIGIN,x
	inx
	mva #$1A :STACKORIGIN,x
	jsr B_CRT.CRT_INIT_022A

; optimize FAIL ('B_CRT.CRT_CLEAR_0278', Mind Field.pas), line = 703
	jsr B_CRT.CRT_CLEAR_0278

; optimize FAIL ('DISPLAY_INFORMATION_LINE', Mind Field.pas), line = 704
	jsr DISPLAY_INFORMATION_LINE

; optimize OK (Mind Field.pas), line = 705

	mva #$53 ATARI.DLISTW
	mva #$82 ATARI.DLISTW+1

; optimize OK (Mind Field.pas), line = 706

	mva #$53 ATARI.SDLSTW
	mva #$82 ATARI.SDLSTW+1

; optimize OK (Mind Field.pas), line = 707

	mva #$00 ATARI.SAVMSC
	mva #$08 ATARI.SAVMSC+1

; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 708
	inx
	mva #$A4 :STACKORIGIN,x
	jsr B_SYSTEM.SETCHARSET

; optimize OK (Mind Field.pas), line = 709

	mva #$A4 ATARI.CHBAS

; optimize FAIL ('INITIALIZE_LEVEL', Mind Field.pas), line = 710
	jsr INITIALIZE_LEVEL

; optimize OK (Mind Field.pas), line = 711

	mva #$8E ATARI.COLOR0

; optimize OK (Mind Field.pas), line = 712

	mva #$D4 ATARI.COLOR1

; optimize OK (Mind Field.pas), line = 713

	mva #$96 ATARI.COLOR3

; optimize OK (Mind Field.pas), line = 714

	mva #$22 ATARI.COLOR4

; optimize OK (Mind Field.pas), line = 715

	mva #$CA ATARI.COLPM0

; optimize OK (Mind Field.pas), line = 716

	mva #$FA ATARI.COLPM1

; optimize OK (Mind Field.pas), line = 717

	mva #$88 ATARI.COLPM2

; optimize OK (Mind Field.pas), line = 718

	mva #$24 ATARI.COLPM3

; optimize OK (Mind Field.pas), line = 719

	mva #$00 ATARI.SIZEP0

; optimize OK (Mind Field.pas), line = 720

	sta ATARI.SIZEP1

; optimize OK (Mind Field.pas), line = 721

	sta ATARI.SIZEP2

; optimize OK (Mind Field.pas), line = 722

	sta ATARI.SIZEP3

; optimize FAIL ('B_SET_INTERUPTS.SETVBLI', Mind Field.pas), line = 723
	inx
	mva <GAMEVBI :STACKORIGIN,x
	mva >GAMEVBI :STACKORIGIN+STACKWIDTH,x
	jsr B_SET_INTERUPTS.SETVBLI

; optimize FAIL ('B_PMG.PMG_INIT_03D0', Mind Field.pas), line = 724
	inx
	mva #$18 :STACKORIGIN,x
	inx
	mva #$3E :STACKORIGIN,x
	jsr B_PMG.PMG_INIT_03D0

; optimize OK (Mind Field.pas), line = 725

	mva #$C0 ATARI.NMIEN

; optimize OK (Mind Field.pas), line = 727

	mva #$B4 SHOW_COUNTDOWN

; optimize OK (Mind Field.pas), line = 728

	mva #$3F MIND_COLOR

; optimize OK (Mind Field.pas), line = 730

	mva #$00 F

; optimize OK (Mind Field.pas), line = 735

	mva RT_CHECK PRIOR_RT_CLOCK

; --- RepeatUntilProlog
l_074F

; optimize OK (Mind Field.pas), line = 737

	ldy #1
	lda MINDS_FOUND
	cmp #$00
	seq
	bcs @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda SHOW_COUNTDOWN
	beq @+
	dey
@
	tya
	and :STACKORIGIN+9
	.ifdef IFTMP_38
	sta IFTMP_38
	eif
	bne *+5
	jmp l_076D

; optimize OK (Mind Field.pas), line = 739

	mva #$00 MINDS_FOUND

; optimize FAIL ('idivCARD', Mind Field.pas), line = 740
	inx
	mva CHARACTER_PX :STACKORIGIN,x
	inx
	mva #$30 :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$04 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x A
	dex

; optimize FAIL ('idivCARD', Mind Field.pas), line = 741
	inx
	mva CHARACTER_PY :STACKORIGIN,x
	inx
	mva #$18 :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$08 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x B
	dex
; For

; optimize OK (Mind Field.pas), line = 742

	lda B
	sub #$02
	sta J

; optimize OK (Mind Field.pas), line = 742

	lda B
	add #$03
	sta @FORTMP_1968
; To
l_07B6

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 742

	lda J
	cmp @FORTMP_1968
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_07C4
; For

; optimize OK (Mind Field.pas), line = 743

	lda A
	sub #$02
	sta I

; optimize OK (Mind Field.pas), line = 743

	lda A
	add #$03
	sta @FORTMP_2009
; To
l_07DF

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 743

	lda I
	cmp @FORTMP_2009
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_07ED

; optimize OK (Mind Field.pas), line = 745

	lda #$28
	add I
	sta :STACKORIGIN+9
	lda #$08
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda J
	sta :ecx
	lda #$28
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :STACKORIGIN+9
	add :eax
	sta C
	lda :STACKORIGIN+STACKWIDTH+9
	adc :eax+1
	sta C+1

; optimize OK (Mind Field.pas), line = 746

	lda C+1
	sta :bp+1
	ldy C
	lda (:bp),y
	sta E

; optimize OK (Mind Field.pas), line = 747

	ldy #1
	lda E
	cmp #$41
	beq @+
	dey
@
	.ifdef IFTMP_39
	sty IFTMP_39
	eif
	tya
	bne *+5
	jmp l_081F

; optimize OK (Mind Field.pas), line = 747

	lda C+1
	sta :bp+1
	ldy C
	lda #$C1
	sta (:bp),y

; IfThenEpilog
l_081F

; ForToDoEpilog
c_07DF
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_07DF
l_07ED
b_07DF

; ForToDoEpilog
c_07B6
	inc J						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_07B6
l_07C4
b_07B6

; IfThenEpilog
l_076D

; optimize OK (Mind Field.pas), line = 750

	ldy #1
	lda PRIOR_RT_CLOCK
	cmp RT_CHECK
	bne @+
	dey
@
	.ifdef IFTMP_40
	sty IFTMP_40
	eif
	tya
	bne *+5
	jmp l_0846

; optimize OK (Mind Field.pas), line = 751

	mva #$00 MINDS_FOUND

; optimize OK (Mind Field.pas), line = 752

	mva RT_CHECK PRIOR_RT_CLOCK

; optimize OK (Mind Field.pas), line = 753

	lda PRIOR_PY
	sta :edx
	lda #$1C
	sta :edx+1
	lda #$0E
	sta :ecx
	lda #$00
	sta :ecx+1
	sta :eax
	jsr @fill

; optimize OK (Mind Field.pas), line = 754

	lda F
	asl @
	tay
	lda adr.SPRITEFRAMES,y
	sta :edx
	lda adr.SPRITEFRAMES+1,y
	sta :edx+1
	lda CHARACTER_PY
	sta :ecx
	lda #$1C
	sta :ecx+1
	lda #$0E
	sta :eax
	lda #$00
	sta :eax+1
	jsr @move

; optimize OK (Mind Field.pas), line = 755

	mva CHARACTER_PX ATARI.HPOSP0

; optimize OK (Mind Field.pas), line = 756

	mva CHARACTER_PY PRIOR_PY

; optimize OK (Mind Field.pas), line = 757

	ldy #1
	lda SHOW_COUNTDOWN
	cmp #$00
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_41
	sty IFTMP_41
	eif
	tya
	bne *+5
	jmp l_0893

; optimize OK (Mind Field.pas), line = 758

	dec SHOW_COUNTDOWN

; IfThenEpilog
l_0893

; Restore conditional expression
	lda IFTMP_41

; else condition
	beq *+5						; je
	jmp l_08AA

; optimize OK (Mind Field.pas), line = 759

	ldy #1
	lda MIND_COLOR
	cmp #$32
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_42
	sty IFTMP_42
	eif
	tya
	bne *+5
	jmp l_08BC

; optimize OK (Mind Field.pas), line = 760

	dec MIND_COLOR

; optimize OK (Mind Field.pas), line = 761

	ldy #1
	lda MIND_COLOR
	cmp #$32
	beq @+
	dey
@
	.ifdef IFTMP_43
	sty IFTMP_43
	eif
	tya
	bne *+5
	jmp l_08DC

; optimize OK (Mind Field.pas), line = 761

	mva #$22 MIND_COLOR

; IfThenEpilog
l_08DC

; IfThenEpilog
l_08BC

; IfThenEpilog
l_08AA

; optimize OK (Mind Field.pas), line = 763

	ldy #1
	lda MIND_COLOR
	cmp #$22
	beq @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda SHOW_COUNTDOWN
	beq @+
	dey
@
	tya
	and :STACKORIGIN+9
	.ifdef IFTMP_44
	sta IFTMP_44
	eif
	bne *+5
	jmp l_0906

; optimize OK (Mind Field.pas), line = 765

	lda ATARI.PORTA
	and #$0F
	sta STICK_READ

; ---------------------  ASM Block 084  ---------------------


															lda RT_CHECK
															AND #4
															STA G
								            

; optimize OK (Mind Field.pas), line = 771

	mva #$00 F

; optimize OK (Mind Field.pas), line = 772

	lda STICK_READ
	ldy #1
	and #$01
	beq @+
	dey
@
	.ifdef IFTMP_45
	sty IFTMP_45
	eif
	tya
	bne *+5
	jmp l_0931

; optimize OK (Mind Field.pas), line = 773

	dec CHARACTER_PY

; optimize OK (Mind Field.pas), line = 774

	lda #$01
	add G
	sta F

; IfThenEpilog
l_0931

; optimize OK (Mind Field.pas), line = 776

	lda STICK_READ
	ldy #1
	and #$02
	beq @+
	dey
@
	.ifdef IFTMP_46
	sty IFTMP_46
	eif
	tya
	bne *+5
	jmp l_0964

; optimize OK (Mind Field.pas), line = 777

	inc CHARACTER_PY

; optimize OK (Mind Field.pas), line = 778

	lda #$03
	add G
	sta F

; IfThenEpilog
l_0964

; optimize OK (Mind Field.pas), line = 780

	lda STICK_READ
	ldy #1
	and #$04
	beq @+
	dey
@
	.ifdef IFTMP_47
	sty IFTMP_47
	eif
	tya
	bne *+5
	jmp l_0997

; optimize OK (Mind Field.pas), line = 781

	dec CHARACTER_PX

; optimize OK (Mind Field.pas), line = 782

	lda #$02
	add G
	sta F

; IfThenEpilog
l_0997

; optimize OK (Mind Field.pas), line = 784

	lda STICK_READ
	ldy #1
	and #$08
	beq @+
	dey
@
	.ifdef IFTMP_48
	sty IFTMP_48
	eif
	tya
	bne *+5
	jmp l_09CA

; optimize OK (Mind Field.pas), line = 785

	inc CHARACTER_PX

; optimize OK (Mind Field.pas), line = 786

	lda #$04
	add G
	sta F

; IfThenEpilog
l_09CA

; IfThenEpilog
l_0906

; optimize FAIL ('idivCARD', Mind Field.pas), line = 789
	inx
	mva CHARACTER_PX :STACKORIGIN,x
	inx
	mva #$30 :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$04 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x A
	dex

; optimize FAIL ('idivCARD', Mind Field.pas), line = 790
	inx
	mva CHARACTER_PY :STACKORIGIN,x
	inx
	mva #$18 :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$08 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x B
	dex
; For

; optimize OK (Mind Field.pas), line = 791

	lda B
	sub #$02
	sta J

; optimize OK (Mind Field.pas), line = 791

	lda B
	add #$03
	sta @FORTMP_2596
; To
l_0A2A

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 791

	lda J
	cmp @FORTMP_2596
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0A38
; For

; optimize OK (Mind Field.pas), line = 792

	lda A
	sub #$02
	sta I

; optimize OK (Mind Field.pas), line = 792

	lda A
	add #$03
	sta @FORTMP_2637
; To
l_0A53

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 792

	lda I
	cmp @FORTMP_2637
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0A61

; optimize OK (Mind Field.pas), line = 794

	lda #$28
	add I
	sta :STACKORIGIN+9
	lda #$08
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda J
	sta :ecx
	lda #$28
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :STACKORIGIN+9
	add :eax
	sta C
	lda :STACKORIGIN+STACKWIDTH+9
	adc :eax+1
	sta C+1

; optimize OK (Mind Field.pas), line = 795

	lda C+1
	sta :bp+1
	ldy C
	lda (:bp),y
	sta E

; optimize OK (Mind Field.pas), line = 796

	ldy #1
	lda E
	cmp #$C1
	beq @+
	dey
@
	.ifdef IFTMP_49
	sty IFTMP_49
	eif
	tya
	bne *+5
	jmp l_0A93

; optimize OK (Mind Field.pas), line = 798

	ldy #1
	lda J
	cmp B
	beq @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda I
	cmp A
	beq @+
	dey
@
	tya
	ora :STACKORIGIN+9
	sta :STACKORIGIN+9
	lda A
	add #$01
	sta :STACKORIGIN+11
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+11
	ldy #1
	lda #$00
	cmp :STACKORIGIN+STACKWIDTH+11
	bne @+
	lda I
	cmp :STACKORIGIN+11
@
	beq @+
	dey
@
	tya
	ora :STACKORIGIN+9
	.ifdef IFTMP_50
	sta IFTMP_50
	eif
	bne *+5
	jmp l_0AC8

; optimize OK (Mind Field.pas), line = 798

	mva #$01 MINDS_UNDER

; IfThenEpilog
l_0AC8

; optimize OK (Mind Field.pas), line = 799

	lda C+1
	sta :bp+1
	ldy C
	lda #$41
	sta (:bp),y

; optimize OK (Mind Field.pas), line = 800

	inc MINDS_FOUND

; IfThenEpilog
l_0A93

; ForToDoEpilog
c_0A53
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0A53
l_0A61
b_0A53

; ForToDoEpilog
c_0A2A
	inc J						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0A2A
l_0A38
b_0A2A

; IfThenEpilog
l_0846

; optimize FAIL ('B_CRT.CRT_KEYPRESSED', Mind Field.pas), line = 804
	jsr B_CRT.CRT_KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	bne *+5
c_074F
	jmp l_074F
b_074F

; optimize OK (Mind Field.pas), line = 806

	lda #$00
	bne *+5
c_069D
	jmp l_069D
b_069D

; -----------------------------------------------------------

SCREEN_ADDR	= $0800
GAME_SCREEN	= $0828
PMBANK	= $1800
VARBANK	= $0600
CHARSET_GAME	= $A400
CHARSET_TITLE	= $A800
TITLE_DATA	= $AC00
CHARSET_BASE	= $00A4
MIBANK	= $1B00
PMBNK0	= $1C00
PMBNK1	= $1D00
PMBNK2	= $1E00
PMBNK3	= $1F00
adr.DISPLAY_LIST_TITLE	= CODEORIGIN+$021E
.var DISPLAY_LIST_TITLE	= adr.DISPLAY_LIST_TITLE .word
adr.DISPLAY_LIST_GAME	= CODEORIGIN+$0253
.var DISPLAY_LIST_GAME	= adr.DISPLAY_LIST_GAME .word
adr.P000	= CODEORIGIN+$0276
.var P000	= adr.P000 .word
adr.P001	= CODEORIGIN+$0284
.var P001	= adr.P001 .word
adr.P002	= CODEORIGIN+$0292
.var P002	= adr.P002 .word
adr.P003	= CODEORIGIN+$02A0
.var P003	= adr.P003 .word
adr.P004	= CODEORIGIN+$02AE
.var P004	= adr.P004 .word
adr.P005	= CODEORIGIN+$02BC
.var P005	= adr.P005 .word
adr.P006	= CODEORIGIN+$02CA
.var P006	= adr.P006 .word
adr.P007	= CODEORIGIN+$02D8
.var P007	= adr.P007 .word
adr.P008	= CODEORIGIN+$02E6
.var P008	= adr.P008 .word
adr.P009	= CODEORIGIN+$02F4
.var P009	= adr.P009 .word
adr.P010	= CODEORIGIN+$0302
.var P010	= adr.P010 .word
adr.P011	= CODEORIGIN+$0310
.var P011	= adr.P011 .word
adr.P012	= CODEORIGIN+$031E
.var P012	= adr.P012 .word
adr.P013	= CODEORIGIN+$032C
.var P013	= adr.P013 .word
adr.P014	= CODEORIGIN+$033A
.var P014	= adr.P014 .word
adr.P015	= CODEORIGIN+$0348
.var P015	= adr.P015 .word
adr.P016	= CODEORIGIN+$0356
.var P016	= adr.P016 .word
adr.P017	= CODEORIGIN+$0364
.var P017	= adr.P017 .word
adr.P018	= CODEORIGIN+$0372
.var P018	= adr.P018 .word
adr.P019	= CODEORIGIN+$0380
.var P019	= adr.P019 .word
adr.SPRITEFRAMES	= CODEORIGIN+$038E
.var SPRITEFRAMES	= adr.SPRITEFRAMES .word
RT_CHECK	= $0014
PRIOR	= $D01B
TMP0	= $00E0
TMP1	= $00E1
TMP2	= $00E2
TMP3	= $00E3
TMP4	= $00E4
TMP5	= $00E5
TMP6	= $00E6
TMP7	= $00E7
TMP8	= $00E8
TMP9	= $00E9
NDX0	= $00EA
NDX1	= $00EB
NDX2	= $00EC
NDX3	= $00ED
HOLDX	= $00EE
HOLDY	= $00EF
A	= DATAORIGIN+$033B
B	= DATAORIGIN+$033C
C	= DATAORIGIN+$033D
D	= DATAORIGIN+$033F
E	= DATAORIGIN+$0341
F	= DATAORIGIN+$0342
G	= DATAORIGIN+$0343
H	= DATAORIGIN+$0344
I	= DATAORIGIN+$0345
J	= DATAORIGIN+$0346
K	= DATAORIGIN+$0347
L	= DATAORIGIN+$0348
CHARACTER_PX	= DATAORIGIN+$0349
CHARACTER_PY	= DATAORIGIN+$034A
PRIOR_PY	= DATAORIGIN+$034B
STICK_READ	= DATAORIGIN+$034C
PRIOR_RT_CLOCK	= DATAORIGIN+$034D
MENU_SELECTION	= DATAORIGIN+$034E
FIND_OPTION	= DATAORIGIN+$034F
BOMBS_ON_OPTION	= DATAORIGIN+$0350
WALLS_ON_OPTION	= DATAORIGIN+$0351
SHOOTERS_OPTION	= DATAORIGIN+$0352
MIND_COLOR	= DATAORIGIN+$0353
SHOW_COUNTDOWN	= DATAORIGIN+$0354
MINDS_FOUND	= DATAORIGIN+$0355
MINDS_UNDER	= DATAORIGIN+$0356
TITLEPHASE	= DATAORIGIN+$0357
SCORE	= DATAORIGIN+$0358
LIVES	= DATAORIGIN+$035A
adr.HISCORE	= DATAORIGIN+$035B
.var HISCORE	= adr.HISCORE .word
TOPMEM	= DATAORIGIN+$0371
CHBASE1	= DATAORIGIN+$0373
@FORTMP_1968	= DATAORIGIN+$0376
@FORTMP_2009	= DATAORIGIN+$0377
IFTMP_41	= DATAORIGIN+$0378
@FORTMP_2596	= DATAORIGIN+$0379
@FORTMP_2637	= DATAORIGIN+$037A

@exit

@halt	ldx #0
	txs

	rts

IOCB@COPY	:16 brk

.local	@DEFINES
ATARI
PLATFORM_ATARI_ANTIC
PLATFORM_ATARI_8_BIT
.endl

.endl

; -----------------------------------------------------------

	icl 'cpu6502.asm'

; -----------------------------------------------------------

.macro UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	eif

	.ifdef MAIN.ATARI.@UnitInit
	jsr MAIN.ATARI.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_SYSTEM.@UnitInit
	jsr MAIN.B_SYSTEM.@UnitInit
	eif

	.ifdef MAIN.SYSUTILS.@UnitInit
	jsr MAIN.SYSUTILS.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_CRT.@UnitInit
	jsr MAIN.B_CRT.@UnitInit
	eif

	.ifdef MAIN.B_PMG.@UnitInit
	jsr MAIN.B_PMG.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_SET_INTERUPTS.@UnitInit
	jsr MAIN.B_SET_INTERUPTS.@UnitInit
	eif
.endm

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.ATARI) > 0
	.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
	eif

	ift .SIZEOF(MAIN.B_SYSTEM) > 0
	.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.SYSUTILS) > 0
	.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
	eif

	ift .SIZEOF(MAIN.B_CRT) > 0
	.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
	eif

	ift .SIZEOF(MAIN.B_PMG) > 0
	.print 'B_PMG: ',MAIN.B_PMG,'..',MAIN.B_PMG+.SIZEOF(MAIN.B_PMG)-1
	eif

	ift .SIZEOF(MAIN.B_SET_INTERUPTS) > 0
	.print 'B_SET_INTERUPTS: ',MAIN.B_SET_INTERUPTS,'..',MAIN.B_SET_INTERUPTS+.SIZEOF(MAIN.B_SET_INTERUPTS)-1
	eif

	.print 'CODE: ',CODEORIGIN,'..',*-1

	org $A000

DATAORIGIN

.by  $28 $00 $18 $00 $0C $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $03  $0E $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $9A $10 $00 $00 $00 $4C $1D $7C
.by  $15 $AC $0D $C4 $09 $F4 $01

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 891

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

	run START

; -----------------------------------------------------------

.macro	STATICDATA
.by  $00 $00 $28 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $21 $34  $21 $32 $29 $00 $18 $0D $22 $29
.by  $34 $00 $36 $25 $32 $33 $29 $2F  $2E $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $28 $00 $30 $32
.by  $2F $27 $32 $21 $2D $2D $29 $2E  $27 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $30 $25
.by  $34 $25 $32 $00 $2A $0E $00 $2D  $25 $39 $25 $32 $00 $00 $28 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $08 $39 $2F  $35 $32 $00 $2E $21 $2D $25 $00  $23 $2F $35 $2C $24 $00 $22 $25
.by  $00 $28 $25 $32 $25 $09 $00 $00  $28 $00 $27 $32 $21 $30 $28 $29  $23 $33 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $28 $00 $33 $2F $35 $2E  $24 $00 $21 $2E $24 $00 $2D $35  $33 $29 $23 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $15 $30 $32 $25
.by  $33 $33 $00 $33 $34 $21 $32 $34  $00 $34 $2F $00 $22 $25 $27 $29  $2E $0E $00 $08 $33 $23 $2F $32
.by  $25 $00 $1A $00 $00 $13 $34 $2F  $24 $21 $39 $33 $00 $28 $29 $27  $28 $00 $33 $23 $2F $32 $25 $33
.by  $0E $00 $02 $00 $1A $00 $06 $33  $23 $2F $32 $25 $1A $00 $06 $2C  $29 $36 $25 $33 $1A $00 $6C $6A
.by  $3B $FF $FF $6B $2B $2A $6F $FF  $70 $75 $9B $69 $2D $3D $76 $FF  $63 $FF $FF $62 $78 $7A $34 $FF
.by  $33 $36 $1B $35 $32 $31 $2C $20  $2E $6E $FF $6D $2F $81 $72 $FF  $65 $79 $7F $74 $77 $71 $39 $FF
.by  $30 $37 $7E $38 $3E $FF $66 $68  $64 $FF $82 $67 $73 $61 $4C $4A  $3A $FF $FF $4B $5C $5E $4F $FF
.by  $50 $55 $FF $49 $5F $7C $56 $FF  $43 $FF $FF $42 $58 $5A $24 $FF  $23 $26 $FF $25 $22 $21 $5B $3B
.by  $5D $4E $FF $4D $3F $FF $52 $FF  $45 $59 $FF $54 $57 $51 $28 $FF  $29 $27 $FF $40 $FF $FF $46 $48
.by  $44 $FF $FF $47 $53 $41 $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $70 $C0  $44 $00 $AC $04 $04 $04 $04 $04
.by  $04 $84 $00 $44 $00 $08 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04
.by  $00 $04 $00 $04 $00 $04 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04  $41 $1E $82 $70 $70 $44 $00 $08
.by  $10 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04
.by  $04 $04 $04 $41 $53 $82 $10 $38  $38 $7C $7C $7C $7C $38 $38 $38  $28 $28 $28 $28 $10 $38 $38 $78
.by  $78 $7C $7E $3A $3A $38 $28 $2C  $24 $20 $1C $1C $0C $1E $3E $3E  $1E $1C $18 $18 $18 $1C $1C $14
.by  $10 $38 $38 $3C $3C $7C $FC $B8  $B8 $38 $28 $2C $24 $20 $1C $1C  $18 $3C $3E $3E $3C $1C $0C $0C
.by  $0C $1C $1C $14 $10 $38 $38 $3C  $3C $7C $FC $B8 $B8 $38 $28 $68  $48 $48 $1C $1C $0C $1C $1E $1D
.by  $3E $3C $18 $18 $24 $22 $41 $41  $10 $38 $38 $78 $78 $7C $7E $3A  $3A $38 $28 $68 $48 $48 $1C $1C
.by  $18 $1C $3C $5C $3E $1E $0C $0C  $12 $22 $41 $41 $C3 $C3 $66 $3C  $18 $3C $7E $7E $7E $7E $7E $7E
.by  $3C $18 $00 $C6 $C6 $6C $38 $38  $7C $7C $7C $7C $7C $7C $38 $10  $00 $66 $66 $3C $18 $18 $3C $3C
.by  $3C $3C $3C $3C $18 $00 $00 $00  $C3 $66 $3C $18 $3C $7E $7E $7E  $7E $18 $00 $00 $00 $00 $C6 $6C
.by  $38 $10 $38 $7C $7C $7C $7C $38  $00 $00 $00 $00 $00 $66 $3C $18  $18 $3C $3C $3C $18 $00 $00 $00
.by  $00 $00 $00 $00 $6C $38 $10 $38  $38 $38 $10 $00 $00 $00 $00 $00  $00 $00 $18 $24 $24 $24 $24 $18
.by  $00 $00 $00 $00 $00 $00 $18 $24  $42 $42 $42 $42 $42 $42 $24 $18  $00 $00 $00 $18 $24 $42 $81 $81
.by  $81 $81 $81 $81 $42 $24 $18 $00  $3C $42 $42 $81 $81 $81 $81 $81  $81 $81 $81 $42 $42 $3C $76 $82
.by  $84 $82 $92 $82 $A0 $82 $AE $82  $BC $82 $CA $82 $D8 $82 $E6 $82  $F4 $82 $02 $83 $10 $83 $1E $83
.by  $2C $83 $3A $83 $48 $83 $56 $83  $64 $83 $72 $83 $80 $83
.endm

	end
