mads 2.0.8 build 1 (2 Nov 17)
Source: Mind Field.a65
     1 = 0010			STACKWIDTH	= 16
     2 = 8000			CODEORIGIN	= $8000
     3
     4 = 0001			TRUE		= 1
     5 = 0000			FALSE		= 0
     6
     7 					org $A0
     8
     9 					.print 'ZPFREE: $0000..',*-1
     9 				ZPFREE: $0000..$009F
    10
    11 = 00A0			fxptr	.ds 2
    12
    13 = 00A2			eax	.ds 4						;8 bytes (aex + edx) -> divREAL
    14 = 00A6			edx	.ds 4
    15 = 00AA			ecx	.ds 4
    16 = 00AE			bp	.ds 2
    17 = 00B0			bp2	.ds 2
    18
    19 				ztmp
    20 = 00B2			ztmp8	.ds 1
    21 = 00B3			ztmp9	.ds 1
    22 = 00B4			ztmp10	.ds 1
    23 = 00B5			ztmp11	.ds 1
    24
    25 = 00B6			TMP	.ds 2
    26
    27 					org $2C00
    28
    29 = 2C00			STACKORIGIN	.ds STACKWIDTH*4
    30
    31 					.print 'ZPFREE: ',*,'..',$ff
    31 				ZPFREE: $2C40..$00FF
    32
    33 = 00A2			ax	= eax
    34 = 00A2			al	= eax
    35 = 00A3			ah	= eax+1
    36
    37 = 00AA			cx	= ecx
    38 = 00AA			cl	= ecx
    39 = 00AB			ch	= ecx+1
    40
    41 = 00A6			dx	= edx
    42 = 00A6			dl	= edx
    43 = 00A7			dh	= edx+1
    44
    45 					org eax
    46
    47 = 00A2			FP1MAN0	.ds 1
    48 = 00A3			FP1MAN1	.ds 1
    49 = 00A4			FP1MAN2	.ds 1
    50 = 00A5			FP1MAN3	.ds 1
    51
    52 					org ztmp8
    53
    54 = 00B2			FP1SGN	.ds 1
    55 = 00B3			FP1EXP	.ds 1
    56
    57 					org edx
    58
    59 = 00A6			FP2MAN0	.ds 1
    60 = 00A7			FP2MAN1	.ds 1
    61 = 00A8			FP2MAN2	.ds 1
    62 = 00A9			FP2MAN3	.ds 1
    63
    64 					org ztmp10
    65
    66 = 00B4			FP2SGN	.ds 1
    67 = 00B5			FP2EXP	.ds 1
    68
    69 					org ecx
    70
    71 = 00AA			FPMAN0	.ds 1
    72 = 00AB			FPMAN1	.ds 1
    73 = 00AC			FPMAN2	.ds 1
    74 = 00AD			FPMAN3	.ds 1
    75
    76 					org bp2
    77
    78 = 00B0			FPSGN	.ds 1
    79 = 00B1			FPEXP	.ds 1
    80
    81 				.local	RESOURCE
    82 					icl 'res6502.asm'
Source: res6502.asm
     1
  1103 					opt l+
    83
    84 8000				RCDATA 'MINDFIELD.FNT' CHARSET_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0400			len = .filesize('MINDFIELD.FNT')
    17 					org main.CHARSET_ADDRESS
    19 FFFF> A400-A7FF> 00 00 + 	ins 'MINDFIELD.FNT'
Source: Mind Field.a65
    85 				.endl
    86
    87 				; -----------------------------------------------------------
    88
    89 A800				org CODEORIGIN
    90
    91 8000				STATICDATA
Macro: STATICDATA [Source: Mind Field.a65]
     1 8000-8AFE> 00 00 27 80 + .by  $00 $00 $27 $80 $80 $80 $80 $80  $80 $80 $80 $80 $80 $80 $80 $80  $80 $80 $AD $A9 $AE $A4 $80 $A6
     2 8018 A9 A5 AC A4 80 80 + .by  $A9 $A5 $AC $A4 $80 $80 $80 $80  $80 $80 $80 $80 $80 $80 $80 $80  $80 $80 $00 $28 $00 $00 $00 $00
     3 8030 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $21  $34 $21 $32 $29 $00 $18 $0D $22  $29 $34 $00 $36 $25 $32 $33 $29
     4 8048 2F 2E 00 00 00 00 + .by  $2F $2E $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $28 $00 $30  $32 $2F $27 $32 $21 $2D $2D $29
     5 8060 2E 27 00 00 00 00 + .by  $2E $27 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $30  $25 $34 $25 $32 $00 $2A $0E $00
     6 8078 2D 25 39 25 32 00 + .by  $2D $25 $39 $25 $32 $00 $00 $28  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $08 $39
     7 8090 2F 35 32 00 2E 21 + .by  $2F $35 $32 $00 $2E $21 $2D $25  $00 $23 $2F $35 $2C $24 $00 $22  $25 $00 $28 $25 $32 $25 $09 $00
     8 80A8 00 28 00 27 32 21 + .by  $00 $28 $00 $27 $32 $21 $30 $28  $29 $23 $33 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
     9 80C0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $28 $00 $33 $2F $35
    10 80D8 2E 24 00 21 2E 24 + .by  $2E $24 $00 $21 $2E $24 $00 $2D  $35 $33 $29 $23 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
    11 80F0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $08 $33 $23  $2F $32 $25 $00 $1A $00 $00 $13
    12 8108 34 2F 24 21 39 33 + .by  $34 $2F $24 $21 $39 $33 $00 $28  $29 $27 $28 $00 $33 $23 $2F $32  $25 $33 $0E $00 $02 $00 $1A $00
    13 8120 15 30 32 25 33 33 + .by  $15 $30 $32 $25 $33 $33 $00 $33  $34 $21 $32 $34 $00 $34 $2F $00  $22 $25 $27 $29 $2E $0E $00 $6C
    14 8138 6A 3B FF FF 6B 2B + .by  $6A $3B $FF $FF $6B $2B $2A $6F  $FF $70 $75 $9B $69 $2D $3D $76  $FF $63 $FF $FF $62 $78 $7A $34
    15 8150 FF 33 36 1B 35 32 + .by  $FF $33 $36 $1B $35 $32 $31 $2C  $20 $2E $6E $FF $6D $2F $81 $72  $FF $65 $79 $7F $74 $77 $71 $39
    16 8168 FF 30 37 7E 38 3E + .by  $FF $30 $37 $7E $38 $3E $FF $66  $68 $64 $FF $82 $67 $73 $61 $4C  $4A $3A $FF $FF $4B $5C $5E $4F
    17 8180 FF 50 55 FF 49 5F + .by  $FF $50 $55 $FF $49 $5F $7C $56  $FF $43 $FF $FF $42 $58 $5A $24  $FF $23 $26 $FF $25 $22 $21 $5B
    18 8198 3B 5D 4E FF 4D 3F + .by  $3B $5D $4E $FF $4D $3F $FF $52  $FF $45 $59 $FF $54 $57 $51 $28  $FF $29 $27 $FF $40 $FF $FF $46
    19 81B0 48 44 FF FF 47 53 + .by  $48 $44 $FF $FF $47 $53 $41 $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    20 81C8 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    21 81E0 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    22 81F8 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    23 8210 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    24 8228 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $70  $70 $44 $00 $40 $04 $04 $04 $04
    25 8240 04 00 04 00 04 00 + .by  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $00
    26 8258 04 00 04 00 04 00 + .by  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $41  $37 $82 $70 $50 $43 $00 $40 $03
    27 8270 03 10 04 04 04 04 + .by  $03 $10 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04
    28 8288 04 04 41 6A 82	.by  $04 $04 $41 $6A $82
Source: Mind Field.a65
    92
    93 828D			START
    94 828D BA				tsx
    95 828E 8E C7 88			stx MAIN.@halt+1
    96
    97 					.ifdef fmulinit
    98 					fmulinit
    99 					eif
   100
   101 					ift DATAORIGIN+VARINITSIZE > $BFFF
   102 					ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
   103 					els
   104 					@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
   104 				 MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1\ MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3\ MVA #0 @FILL.PTR2\ JSR @FILL
   104 8291 A9 3E 85 A6 A9 A3 +  MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1
   104 8299 A9 0D 85 AA A9 00 +  MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3
   104 82A1 A9 00 85 A2		 MVA #0 @FILL.PTR2
   104 82A5 20 B6 8A		 JSR @FILL
   105 					eif
   106
   107 82A8 A2 0F			ldx #$0f
   108 82AA BD 40 03 9D CA 88 + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   109
   110 82B3 A2 00 86 AE			mvx #$00 bp					; lo BP = 0, X = 0 !!!
   111
   112 82B7				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: Mind Field.a65]
Source: Mind Field.a65
   113
   114 82B7			.local	MAIN						; PROCEDURE
   115
   116 					ift l_013E-*>3
   117 82B7 4C C3 88			jmp l_013E
   118 					eif
   119
   120 				; -----------------------------------------------------------
   121
   122 82BA			.local	SYSTEM						; UNIT
   123
   124 82BA			.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER
   125
   126 				; -----------------------------------------------------------
   127
   128 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   129 				; as Pointer
   130 82BA BD 00 2C 85 AA		mva :STACKORIGIN,x VALUE
   131 82BF CA				dex						; sub bx, 1
   132
   133 				; -----------------------------------------------------------
   134
   135 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   136 				; as Pointer
   137 82C0 BD 00 2C 85 A6		mva :STACKORIGIN,x A
   138 82C5 BD 10 2C 85 A7		mva :STACKORIGIN+STACKWIDTH,x A+1
   139 82CA CA				dex						; sub bx, 1
   140
   141
   142 				; ---------------------  ASM Block 021  ---------------------
   143
   144 82CB A0 00			ldy #0
   145 82CD A5 AA 91 A6			mva value (edx),y
   146
   147
   148 				; -----------------------------------------------------------
   149
   150 = 00A6			A	= edx
   151 = 00AA			VALUE	= ecx
   152
   153 82D1			@exit
   154 					.ifdef @new
   155 					@FreeMem #@VarData #@VarDataSize
   156 					eif
   157 82D1 60				rts						; ret
   158 				.endl
   159
   160 82D2			.local	FILLCHAR_0165					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   161
   162 				; -----------------------------------------------------------
   163
   164 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   165 				; as Pointer
   166 82D2 BD 00 2C 85 A2		mva :STACKORIGIN,x VALUE
   167 82D7 CA				dex						; sub bx, 1
   168
   169 				; -----------------------------------------------------------
   170
   171 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   172 				; as Pointer
   173 82D8 BD 00 2C 85 AA		mva :STACKORIGIN,x COUNT
   174 82DD BD 10 2C 85 AB		mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   175 82E2 CA				dex						; sub bx, 1
   176
   177 				; -----------------------------------------------------------
   178
   179 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   180 				; as Pointer
   181 82E3 BD 00 2C 85 A6		mva :STACKORIGIN,x A
   182 82E8 BD 10 2C 85 A7		mva :STACKORIGIN+STACKWIDTH,x A+1
   183 82ED CA				dex						; sub bx, 1
   184
   185
   186 				; ---------------------  ASM Block 024  ---------------------
   187
   188 82EE 20 B6 8A			jsr @fill
   189
   190
   191 				; -----------------------------------------------------------
   192
   193 = 00A6			A	= edx
   194 = 00AA			COUNT	= ecx
   195 = 00A2			VALUE	= eax
   196
   197 82F1			@exit
   198 					.ifdef @new
   199 					@FreeMem #@VarData #@VarDataSize
   200 					eif
   201 82F1 60				rts						; ret
   202 				.endl
   203
   204 82F2			.local	MOVE_0178					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   205
   206 				; -----------------------------------------------------------
   207
   208 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   209 				; as Pointer
   210 82F2 BD 00 2C 85 A2		mva :STACKORIGIN,x COUNT
   211 82F7 BD 10 2C 85 A3		mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   212 82FC CA				dex						; sub bx, 1
   213
   214 				; -----------------------------------------------------------
   215
   216 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   217 				; as Pointer
   218 82FD BD 00 2C 85 AA		mva :STACKORIGIN,x DEST
   219 8302 BD 10 2C 85 AB		mva :STACKORIGIN+STACKWIDTH,x DEST+1
   220 8307 CA				dex						; sub bx, 1
   221
   222 				; -----------------------------------------------------------
   223
   224 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   225 				; as Pointer
   226 8308 BD 00 2C 85 A6		mva :STACKORIGIN,x SOURCE
   227 830D BD 10 2C 85 A7		mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
   228 8312 CA				dex						; sub bx, 1
   229
   230
   231 				; ---------------------  ASM Block 033  ---------------------
   232
   233 8313 20 61 8A			jsr @move
   234
   235
   236 				; -----------------------------------------------------------
   237
   238 = 00A6			SOURCE	= edx
   239 = 00AA			DEST	= ecx
   240 = 00A2			COUNT	= eax
   241
   242 8316			@exit
   243 					.ifdef @new
   244 					@FreeMem #@VarData #@VarDataSize
   245 					eif
   246 8316 60				rts						; ret
   247 				.endl
   248
   249 				; -----------------------------------------------------------
   250
   251 = 0648			M_PI_2	= $0648
   252 = 0192			D_PI_2	= $0192
   253 = 0004			D_PI_180	= $0004
   254 = 0000			MGTIA	= $0000
   255 = 0080			MVBXE	= $0080
   256 = 0010			WINDOW	= $0010
   257 = 0020			NARROW	= $0020
   258 = 0000			VBXE_XDLADR	= $0000
   259 = 0100			VBXE_BCBADR	= $0100
   260 = 1000			VBXE_MAPADR	= $1000
   261 = 5000			VBXE_OVRADR	= $5000
   262 = B000			VBXE_WINDOW	= $B000
   263 = 0000			IDLI	= $0000
   264 = 0001			IVBL	= $0001
   265 = 00FE			CH_DELCHR	= $00FE
   266 = 009B			CH_ENTER	= $009B
   267 = 001B			CH_ESC	= $001B
   268 = 001C			CH_CURS_UP	= $001C
   269 = 001D			CH_CURS_DOWN	= $001D
   270 = 001E			CH_CURS_LEFT	= $001E
   271 = 001F			CH_CURS_RIGHT	= $001F
   272 = 007F			CH_TAB	= $007F
   273 = 009B			CH_EOL	= $009B
   274 = 007D			CH_CLR	= $007D
   275 = 00FD			CH_BELL	= $00FD
   276 = 007E			CH_DEL	= $007E
   277 = 009C			CH_DELLINE	= $009C
   278 = 009D			CH_INSLINE	= $009D
   279 = 0000			COLOR_BLACK	= $0000
   280 = 000E			COLOR_WHITE	= $000E
   281 = 0032			COLOR_RED	= $0032
   282 = 0096			COLOR_CYAN	= $0096
   283 = 0068			COLOR_VIOLET	= $0068
   284 = 00C4			COLOR_GREEN	= $00C4
   285 = 0074			COLOR_BLUE	= $0074
   286 = 00EE			COLOR_YELLOW	= $00EE
   287 = 004A			COLOR_ORANGE	= $004A
   288 = 00E4			COLOR_BROWN	= $00E4
   289 = 003C			COLOR_LIGHTRED	= $003C
   290 = 0004			COLOR_GRAY1	= $0004
   291 = 0006			COLOR_GRAY2	= $0006
   292 = 000A			COLOR_GRAY3	= $000A
   293 = 00CC			COLOR_LIGHTGREEN	= $00CC
   294 = 007C			COLOR_LIGHTBLUE	= $007C
   295 = 0004			FMOPENREAD	= $0004
   296 = 0008			FMOPENWRITE	= $0008
   297 = 0009			FMOPENAPPEND	= $0009
   298 = 000C			FMOPENREADWRITE	= $000C
   299 = A000			SCREENWIDTH	= DATAORIGIN+$0000
   300 = A002			SCREENHEIGHT	= DATAORIGIN+$0002
   301 = A004			FILEMODE	= DATAORIGIN+$0004
   302 = A005			SCREENMODE	= DATAORIGIN+$0005
   303 = A006			IORESULT	= DATAORIGIN+$0006
   304 = A007			EOLN	= DATAORIGIN+$0007
   305 = A008			RNDSEED	= DATAORIGIN+$0008
   306
   307 				.endl							; UNIT SYSTEM
   308
   309 				; -----------------------------------------------------------
   310
   311 8317			.local	ATARI						; UNIT
   312
   313 				; -----------------------------------------------------------
   314
   315 = 0012			RTCLOK	= $0012
   316 = 004D			ATRACT	= $004D
   317 = 0052			LMARGIN	= $0052
   318 = 0053			RMARGIN	= $0053
   319 = 0054			ROWCRS	= $0054
   320 = 0055			COLCRS	= $0055
   321 = 0057			DINDEX	= $0057
   322 = 0058			SAVMSC	= $0058
   323 = 0200			VDSLST	= $0200
   324 = 0202			VPRCED	= $0202
   325 = 0204			VINTER	= $0204
   326 = 0206			VBREAK	= $0206
   327 = 0208			VKEYBD	= $0208
   328 = 020A			VSERIN	= $020A
   329 = 020C			VSEROR	= $020C
   330 = 020E			VSEROC	= $020E
   331 = 0210			VTIMR1	= $0210
   332 = 0212			VTIMR2	= $0212
   333 = 0214			VTIMR3	= $0214
   334 = 0216			VIMIRQ	= $0216
   335 = 0218			CDTMV1	= $0218
   336 = 021A			CDTMV2	= $021A
   337 = 021C			CDTMV3	= $021C
   338 = 022E			CDTMV4	= $022E
   339 = 0220			CDTMV5	= $0220
   340 = 0222			VVBLKI	= $0222
   341 = 0224			VVBLKD	= $0224
   342 = 0226			CDTMA1	= $0226
   343 = 0228			CDTMA2	= $0228
   344 = 022F			SDNCTK	= $022F
   345 = 0230			SDLSTW	= $0230
   346 = 0230			SDLSTL	= $0230
   347 = 0231			SDLSTH	= $0231
   348 = 0290			TXTROW	= $0290
   349 = 0291			TXTCOL	= $0291
   350 = 0293			TINDEX	= $0293
   351 = 0294			TXTMSC	= $0294
   352 = 022F			SDMCTL	= $022F
   353 = 026F			GPRIOR	= $026F
   354 = 02F0			CRSINH	= $02F0
   355 = 02F3			CHACT	= $02F3
   356 = 02F4			CHBAS	= $02F4
   357 = 02FC			CH	= $02FC
   358 = 02C0			PCOLR0	= $02C0
   359 = 02C1			PCOLR1	= $02C1
   360 = 02C2			PCOLR2	= $02C2
   361 = 02C3			PCOLR3	= $02C3
   362 = 02C4			COLOR0	= $02C4
   363 = 02C5			COLOR1	= $02C5
   364 = 02C6			COLOR2	= $02C6
   365 = 02C7			COLOR3	= $02C7
   366 = 02C8			COLOR4	= $02C8
   367 = D000			HPOSP0	= $D000
   368 = D001			HPOSP1	= $D001
   369 = D002			HPOSP2	= $D002
   370 = D003			HPOSP3	= $D003
   371 = D004			HPOSM0	= $D004
   372 = D005			HPOSM1	= $D005
   373 = D006			HPOSM2	= $D006
   374 = D007			HPOSM3	= $D007
   375 = D008			SIZEP0	= $D008
   376 = D009			SIZEP1	= $D009
   377 = D00A			SIZEP2	= $D00A
   378 = D00B			SIZEP3	= $D00B
   379 = D00C			SIZEM	= $D00C
   380 = D00D			GRAFP0	= $D00D
   381 = D00E			GRAFP1	= $D00E
   382 = D00F			GRAFP2	= $D00F
   383 = D010			GRAFP3	= $D010
   384 = D011			GRAFM	= $D011
   385 = D014			PAL	= $D014
   386 = D012			COLPM0	= $D012
   387 = D013			COLPM1	= $D013
   388 = D014			COLPM2	= $D014
   389 = D015			COLPM3	= $D015
   390 = D016			COLPF0	= $D016
   391 = D017			COLPF1	= $D017
   392 = D018			COLPF2	= $D018
   393 = D019			COLPF3	= $D019
   394 = D01A			COLBK	= $D01A
   395 = D01B			PRIOR	= $D01B
   396 = D01D			GRACTL	= $D01D
   397 = D01E			HITCLR	= $D01E
   398 = D01F			CONSOL	= $D01F
   399 = D200			AUDF1	= $D200
   400 = D201			AUDC1	= $D201
   401 = D202			AUDF2	= $D202
   402 = D203			AUDC2	= $D203
   403 = D204			AUDF3	= $D204
   404 = D205			AUDC3	= $D205
   405 = D206			AUDF4	= $D206
   406 = D207			AUDC4	= $D207
   407 = D208			AUDCTL	= $D208
   408 = D209			STIMER	= $D209
   409 = D20A			SKRES	= $D20A
   410 = D20B			POTGO	= $D20B
   411 = D20D			SEROUT	= $D20D
   412 = D20E			IRQEN	= $D20E
   413 = D20F			SKCTL	= $D20F
   414 = D20F			SKSTAT	= $D20F
   415 = D200			POT0	= $D200
   416 = D201			POT1	= $D201
   417 = D202			POT2	= $D202
   418 = D203			POT3	= $D203
   419 = D204			POT4	= $D204
   420 = D205			POT5	= $D205
   421 = D206			POT6	= $D206
   422 = D207			POT7	= $D207
   423 = D208			ALLPOT	= $D208
   424 = D208			POTST	= $D208
   425 = D209			KBCODE	= $D209
   426 = D20A			RANDOM	= $D20A
   427 = D20D			SERIN	= $D20D
   428 = D20E			IRQST	= $D20E
   429 = D300			PORTA	= $D300
   430 = D301			PORTB	= $D301
   431 = D302			PCCTL	= $D302
   432 = D303			PBCTL	= $D303
   433 = D400			DMACTL	= $D400
   434 = D401			CHACTL	= $D401
   435 = D402			DLISTW	= $D402
   436 = D402			DLISTL	= $D402
   437 = D403			DLISTH	= $D403
   438 = D404			HSCROL	= $D404
   439 = D405			VSCROL	= $D405
   440 = D407			PMBASE	= $D407
   441 = D409			CHBASE	= $D409
   442 = D40A			WSYNC	= $D40A
   443 = D40B			VCOUNT	= $D40B
   444 = D40C			PENH	= $D40C
   445 = D40D			PENV	= $D40D
   446 = D40E			NMIEN	= $D40E
   447 = D40F			NMIRES	= $D40F
   448 = D40F			NMIST	= $D40F
   449
   450 				.endl							; UNIT ATARI
   451
   452 				; -----------------------------------------------------------
   453
   454 8317			.local	B_SYSTEM					; UNIT
   455
   456 8317			.local	SETCHARSET					; PROCEDURE
   457
   458 				; -----------------------------------------------------------
   459
   460 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   461 				; as Pointer
   462 8317 BD 00 2C 8D 0B A0		mva :STACKORIGIN,x MSB
   463 831D CA				dex						; sub bx, 1
   464
   465 					ift l_019E-*>3
   466 					jmp l_019E
   467 					eif
   468
   469 				; IfThenEpilog
   470 831E			l_019E
   471
   472 				; optimize OK (B_SYSTEM), line = 218
   473
   474 831E AD 0B A0 8D 09 D4		mva MSB ATARI.CHBASE
   475
   476 				; -----------------------------------------------------------
   477
   478 = A00B			MSB	= DATAORIGIN+$000B
   479
   480 = A00B			@VarData	= MSB
   481 = 0001			@VarDataSize	= 1
   482
   483
   484 8324			@exit
   485 					.ifdef @new
   486 					@FreeMem #@VarData #@VarDataSize
   487 					eif
   488 8324 60				rts						; ret
   489 				.endl
   490
   491 				; -----------------------------------------------------------
   492
   493 = A00A			__NMIEN	= DATAORIGIN+$000A
   494 = 0080			PORTB_SELFTEST_OFF	= $0080
   495 = 0002			PORTB_BASIC_OFF	= $0002
   496 = 0001			PORTB_SYSTEM_ON	= $0001
   497
   498 				.endl							; UNIT B_SYSTEM
   499
   500 				; -----------------------------------------------------------
   501
   502 8325			.local	SYSUTILS					; UNIT
   503
   504 8325			.local	INTTOSTR					; FUNCTION | ASSEMBLER
   505
   506 				; -----------------------------------------------------------
   507
   508 				; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
   509 				; as Pointer
   510 8325 BD 00 2C 8D 0C A0		mva :STACKORIGIN,x A
   511 832B BD 10 2C 8D 0D A0		mva :STACKORIGIN+STACKWIDTH,x A+1
   512 8331 BD 20 2C 8D 0E A0		mva :STACKORIGIN+STACKWIDTH*2,x A+2
   513 8337 BD 30 2C 8D 0F A0		mva :STACKORIGIN+STACKWIDTH*3,x A+3
   514 833D CA				dex						; sub bx, 1
   515
   516
   517 				; ---------------------  ASM Block 060  ---------------------
   518
   519 833E 8A 48			txa:pha
   520
   521 8340 E8				inx
   522
   523 					@ValueToStr #@printINT
   523 				 LDY> @PRINTINT\ LDA< @PRINTINT\ JSR @VALUETOSTR
   523 8341 A0 89		 LDY> @PRINTINT
   523 8343 A9 7C		 LDA< @PRINTINT
   523 8345 20 0B 8A		 JSR @VALUETOSTR
   524
   525 8348 A9 00 8D 10 A0 A9 + 	mwa #@buf Result
   526
   527 8352 68 AA			pla:tax
   528
   529
   530 8354			@exit
   531
   532 				; -----------------------------------------------------------
   533
   534 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   535 				; as Pointer
   536
   537 8354 E8				inx						; add bx, 1
   538 8355 AD 10 A0 9D 00 2C		mva RESULT :STACKORIGIN,x
   539 835B AD 11 A0 9D 10 2C		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   540
   541 					.ifdef @new
   542 					@FreeMem #@VarData #@VarDataSize
   543 					eif
   544
   545 				; -----------------------------------------------------------
   546
   547 = A00C			A	= DATAORIGIN+$000C
   548 = A010			RESULT	= DATAORIGIN+$0010
   549
   550 = A00C			@VarData	= A
   551 = 0006			@VarDataSize	= 6
   552
   553 8361 60				rts						; ret
   554 				.endl
   555
   556 				; -----------------------------------------------------------
   557
   558 = 0001			FAREADONLY	= $0001
   559 = 0002			FAHIDDEN	= $0002
   560 = 0004			FASYSFILE	= $0004
   561 = 0008			FAVOLUMEID	= $0008
   562 = 0010			FADIRECTORY	= $0010
   563 = 0020			FAARCHIVE	= $0020
   564 = 003F			FAANYFILE	= $003F
   565
   566 				.endl							; UNIT SYSUTILS
   567
   568 				; -----------------------------------------------------------
   569
   570 8362			.local	B_CRT						; UNIT
   571
   572 8362			.local	ATASCII2ANTIC_01BF				; FUNCTION | OVERLOAD
   573
   574 				; -----------------------------------------------------------
   575
   576 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   577 				; as Pointer
   578 8362 BD 00 2C 8D 1B A0		mva :STACKORIGIN,x C
   579 8368 CA				dex						; sub bx, 1
   580
   581 					ift l_01C8-*>3
   582 					jmp l_01C8
   583 					eif
   584
   585 				; IfThenEpilog
   586 8369			l_01C8
   587
   588 				; ---------------------  ASM Block 064  ---------------------
   589
   590
   591 8369 AD 1B A0		        lda c
   592 836C 0A			        asl
   593 836D 08			        php
   594 836E C9 C0		        cmp #2*$60
   595 8370 B0 06		        bcs @+
   596 8372 E9 3F		        sbc #2*$20-1
   597 8374 B0 02		        bcs @+
   598 8376 69 C0		        adc #2*$60
   599 8378 28			@       plp
   600 8379 6A			        ror
   601 837A 8D 1C A0		        sta result;
   602 				    
   603
   604 837D			@exit
   605
   606 				; -----------------------------------------------------------
   607
   608 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   609 				; as Pointer
   610
   611 837D E8				inx						; add bx, 1
   612 837E AD 1C A0 9D 00 2C		mva RESULT :STACKORIGIN,x
   613
   614 					.ifdef @new
   615 					@FreeMem #@VarData #@VarDataSize
   616 					eif
   617
   618 				; -----------------------------------------------------------
   619
   620 = A01B			C	= DATAORIGIN+$001B
   621 = A01C			RESULT	= DATAORIGIN+$001C
   622
   623 = A01B			@VarData	= C
   624 = 0002			@VarDataSize	= 2
   625
   626 8384 60				rts						; ret
   627 				.endl
   628
   629 8385			.local	ATASCII2ANTIC_01CC				; FUNCTION | OVERLOAD
   630
   631 				; -----------------------------------------------------------
   632
   633 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   634 				; as Pointer
   635 8385 BD 00 2C 8D 0C 84		mva :STACKORIGIN,x S
   636 838B BD 10 2C 8D 0D 84		mva :STACKORIGIN+STACKWIDTH,x S+1
   637 8391 CA				dex						; sub bx, 1
   638 					@move S #adr.S #256
   638 				 MWA S @MOVE.PTR1\ MWA #ADR.S @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
   638 8392 AD 0C 84 85 A6 AD +  MWA S @MOVE.PTR1
   638 839C A9 1D 85 AA A9 A0 +  MWA #ADR.S @MOVE.PTR2
   638 83A4 A9 00 85 A2 A9 01 +  MWA #256 @MOVE.PTR3
   638 83AC 20 61 8A		 JSR @MOVE
   639 83AF A9 1D 8D 0C 84 A9 + 	mwa #adr.S S
   640
   641 					ift l_01D5-*>3
   642 					jmp l_01D5
   643 					eif
   644
   645 				; IfThenEpilog
   646 83B9			l_01D5
   647
   648 				; optimize OK (B_CRT), line = 468
   649
   650 83B9 AD 1D A0			lda adr.S+$00
   651 83BC 8D 1D A1			sta adr.RESULT+$00
   652 				; For
   653
   654 				; optimize OK (B_CRT), line = 469
   655
   656 83BF A9 01 8D 1D A2		mva #$01 I
   657
   658 				; optimize OK (B_CRT), line = 469
   659
   660 83C4 AD 1D A0			lda adr.S+$00
   661 83C7 8D 1E A2			sta @FORTMP_489
   662 				; To
   663 83CA			l_01EF
   664
   665 				; ForToDoCondition
   666
   667 				; optimize OK (B_CRT), line = 469
   668
   669 83CA AD 1D A2			lda I
   670 83CD CD 1E A2			cmp @FORTMP_489
   671 83D0 90 05			bcc *+7
   672 83D2 F0 03			beq *+5
   673
   674 				; ForToDoProlog
   675 83D4 4C FE 83			jmp l_01FD
   676
   677 				; optimize FAIL ('ATASCII2ANTIC_01BF', B_CRT), line = 470
   678 83D7 E8				inx
   679 83D8 AD 1D A2 9D 00 2C		mva I :STACKORIGIN,x
   680 83DE E8				inx
   681 83DF AC 1D A2			ldy I 
   682 83E2 B9 1D A0 9D 00 2C		mva adr.S,y :STACKORIGIN,x
   683 83E8 20 62 83			jsr ATASCII2ANTIC_01BF
   684 83EB BC FF 2B			ldy :STACKORIGIN-1,x
   685 83EE BD 00 2C 99 1D A1		mva :STACKORIGIN,x adr.RESULT,y
   686 83F4 CA				dex
   687 83F5 CA				dex
   688
   689 				; ForToDoEpilog
   690 83F6			c_01EF
   691 83F6 EE 1D A2			inc I						; inc ptr byte [CounterAddress]
   692
   693 83F9 F0 03			seq
   694
   695 				; WhileDoEpilog
   696 83FB 4C CA 83			jmp l_01EF
   697 83FE			l_01FD
   698 83FE			b_01EF
   699
   700 83FE			@exit
   701
   702 				; -----------------------------------------------------------
   703
   704 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   705 				; as Pointer
   706
   707 83FE E8				inx						; add bx, 1
   708 83FF AD 0E 84 9D 00 2C		mva RESULT :STACKORIGIN,x
   709 8405 AD 0F 84 9D 10 2C		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   710
   711 					.ifdef @new
   712 					@FreeMem #@VarData #@VarDataSize
   713 					eif
   714
   715 				; -----------------------------------------------------------
   716
   717 = A01D			adr.S	= DATAORIGIN+$001D
   718 840B			.var S	= adr.S .word
   719 = A11D			adr.RESULT	= DATAORIGIN+$011D
   720 840B			.var RESULT	= adr.RESULT .word
   721 = A21D			I	= DATAORIGIN+$021D
   722 = A21E			@FORTMP_489	= DATAORIGIN+$021E
   723
   724 = 840C			@VarData	= S
   725 = 0202			@VarDataSize	= 514
   726
   727 840B 60				rts						; ret
   728 = 840C 1D A0		S
   728 = 840E 1D A1		RESULT
   728 				.endl
   729
   730 8410			.local	CRT_INIT_0213					; PROCEDURE | OVERLOAD
   731
   732 				; -----------------------------------------------------------
   733
   734 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   735 				; as Pointer
   736 8410 BD 00 2C 8D 22 A2		mva :STACKORIGIN,x HEIGHT
   737 8416 CA				dex						; sub bx, 1
   738
   739 				; -----------------------------------------------------------
   740
   741 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   742 				; as Pointer
   743 8417 BD 00 2C 8D 21 A2		mva :STACKORIGIN,x WIDTH
   744 841D CA				dex						; sub bx, 1
   745
   746 				; -----------------------------------------------------------
   747
   748 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   749 				; as Pointer
   750 841E BD 00 2C 8D 1F A2		mva :STACKORIGIN,x VRAM_ADDRESS
   751 8424 BD 10 2C 8D 20 A2		mva :STACKORIGIN+STACKWIDTH,x VRAM_ADDRESS+1
   752 842A CA				dex						; sub bx, 1
   753
   754 					ift l_0228-*>3
   755 					jmp l_0228
   756 					eif
   757
   758 				; IfThenEpilog
   759 842B			l_0228
   760
   761 				; optimize OK (B_CRT), line = 483
   762
   763 842B AD 1F A2 8D 12 A0		mva VRAM_ADDRESS CRT_VRAM
   764 8431 AD 20 A2 8D 13 A0		mva VRAM_ADDRESS+1 CRT_VRAM+1
   765
   766 				; optimize OK (B_CRT), line = 484
   767
   768 8437 AD 21 A2 8D 16 A0		mva WIDTH CRT_SCREENWIDTH
   769
   770 				; optimize OK (B_CRT), line = 485
   771
   772 843D AD 22 A2 8D 17 A0		mva HEIGHT CRT_SCREENHEIGHT
   773
   774 				; optimize OK (B_CRT), line = 486
   775
   776 8443 AD 22 A2			lda HEIGHT
   777 8446 85 AA			sta :ecx
   778 8448 AD 21 A2			lda WIDTH
   779 844B 85 A2			sta :eax
   780 					.ifdef fmulinit
   781 					fmulu_8
   782 					els
   783 844D 20 3F 89			imulCL
   784 					eif
   785 8450 A5 A2			lda :eax
   786 8452 8D 14 A0			sta CRT_SIZE
   787 8455 A5 A3			lda :eax+1
   788 8457 8D 15 A0			sta CRT_SIZE+1
   789
   790 				; optimize OK (B_CRT), line = 487
   791
   792 845A AD 12 A0 8D 18 A0		mva CRT_VRAM CRT_CURSOR
   793 8460 AD 13 A0 8D 19 A0		mva CRT_VRAM+1 CRT_CURSOR+1
   794
   795 				; optimize OK (B_CRT), line = 488
   796
   797 8466 A9 00 8D 1A A0		mva #$00 CRT_LEFTMARGIN
   798
   799 				; -----------------------------------------------------------
   800
   801 = A21F			VRAM_ADDRESS	= DATAORIGIN+$021F
   802 = A221			WIDTH	= DATAORIGIN+$0221
   803 = A222			HEIGHT	= DATAORIGIN+$0222
   804
   805 = A21F			@VarData	= VRAM_ADDRESS
   806 = 0004			@VarDataSize	= 4
   807
   808
   809 846B			@exit
   810 					.ifdef @new
   811 					@FreeMem #@VarData #@VarDataSize
   812 					eif
   813 846B 60				rts						; ret
   814 				.endl
   815
   816 846C			.local	CRT_CLEAR_0261					; PROCEDURE | OVERLOAD
   817
   818 					ift l_0264-*>3
   819 					jmp l_0264
   820 					eif
   821
   822 				; IfThenEpilog
   823 846C			l_0264
   824
   825 				; optimize OK (B_CRT), line = 504
   826
   827 846C AD 12 A0			lda CRT_VRAM
   828 846F 85 A6			sta :edx
   829 8471 AD 13 A0			lda CRT_VRAM+1
   830 8474 85 A7			sta :edx+1
   831 8476 AD 14 A0			lda CRT_SIZE
   832 8479 85 AA			sta :ecx
   833 847B AD 15 A0			lda CRT_SIZE+1
   834 847E 85 AB			sta :ecx+1
   835 8480 A9 00			lda #$00
   836 8482 85 A2			sta :eax
   837 8484 20 B6 8A			jsr @fill
   838
   839 				; optimize OK (B_CRT), line = 505
   840
   841 8487 AD 12 A0 8D 18 A0		mva CRT_VRAM CRT_CURSOR
   842 848D AD 13 A0 8D 19 A0		mva CRT_VRAM+1 CRT_CURSOR+1
   843
   844 8493			@exit
   845 					.ifdef @new
   846 					@FreeMem #@VarData #@VarDataSize
   847 					eif
   848 8493 60				rts						; ret
   849 				.endl
   850
   851 8494			.local	CRT_GOTOXY					; PROCEDURE
   852
   853 				; -----------------------------------------------------------
   854
   855 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   856 				; as Pointer
   857 8494 BD 00 2C 8D 24 A2		mva :STACKORIGIN,x Y
   858 849A CA				dex						; sub bx, 1
   859
   860 				; -----------------------------------------------------------
   861
   862 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   863 				; as Pointer
   864 849B BD 00 2C 8D 23 A2		mva :STACKORIGIN,x X
   865 84A1 CA				dex						; sub bx, 1
   866
   867 					ift l_0282-*>3
   868 					jmp l_0282
   869 					eif
   870
   871 				; IfThenEpilog
   872 84A2			l_0282
   873
   874 				; optimize OK (B_CRT), line = 516
   875
   876 84A2 AD 16 A0			lda CRT_SCREENWIDTH
   877 84A5 85 AA			sta :ecx
   878 84A7 AD 24 A2			lda Y
   879 84AA 85 A2			sta :eax
   880 					.ifdef fmulinit
   881 					fmulu_8
   882 					els
   883 84AC 20 3F 89			imulCL
   884 					eif
   885 84AF A5 A2			lda :eax
   886 84B1 18 6D 23 A2			add X
   887 84B5 8D 09 2C			sta :STACKORIGIN+9
   888 84B8 A5 A3			lda :eax+1
   889 84BA 69 00			adc #$00
   890 84BC 8D 19 2C			sta :STACKORIGIN+STACKWIDTH+9
   891 84BF AD 09 2C			lda :STACKORIGIN+9
   892 84C2 18 6D 12 A0			add CRT_VRAM
   893 84C6 8D 18 A0			sta CRT_CURSOR
   894 84C9 AD 19 2C			lda :STACKORIGIN+STACKWIDTH+9
   895 84CC 6D 13 A0			adc CRT_VRAM+1
   896 84CF 8D 19 A0			sta CRT_CURSOR+1
   897
   898 				; -----------------------------------------------------------
   899
   900 = A223			X	= DATAORIGIN+$0223
   901 = A224			Y	= DATAORIGIN+$0224
   902
   903 = A223			@VarData	= X
   904 = 0002			@VarDataSize	= 2
   905
   906
   907 84D2			@exit
   908 					.ifdef @new
   909 					@FreeMem #@VarData #@VarDataSize
   910 					eif
   911 84D2 60				rts						; ret
   912 				.endl
   913
   914 84D3			.local	CRT_WRITE_029D					; PROCEDURE | OVERLOAD
   915
   916 				; -----------------------------------------------------------
   917
   918 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   919 				; as Pointer
   920 84D3 BD 00 2C 8D 3F 85		mva :STACKORIGIN,x S
   921 84D9 BD 10 2C 8D 40 85		mva :STACKORIGIN+STACKWIDTH,x S+1
   922 84DF CA				dex						; sub bx, 1
   923 					@move S #adr.S #256
   923 				 MWA S @MOVE.PTR1\ MWA #ADR.S @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
   923 84E0 AD 3F 85 85 A6 AD +  MWA S @MOVE.PTR1
   923 84EA A9 25 85 AA A9 A2 +  MWA #ADR.S @MOVE.PTR2
   923 84F2 A9 00 85 A2 A9 01 +  MWA #256 @MOVE.PTR3
   923 84FA 20 61 8A		 JSR @MOVE
   924 84FD A9 25 8D 3F 85 A9 + 	mwa #adr.S S
   925
   926 					ift l_02A6-*>3
   927 					jmp l_02A6
   928 					eif
   929
   930 				; IfThenEpilog
   931 8507			l_02A6
   932
   933 				; optimize OK (B_CRT), line = 531
   934
   935 8507 AD 3F 85			lda S
   936 850A 18 69 01			add #$01
   937 850D 85 A6			sta :edx
   938 850F AD 40 85			lda S+1
   939 8512 69 00			adc #$00
   940 8514 85 A7			sta :edx+1
   941 8516 AD 25 A2			lda adr.S+$00
   942 8519 85 A2			sta :eax
   943 851B AD 18 A0			lda CRT_CURSOR
   944 851E 85 AA			sta :ecx
   945 8520 AD 19 A0			lda CRT_CURSOR+1
   946 8523 85 AB			sta :ecx+1
   947 8525 A9 00			lda #$00
   948 8527 85 A3			sta :eax+1
   949 8529 20 61 8A			jsr @move
   950
   951 				; optimize OK (B_CRT), line = 532
   952
   953 852C AD 18 A0			lda CRT_CURSOR
   954 852F 18 6D 25 A2			add adr.S+$00
   955 8533 8D 18 A0			sta CRT_CURSOR
   956 8536 AD 19 A0			lda CRT_CURSOR+1
   957 8539 69 00			adc #$00
   958 853B 8D 19 A0			sta CRT_CURSOR+1
   959
   960 				; -----------------------------------------------------------
   961
   962 = A225			adr.S	= DATAORIGIN+$0225
   963 853E			.var S	= adr.S .word
   964
   965 = 853F			@VarData	= S
   966 = 0100			@VarDataSize	= 256
   967
   968
   969 853E			@exit
   970 					.ifdef @new
   971 					@FreeMem #@VarData #@VarDataSize
   972 					eif
   973 853E 60				rts						; ret
   974 = 853F 25 A2		S
   974 				.endl
   975
   976 8541			.local	CRT_WRITE_02B3					; PROCEDURE | OVERLOAD
   977
   978 				; -----------------------------------------------------------
   979
   980 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   981 				; as Pointer
   982 8541 BD 00 2C 8D 25 A3		mva :STACKORIGIN,x C
   983 8547 CA				dex						; sub bx, 1
   984
   985 					ift l_02BC-*>3
   986 					jmp l_02BC
   987 					eif
   988
   989 				; IfThenEpilog
   990 8548			l_02BC
   991
   992 				; optimize OK (B_CRT), line = 537
   993
   994 8548 AD 19 A0			lda CRT_CURSOR+1
   995 854B 85 AF			sta :bp+1
   996 854D AC 18 A0			ldy CRT_CURSOR
   997 8550 AD 25 A3			lda C
   998 8553 91 AE			sta (:bp),y
   999
  1000 				; optimize FAIL (0, B_CRT), line = 538
  1001 8555 EE 18 A0 D0 03 EE + 	inw CRT_CURSOR
  1002
  1003 				; -----------------------------------------------------------
  1004
  1005 = A325			C	= DATAORIGIN+$0325
  1006
  1007 = A325			@VarData	= C
  1008 = 0001			@VarDataSize	= 1
  1009
  1010
  1011 855D			@exit
  1012 					.ifdef @new
  1013 					@FreeMem #@VarData #@VarDataSize
  1014 					eif
  1015 855D 60				rts						; ret
  1016 				.endl
  1017
  1018 855E			.local	CRT_WRITE_02C7					; PROCEDURE | OVERLOAD
  1019
  1020 				; -----------------------------------------------------------
  1021
  1022 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1023 				; as Pointer
  1024 855E BD 00 2C 8D 26 A3		mva :STACKORIGIN,x NUM
  1025 8564 CA				dex						; sub bx, 1
  1026
  1027 					ift l_02D0-*>3
  1028 					jmp l_02D0
  1029 					eif
  1030
  1031 				; IfThenEpilog
  1032 8565			l_02D0
  1033
  1034 				; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 543
  1035 8565 E8				inx
  1036 8566 AD 26 A3 9D 00 2C		mva NUM :STACKORIGIN,x
  1037 856C 20 11 89			jsr @expandToCARD.BYTE
  1038 856F 20 25 83			jsr SYSUTILS.INTTOSTR
  1039 8572 20 85 83			jsr ATASCII2ANTIC_01CC
  1040 8575 20 D3 84			jsr CRT_WRITE_029D
  1041
  1042 				; -----------------------------------------------------------
  1043
  1044 = A326			NUM	= DATAORIGIN+$0326
  1045
  1046 = A326			@VarData	= NUM
  1047 = 0001			@VarDataSize	= 1
  1048
  1049
  1050 8578			@exit
  1051 					.ifdef @new
  1052 					@FreeMem #@VarData #@VarDataSize
  1053 					eif
  1054 8578 60				rts						; ret
  1055 				.endl
  1056
  1057 8579			.local	CRT_WRITE_02D7					; PROCEDURE | OVERLOAD
  1058
  1059 				; -----------------------------------------------------------
  1060
  1061 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  1062 				; as Pointer
  1063 8579 BD 00 2C 8D 27 A3		mva :STACKORIGIN,x NUM
  1064 857F BD 10 2C 8D 28 A3		mva :STACKORIGIN+STACKWIDTH,x NUM+1
  1065 8585 CA				dex						; sub bx, 1
  1066
  1067 					ift l_02E0-*>3
  1068 					jmp l_02E0
  1069 					eif
  1070
  1071 				; IfThenEpilog
  1072 8586			l_02E0
  1073
  1074 				; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 548
  1075 8586 E8				inx
  1076 8587 AD 27 A3 9D 00 2C		mva NUM :STACKORIGIN,x
  1077 858D AD 28 A3 9D 10 2C		mva NUM+1 :STACKORIGIN+STACKWIDTH,x
  1078 8593 20 04 89			jsr @expandToCARD.WORD
  1079 8596 20 25 83			jsr SYSUTILS.INTTOSTR
  1080 8599 20 85 83			jsr ATASCII2ANTIC_01CC
  1081 859C 20 D3 84			jsr CRT_WRITE_029D
  1082
  1083 				; -----------------------------------------------------------
  1084
  1085 = A327			NUM	= DATAORIGIN+$0327
  1086
  1087 = A327			@VarData	= NUM
  1088 = 0002			@VarDataSize	= 2
  1089
  1090
  1091 859F			@exit
  1092 					.ifdef @new
  1093 					@FreeMem #@VarData #@VarDataSize
  1094 					eif
  1095 859F 60				rts						; ret
  1096 				.endl
  1097
  1098 85A0			.local	CRT_KEYPRESSED					; FUNCTION
  1099
  1100 					ift l_02E9-*>3
  1101 					jmp l_02E9
  1102 					eif
  1103
  1104 				; IfThenEpilog
  1105 85A0			l_02E9
  1106
  1107 				; optimize OK (B_CRT), line = 592
  1108
  1109 85A0 A9 00 8D 29 A3		mva #$00 RESULT
  1110
  1111 				; optimize OK (B_CRT), line = 593
  1112
  1113 85A5 AD 0F D2			lda ATARI.SKSTAT
  1114 85A8 A0 01			ldy #1
  1115 85AA 29 04			and #$04
  1116 85AC F0 01			beq @+
  1117 85AE 88				dey
  1118 85AF			@
  1119 					.ifdef IFTMP_28
  1120 					sty IFTMP_28
  1121 					eif
  1122 85AF 98				tya
  1123 85B0 D0 03			bne *+5
  1124 85B2 4C BA 85			jmp l_0306
  1125
  1126 				; optimize OK (B_CRT), line = 593
  1127
  1128 85B5 A9 01 8D 29 A3		mva #$01 RESULT
  1129
  1130 				; IfThenEpilog
  1131 85BA			l_0306
  1132
  1133 85BA			@exit
  1134
  1135 				; -----------------------------------------------------------
  1136
  1137 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1138 				; as Pointer
  1139
  1140 85BA E8				inx						; add bx, 1
  1141 85BB AD 29 A3 9D 00 2C		mva RESULT :STACKORIGIN,x
  1142
  1143 					.ifdef @new
  1144 					@FreeMem #@VarData #@VarDataSize
  1145 					eif
  1146
  1147 				; -----------------------------------------------------------
  1148
  1149 = A329			RESULT	= DATAORIGIN+$0329
  1150
  1151 = A329			@VarData	= RESULT
  1152 = 0001			@VarDataSize	= 1
  1153
  1154 85C1 60				rts						; ret
  1155 				.endl
  1156
  1157 				; -----------------------------------------------------------
  1158
  1159 = 0028			DEFAULT_SCREENWIDTH	= $0028
  1160 = 0018			DEFAULT_SCREENHEIGHT	= $0018
  1161 = 009B			CHAR_RETURN	= $009B
  1162 = 001B			CHAR_ESCAPE	= $001B
  1163 = 007E			CHAR_BACKSPACE	= $007E
  1164 = 007F			CHAR_TAB	= $007F
  1165 = 0081			CHAR_INVERSE	= $0081
  1166 = 0082			CHAR_CAPS	= $0082
  1167 = 00DB			ICHAR_RETURN	= $00DB
  1168 = 005B			ICHAR_ESCAPE	= $005B
  1169 = 007E			ICHAR_BACKSPACE	= $007E
  1170 = 007F			ICHAR_TAB	= $007F
  1171 = 00C1			ICHAR_INVERSE	= $00C1
  1172 = 00C2			ICHAR_CAPS	= $00C2
  1173 = 8137			adr.CRT_KEYCODE	= CODEORIGIN+$0137
  1174 85C2			.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
  1175 = A012			CRT_VRAM	= DATAORIGIN+$0012
  1176 = A014			CRT_SIZE	= DATAORIGIN+$0014
  1177 = A016			CRT_SCREENWIDTH	= DATAORIGIN+$0016
  1178 = A017			CRT_SCREENHEIGHT	= DATAORIGIN+$0017
  1179 = A018			CRT_CURSOR	= DATAORIGIN+$0018
  1180 = A01A			CRT_LEFTMARGIN	= DATAORIGIN+$001A
  1181 = D209			KBCODE	= $D209
  1182 = D01F			CONSOL	= $D01F
  1183
  1184 = 85C2 37 81		CRT_KEYCODE
  1184 				.endl							; UNIT B_CRT
  1185
  1186 85C4			.local	SHOWTITLESCREEN					; PROCEDURE
  1187
  1188 					ift l_0320-*>3
  1189 					jmp l_0320
  1190 					eif
  1191
  1192 				; IfThenEpilog
  1193 85C4			l_0320
  1194
  1195 				; optimize OK (Mind Field.pas), line = 125
  1196
  1197 85C4 A9 00			lda #$00
  1198 85C6 8D 48 A3			sta TOPMEM
  1199 85C9 AD 4A A3			lda CHBASE1
  1200 85CC 8D 49 A3			sta TOPMEM+1
  1201
  1202 				; ---------------------  ASM Block 066  ---------------------
  1203
  1204
  1205 				;	  ICL "Atari 8-bit Equates.asm"
  1206 						
  1207 85CF A9 00		    lda #0
  1208 85D1 85 52		    sta 82
  1209 85D3 8D C6 02		    sta 710
  1210 85D6 A9 0C		    lda #12
  1211 85D8 8D C5 02		    sta 709
  1212 				    ; lda chbase1
  1213 				    ; sta 756
  1214 85DB A9 00		    LDA #0
  1215 85DD 8D 0E D4		    STA NMIEN
  1216 85E0 8D 00 D4		    STA DMACTL
  1217 85E3 8D 1B D0		    STA PRIOR
  1218 85E6 8D 1E D0		    STA HITCLR
  1219
  1220 				;    LDX #>RamSizeCode+1
  1221 85E9 A0 00		    LDY #$00
  1222 85EB 84 CA		    STY NDX0
  1223 85ED 84 CC		    STY NDX2
  1224 85EF A9 38		    LDA #$38
  1225 85F1 85 CB		    STA NDX1
  1226 85F3 A9 A8		    LDA #$A8
  1227 85F5 85 CD		    STA NDX3
  1228 				    
  1229
  1230 				; optimize FAIL ('B_CRT.CRT_INIT_0213', Mind Field.pas), line = 152
  1231 85F7 E8				inx
  1232 85F8 A9 00 9D 00 2C		mva #$00 :STACKORIGIN,x
  1233 85FD A9 40 9D 10 2C		mva #$40 :STACKORIGIN+STACKWIDTH,x
  1234 8602 E8				inx
  1235 8603 A9 28 9D 00 2C		mva #$28 :STACKORIGIN,x
  1236 8608 E8				inx
  1237 8609 A9 12 9D 00 2C		mva #$12 :STACKORIGIN,x
  1238 860E 20 10 84			jsr B_CRT.CRT_INIT_0213
  1239
  1240 				; optimize FAIL ('B_CRT.CRT_CLEAR_0261', Mind Field.pas), line = 153
  1241 8611 20 6C 84			jsr B_CRT.CRT_CLEAR_0261
  1242
  1243 				; optimize OK (Mind Field.pas), line = 154
  1244
  1245 8614 A9 37 8D 02 D4		mva #$37 ATARI.DLISTW
  1246 8619 A9 82 8D 03 D4		mva #$82 ATARI.DLISTW+1
  1247
  1248 				; optimize OK (Mind Field.pas), line = 155
  1249
  1250 861E A9 37 8D 30 02		mva #$37 ATARI.SDLSTW
  1251 8623 A9 82 8D 31 02		mva #$82 ATARI.SDLSTW+1
  1252
  1253 				; optimize OK (Mind Field.pas), line = 156
  1254
  1255 8628 A9 00 85 58			mva #$00 ATARI.SAVMSC
  1256 862C A9 40 85 59			mva #$40 ATARI.SAVMSC+1
  1257
  1258 				; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 157
  1259 8630 E8				inx
  1260 8631 A9 A4 9D 00 2C		mva #$A4 :STACKORIGIN,x
  1261 8636 20 17 83			jsr B_SYSTEM.SETCHARSET
  1262
  1263 				; optimize OK (Mind Field.pas), line = 158
  1264
  1265 8639 A9 A4 8D F4 02		mva #$A4 ATARI.CHBAS
  1266
  1267 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 159
  1268 863E E8				inx
  1269 863F A9 00 9D 00 2C		mva #$00 :STACKORIGIN,x
  1270 8644 E8				inx
  1271 8645 9D 00 2C			sta :STACKORIGIN,x
  1272 8648 20 94 84			jsr B_CRT.CRT_GOTOXY
  1273
  1274 				; optimize FAIL ('B_CRT.CRT_WRITE_029D', Mind Field.pas), line = 160
  1275 864B E8				inx
  1276 864C A9 02 9D 00 2C		mva #$02 :STACKORIGIN,x
  1277 8651 A9 80 9D 10 2C		mva #$80 :STACKORIGIN+STACKWIDTH,x
  1278 8656 20 D3 84			jsr B_CRT.CRT_WRITE_029D
  1279
  1280 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 161
  1281 8659 E8				inx
  1282 865A A9 00 9D 00 2C		mva #$00 :STACKORIGIN,x
  1283 865F E8				inx
  1284 8660 A9 06 9D 00 2C		mva #$06 :STACKORIGIN,x
  1285 8665 20 94 84			jsr B_CRT.CRT_GOTOXY
  1286
  1287 				; optimize FAIL ('B_CRT.CRT_WRITE_029D', Mind Field.pas), line = 162
  1288 8668 E8				inx
  1289 8669 A9 2B 9D 00 2C		mva #$2B :STACKORIGIN,x
  1290 866E A9 80 9D 10 2C		mva #$80 :STACKORIGIN+STACKWIDTH,x
  1291 8673 20 D3 84			jsr B_CRT.CRT_WRITE_029D
  1292
  1293 				; optimize FAIL ('B_CRT.CRT_WRITE_029D', Mind Field.pas), line = 163
  1294 8676 E8				inx
  1295 8677 A9 55 9D 00 2C		mva #$55 :STACKORIGIN,x
  1296 867C A9 80 9D 10 2C		mva #$80 :STACKORIGIN+STACKWIDTH,x
  1297 8681 20 D3 84			jsr B_CRT.CRT_WRITE_029D
  1298
  1299 				; optimize FAIL ('B_CRT.CRT_WRITE_029D', Mind Field.pas), line = 164
  1300 8684 E8				inx
  1301 8685 A9 7F 9D 00 2C		mva #$7F :STACKORIGIN,x
  1302 868A A9 80 9D 10 2C		mva #$80 :STACKORIGIN+STACKWIDTH,x
  1303 868F 20 D3 84			jsr B_CRT.CRT_WRITE_029D
  1304
  1305 				; optimize FAIL ('B_CRT.CRT_WRITE_029D', Mind Field.pas), line = 165
  1306 8692 E8				inx
  1307 8693 A9 A9 9D 00 2C		mva #$A9 :STACKORIGIN,x
  1308 8698 A9 80 9D 10 2C		mva #$80 :STACKORIGIN+STACKWIDTH,x
  1309 869D 20 D3 84			jsr B_CRT.CRT_WRITE_029D
  1310
  1311 				; optimize FAIL ('B_CRT.CRT_WRITE_029D', Mind Field.pas), line = 166
  1312 86A0 E8				inx
  1313 86A1 A9 D3 9D 00 2C		mva #$D3 :STACKORIGIN,x
  1314 86A6 A9 80 9D 10 2C		mva #$80 :STACKORIGIN+STACKWIDTH,x
  1315 86AB 20 D3 84			jsr B_CRT.CRT_WRITE_029D
  1316
  1317 				; optimize OK (Mind Field.pas), line = 168
  1318
  1319 86AE A9 0A 8D C5 02		mva #$0A ATARI.COLOR1
  1320
  1321 				; optimize OK (Mind Field.pas), line = 169
  1322
  1323 86B3 A9 BA 8D C6 02		mva #$BA ATARI.COLOR2
  1324
  1325 				; optimize OK (Mind Field.pas), line = 170
  1326
  1327 86B8 A9 22 8D C8 02		mva #$22 ATARI.COLOR4
  1328
  1329 				; optimize OK (Mind Field.pas), line = 172
  1330
  1331 86BD A9 06 8D 2E A3		mva #$06 K
  1332
  1333 				; optimize OK (Mind Field.pas), line = 173
  1334
  1335 86C2 A9 05 8D 2C A3		mva #$05 I
  1336
  1337 				; optimize OK (Mind Field.pas), line = 174
  1338
  1339 86C7 A9 3E 8D 00 D4		mva #$3E ATARI.DMACTL
  1340
  1341 				; optimize OK (Mind Field.pas), line = 175
  1342
  1343 86CC A9 40 8D 0E D4		mva #$40 ATARI.NMIEN
  1344
  1345 				; --- RepeatUntilProlog
  1346 86D1			l_0394
  1347
  1348 				; optimize OK (Mind Field.pas), line = 178
  1349
  1350 86D1 AD 2C A3			lda I
  1351 86D4 0A				asl @
  1352 86D5 A8				tay
  1353 86D6 B9 32 A3			lda adr.HISCORE,y
  1354 86D9 8D 0A 2C			sta :STACKORIGIN+10
  1355 86DC B9 33 A3			lda adr.HISCORE+1,y
  1356 86DF 8D 1A 2C			sta :STACKORIGIN+STACKWIDTH+10
  1357 86E2 A0 01			ldy #1
  1358 86E4 AD 31 A3			lda SCORE+1
  1359 86E7 CD 1A 2C			cmp :STACKORIGIN+STACKWIDTH+10
  1360 86EA D0 06			bne @+
  1361 86EC AD 30 A3			lda SCORE
  1362 86EF CD 0A 2C			cmp :STACKORIGIN+10
  1363 86F2			@
  1364 86F2 F0 02			seq
  1365 86F4 B0 01			bcs @+
  1366 86F6 88				dey
  1367 86F7			@
  1368 					.ifdef IFTMP_32
  1369 					sty IFTMP_32
  1370 					eif
  1371 86F7 98				tya
  1372 86F8 D0 03			bne *+5
  1373 86FA 4C 03 87			jmp l_03A9
  1374
  1375 				; optimize OK (Mind Field.pas), line = 180
  1376
  1377 86FD AD 2C A3 8D 2E A3		mva I K
  1378
  1379 				; IfThenEpilog
  1380 8703			l_03A9
  1381
  1382 				; optimize OK (Mind Field.pas), line = 182
  1383
  1384 8703 CE 2C A3			dec I
  1385
  1386 				; optimize OK (Mind Field.pas), line = 183
  1387
  1388 8706 A0 01			ldy #1
  1389 8708 AD 2C A3			lda I
  1390 870B F0 01			beq @+
  1391 870D 88				dey
  1392 870E			@
  1393 870E 98				tya
  1394 870F D0 03			bne *+5
  1395 8711			c_0394
  1396 8711 4C D1 86			jmp l_0394
  1397 8714			b_0394
  1398
  1399 				; optimize OK (Mind Field.pas), line = 184
  1400
  1401 8714 A0 01			ldy #1
  1402 8716 AD 2E A3			lda K
  1403 8719 C9 05			cmp #$05
  1404 871B 90 01			bcc @+
  1405 871D 88				dey
  1406 871E			@
  1407 					.ifdef IFTMP_33
  1408 					sty IFTMP_33
  1409 					eif
  1410 871E 98				tya
  1411 871F D0 03			bne *+5
  1412 8721 4C 78 87			jmp l_03E1
  1413
  1414 				; optimize OK (Mind Field.pas), line = 186
  1415
  1416 8724 A9 05 8D 2C A3		mva #$05 I
  1417
  1418 				; --- RepeatUntilProlog
  1419 8729			l_03EA
  1420
  1421 				; optimize OK (Mind Field.pas), line = 188
  1422
  1423 8729 AD 2C A3			lda I
  1424 872C 0A				asl @
  1425 872D 8D 09 2C			sta :STACKORIGIN+9
  1426 8730 AD 2C A3			lda I
  1427 8733 38 E9 01			sub #$01
  1428 8736 0A				asl @
  1429 8737 A8				tay
  1430 8738 B9 32 A3			lda adr.HISCORE,y
  1431 873B 8D 0A 2C			sta :STACKORIGIN+10
  1432 873E B9 33 A3			lda adr.HISCORE+1,y
  1433 8741 8D 1A 2C			sta :STACKORIGIN+STACKWIDTH+10
  1434 8744 AC 09 2C			ldy :STACKORIGIN+9
  1435 8747 AD 0A 2C			lda :STACKORIGIN+10
  1436 874A 99 32 A3			sta adr.HISCORE,y
  1437 874D AD 1A 2C			lda :STACKORIGIN+STACKWIDTH+10
  1438 8750 99 33 A3			sta adr.HISCORE+1,y
  1439
  1440 				; optimize OK (Mind Field.pas), line = 189
  1441
  1442 8753 CE 2C A3			dec I
  1443
  1444 				; optimize OK (Mind Field.pas), line = 190
  1445
  1446 8756 A0 01			ldy #1
  1447 8758 AD 2C A3			lda I
  1448 875B CD 2E A3			cmp K
  1449 875E F0 01			beq @+
  1450 8760 88				dey
  1451 8761			@
  1452 8761 98				tya
  1453 8762 D0 03			bne *+5
  1454 8764			c_03EA
  1455 8764 4C 29 87			jmp l_03EA
  1456 8767			b_03EA
  1457
  1458 				; optimize OK (Mind Field.pas), line = 191
  1459
  1460 8767 AD 2E A3			lda K
  1461 876A 0A				asl @
  1462 876B A8				tay
  1463 876C AD 30 A3			lda SCORE
  1464 876F 99 32 A3			sta adr.HISCORE,y
  1465 8772 AD 31 A3			lda SCORE+1
  1466 8775 99 33 A3			sta adr.HISCORE+1,y
  1467
  1468 				; IfThenEpilog
  1469 8778			l_03E1
  1470
  1471 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 193
  1472 8778 E8				inx
  1473 8779 A9 0A 9D 00 2C		mva #$0A :STACKORIGIN,x
  1474 877E E8				inx
  1475 877F A9 0D 9D 00 2C		mva #$0D :STACKORIGIN,x
  1476 8784 20 94 84			jsr B_CRT.CRT_GOTOXY
  1477
  1478 				; optimize FAIL ('B_CRT.CRT_WRITE_029D', Mind Field.pas), line = 194
  1479 8787 E8				inx
  1480 8788 A9 FD 9D 00 2C		mva #$FD :STACKORIGIN,x
  1481 878D A9 80 9D 10 2C		mva #$80 :STACKORIGIN+STACKWIDTH,x
  1482 8792 20 D3 84			jsr B_CRT.CRT_WRITE_029D
  1483
  1484 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 195
  1485 8795 E8				inx
  1486 8796 A9 12 9D 00 2C		mva #$12 :STACKORIGIN,x
  1487 879B E8				inx
  1488 879C A9 0D 9D 00 2C		mva #$0D :STACKORIGIN,x
  1489 87A1 20 94 84			jsr B_CRT.CRT_GOTOXY
  1490
  1491 				; optimize FAIL ('B_CRT.CRT_WRITE_02D7', Mind Field.pas), line = 196
  1492 87A4 E8				inx
  1493 87A5 AD 30 A3 9D 00 2C		mva SCORE :STACKORIGIN,x
  1494 87AB AD 31 A3 9D 10 2C		mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
  1495 87B1 20 79 85			jsr B_CRT.CRT_WRITE_02D7
  1496
  1497 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 197
  1498 87B4 E8				inx
  1499 87B5 A9 08 9D 00 2C		mva #$08 :STACKORIGIN,x
  1500 87BA E8				inx
  1501 87BB A9 0F 9D 00 2C		mva #$0F :STACKORIGIN,x
  1502 87C0 20 94 84			jsr B_CRT.CRT_GOTOXY
  1503
  1504 				; optimize FAIL ('B_CRT.CRT_WRITE_029D', Mind Field.pas), line = 198
  1505 87C3 E8				inx
  1506 87C4 A9 07 9D 00 2C		mva #$07 :STACKORIGIN,x
  1507 87C9 A9 81 9D 10 2C		mva #$81 :STACKORIGIN+STACKWIDTH,x
  1508 87CE 20 D3 84			jsr B_CRT.CRT_WRITE_029D
  1509 				; For
  1510
  1511 				; optimize OK (Mind Field.pas), line = 199
  1512
  1513 87D1 A9 01 8D 2C A3		mva #$01 I
  1514
  1515 				; optimize OK (Mind Field.pas), line = 199
  1516
  1517 				; To
  1518 87D6			l_043E
  1519
  1520 				; ForToDoCondition
  1521
  1522 				; optimize OK (Mind Field.pas), line = 199
  1523
  1524 87D6 AD 2C A3			lda I
  1525 87D9 C9 05			cmp #$05
  1526 87DB 90 05			bcc *+7
  1527 87DD F0 03			beq *+5
  1528
  1529 				; ForToDoProlog
  1530 87DF 4C 8E 88			jmp l_044C
  1531
  1532 				; optimize OK (Mind Field.pas), line = 201
  1533
  1534 87E2 A0 01			ldy #1
  1535 87E4 AD 2E A3			lda K
  1536 87E7 CD 2C A3			cmp I
  1537 87EA F0 01			beq @+
  1538 87EC 88				dey
  1539 87ED			@
  1540 					.ifdef IFTMP_34
  1541 					sty IFTMP_34
  1542 					eif
  1543 87ED 98				tya
  1544 87EE D0 03			bne *+5
  1545 87F0 4C 16 88			jmp l_0460
  1546
  1547 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 203
  1548 87F3 E8				inx
  1549 87F4 A9 0C 9D 00 2C		mva #$0C :STACKORIGIN,x
  1550 87F9 E8				inx
  1551 87FA A9 10 9D 00 2C		mva #$10 :STACKORIGIN,x
  1552 87FF E8				inx
  1553 8800 AD 2C A3 9D 00 2C		mva I :STACKORIGIN,x
  1554 8806 20 E0 88			jsr addAL_CL
  1555 8809 CA				dex
  1556 880A 20 94 84			jsr B_CRT.CRT_GOTOXY
  1557
  1558 				; optimize FAIL ('B_CRT.CRT_WRITE_02B3', Mind Field.pas), line = 204
  1559 880D E8				inx
  1560 880E A9 0A 9D 00 2C		mva #$0A :STACKORIGIN,x
  1561 8813 20 41 85			jsr B_CRT.CRT_WRITE_02B3
  1562
  1563 				; IfThenEpilog
  1564 8816			l_0460
  1565
  1566 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 206
  1567 8816 E8				inx
  1568 8817 A9 0E 9D 00 2C		mva #$0E :STACKORIGIN,x
  1569 881C E8				inx
  1570 881D A9 10 9D 00 2C		mva #$10 :STACKORIGIN,x
  1571 8822 E8				inx
  1572 8823 AD 2C A3 9D 00 2C		mva I :STACKORIGIN,x
  1573 8829 20 E0 88			jsr addAL_CL
  1574 882C CA				dex
  1575 882D 20 94 84			jsr B_CRT.CRT_GOTOXY
  1576
  1577 				; optimize FAIL ('B_CRT.CRT_WRITE_02C7', Mind Field.pas), line = 207
  1578 8830 E8				inx
  1579 8831 AD 2C A3 9D 00 2C		mva I :STACKORIGIN,x
  1580 8837 20 5E 85			jsr B_CRT.CRT_WRITE_02C7
  1581
  1582 				; optimize FAIL ('B_CRT.CRT_WRITE_029D', Mind Field.pas), line = 208
  1583 883A E8				inx
  1584 883B A9 1C 9D 00 2C		mva #$1C :STACKORIGIN,x
  1585 8840 A9 81 9D 10 2C		mva #$81 :STACKORIGIN+STACKWIDTH,x
  1586 8845 20 D3 84			jsr B_CRT.CRT_WRITE_029D
  1587
  1588 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 209
  1589 8848 E8				inx
  1590 8849 A9 12 9D 00 2C		mva #$12 :STACKORIGIN,x
  1591 884E E8				inx
  1592 884F A9 10 9D 00 2C		mva #$10 :STACKORIGIN,x
  1593 8854 E8				inx
  1594 8855 AD 2C A3 9D 00 2C		mva I :STACKORIGIN,x
  1595 885B 20 E0 88			jsr addAL_CL
  1596 885E CA				dex
  1597 885F 20 94 84			jsr B_CRT.CRT_GOTOXY
  1598
  1599 				; optimize FAIL ('B_CRT.CRT_WRITE_02D7', Mind Field.pas), line = 210
  1600 8862 E8				inx
  1601 8863 AD 2C A3 9D 00 2C		mva I :STACKORIGIN,x
  1602 8869 A9 00 9D 10 2C		mva #$00 :STACKORIGIN+STACKWIDTH,x
  1603 886E				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 886E 1E 00 2C			asl :STACKORIGIN-0,x
     2 8871 3E 10 2C			rol :STACKORIGIN-0+STACKWIDTH,x
Source: Mind Field.a65
  1604 8874 BC 00 2C			ldy :STACKORIGIN,x
  1605 8877 B9 32 A3 9D 00 2C		mva adr.HISCORE,y :STACKORIGIN,x
  1606 887D B9 33 A3 9D 10 2C		mva adr.HISCORE+1,y :STACKORIGIN+STACKWIDTH,x
  1607 8883 20 79 85			jsr B_CRT.CRT_WRITE_02D7
  1608
  1609 				; ForToDoEpilog
  1610 8886			c_043E
  1611 8886 EE 2C A3			inc I						; inc ptr byte [CounterAddress]
  1612
  1613 8889 F0 03			seq
  1614
  1615 				; WhileDoEpilog
  1616 888B 4C D6 87			jmp l_043E
  1617 888E			l_044C
  1618 888E			b_043E
  1619
  1620 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 212
  1621 888E E8				inx
  1622 888F A9 07 9D 00 2C		mva #$07 :STACKORIGIN,x
  1623 8894 E8				inx
  1624 8895 A9 17 9D 00 2C		mva #$17 :STACKORIGIN,x
  1625 889A 20 94 84			jsr B_CRT.CRT_GOTOXY
  1626
  1627 				; optimize FAIL ('B_CRT.CRT_WRITE_029D', Mind Field.pas), line = 213
  1628 889D E8				inx
  1629 889E A9 20 9D 00 2C		mva #$20 :STACKORIGIN,x
  1630 88A3 A9 81 9D 10 2C		mva #$81 :STACKORIGIN+STACKWIDTH,x
  1631 88A8 20 D3 84			jsr B_CRT.CRT_WRITE_029D
  1632
  1633 				; optimize OK (Mind Field.pas), line = 214
  1634
  1635 88AB A9 00			lda #$00
  1636 88AD 85 AF			sta :bp+1
  1637 88AF AC 00 D0			ldy ATARI.HPOSP0
  1638 88B2 A9 7C			lda #$7C
  1639 88B4 91 AE			sta (:bp),y
  1640
  1641 				; --- RepeatUntilProlog
  1642 88B6			l_049C
  1643
  1644 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', Mind Field.pas), line = 219
  1645 88B6 20 A0 85			jsr B_CRT.CRT_KEYPRESSED
  1646 88B9 CA				dex
  1647 88BA BD 01 2C			lda :STACKORIGIN+1,x
  1648 88BD D0 03			bne *+5
  1649 88BF			c_049C
  1650 88BF 4C B6 88			jmp l_049C
  1651 88C2			b_049C
  1652
  1653 				; -----------------------------------------------------------
  1654
  1655 = 0005			@FORTMP_1080	= $0005
  1656
  1657 88C2			@exit
  1658 					.ifdef @new
  1659 					@FreeMem #@VarData #@VarDataSize
  1660 					eif
  1661 88C2 60				rts						; ret
  1662 				.endl
  1663
  1664 				; IfThenEpilog
  1665 88C3			l_013E
  1666
  1667 				; optimize FAIL ('SHOWTITLESCREEN', Mind Field.pas), line = 244
  1668 88C3 20 C4 85			jsr SHOWTITLESCREEN
  1669
  1670 				; ---------------------  ASM Block 067  ---------------------
  1671
  1672
  1673 = 0400			DISPLIST 	          = $0400
  1674 = 0440			SCRTXT              = $0440
  1675 				;SCREEN              = $8000
  1676 				       
  1677
  1678
  1679 				; -----------------------------------------------------------
  1680
  1681 = D01B			PRIOR	= $D01B
  1682 = 00C0			TEMP0	= $00C0
  1683 = 00C1			TEMP1	= $00C1
  1684 = 00C2			TEMP2	= $00C2
  1685 = 00C3			TEMP3	= $00C3
  1686 = 00C4			TEMP4	= $00C4
  1687 = 00C5			TEMP5	= $00C5
  1688 = 00C6			TEMP6	= $00C6
  1689 = 00C7			TEMP7	= $00C7
  1690 = 00C8			TEMP8	= $00C8
  1691 = 00C9			TEMP9	= $00C9
  1692 = 00CA			NDX0	= $00CA
  1693 = 00CB			NDX1	= $00CB
  1694 = 00CC			NDX2	= $00CC
  1695 = 00CD			NDX3	= $00CD
  1696 = 00CE			HOLDX	= $00CE
  1697 = 00CF			HOLDY	= $00CF
  1698 = 00C0			M0	= $00C0
  1699 = 00C1			M1	= $00C1
  1700 = 00C2			M2	= $00C2
  1701 = 00C3			M3	= $00C3
  1702 = 00C4			M4	= $00C4
  1703 = 00C5			M5	= $00C5
  1704 = 00C6			M6	= $00C6
  1705 = 00C7			M7	= $00C7
  1706 = 00C8			M8	= $00C8
  1707 = 00C9			M9	= $00C9
  1708 = 00CE			MX	= $00CE
  1709 = 00CF			MY	= $00CF
  1710 = 4000			SCREEN_ADR	= $4000
  1711 = 1000			PMBANK	= $1000
  1712 = 1800			VARBANK	= $1800
  1713 = 1180			SPRITENUM	= $1180
  1714 = 1190			SETSP0COLOR	= $1190
  1715 = 11A0			SETSP1COLOR	= $11A0
  1716 = 11B0			SETSPWIDTH	= $11B0
  1717 = 11C0			SPRITENHOZ	= $11C0
  1718 = 11E0			SPRITENVRT	= $11E0
  1719 = 11F0			SPHOZNEXT	= $11F0
  1720 = 1000			SCREEN_LINE_ADDR_LOW	= $1000
  1721 = 1020			SCREEN_LINE_ADDR_HIGH	= $1020
  1722 = A400			CHARSET_ADDRESS	= $A400
  1723 = 00A4			CHARSET_BASE	= $00A4
  1724 = 1200			SPRHZ0	= $1200
  1725 = 1210			SPRHZ1	= $1210
  1726 = 1220			SPRHZ2	= $1220
  1727 = 1230			SPRHZ3	= $1230
  1728 = 1240			SPZONT	= $1240
  1729 = 1250			SPZONB	= $1250
  1730 = 1260			SPSRC0	= $1260
  1731 = 1278			SPSRC1	= $1278
  1732 = 1290			SPSRC2	= $1290
  1733 = 12A8			SPSRC3	= $12A8
  1734 = 12C0			SPSRC4	= $12C0
  1735 = 12D8			SPRITEUSE	= $12D8
  1736 = 1300			MIBANK	= $1300
  1737 = 1400			PMBNK0	= $1400
  1738 = 1500			PMBNK1	= $1500
  1739 = 1600			PMBNK2	= $1600
  1740 = 1700			PMBNK3	= $1700
  1741 = 8237			adr.DISPLAY_LIST_TITLE	= CODEORIGIN+$0237
  1742 88C6			.var DISPLAY_LIST_TITLE	= adr.DISPLAY_LIST_TITLE .word
  1743 = 826A			adr.DISPLAY_LIST_GAME	= CODEORIGIN+$026A
  1744 88C6			.var DISPLAY_LIST_GAME	= adr.DISPLAY_LIST_GAME .word
  1745 = A32A			SCREEN	= DATAORIGIN+$032A
  1746 = A32C			I	= DATAORIGIN+$032C
  1747 = A32D			J	= DATAORIGIN+$032D
  1748 = A32E			K	= DATAORIGIN+$032E
  1749 = A32F			TITLEPHASE	= DATAORIGIN+$032F
  1750 = A330			SCORE	= DATAORIGIN+$0330
  1751 = A332			adr.HISCORE	= DATAORIGIN+$0332
  1752 88C6			.var HISCORE	= adr.HISCORE .word
  1753 = A348			TOPMEM	= DATAORIGIN+$0348
  1754 = A34A			CHBASE1	= DATAORIGIN+$034A
  1755
  1756 88C6			@exit
  1757
  1758 88C6 A2 00		@halt	ldx #0
  1759 88C8 9A				txs
  1760
  1761 88C9 60				rts
  1762
  1763 88CA 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  1764
  1765 88DA			.local	@DEFINES
  1766 88DA			ATARI
  1767 				.endl
  1768
  1769 = 88DA 37 82		DISPLAY_LIST_TITLE
  1769 = 88DC 6A 82		DISPLAY_LIST_GAME
  1769 = 88DE 32 A3		HISCORE
  1769 				.endl
  1770
  1771 				; -----------------------------------------------------------
  1772
  1773 88E0				icl 'cpu6502.asm'
Source: cpu6502.asm
   290 					opt l+
   226 					opt l+
   227
   228 				/* ----------------------------------------------------------------------- */
   229
   230
   231 88E0			.proc	hiBYTE
   232 					lda :STACKORIGIN,x
   233 88E0				:4 lsr @
   234 					sta :STACKORIGIN,x
   235 					rts
   236 				.endp
   237
   238 88E0			.proc	hiWORD
   239 					lda :STACKORIGIN+STACKWIDTH,x
   240 					sta :STACKORIGIN,x
   241 					rts
   242 				.endp
   243
   244 88E0			.proc	hiCARD
   245 					lda :STACKORIGIN+STACKWIDTH*3,x
   246 					sta :STACKORIGIN+STACKWIDTH,x
   247
   248 					lda :STACKORIGIN+STACKWIDTH*2,x
   249 					sta :STACKORIGIN,x
   250 					rts
   251 				.endp
   252
   253
   254 88E0			.proc	movaBX_EAX		; mov [BX], EAX
   255 88E0				:MAXSIZE mva eax+# :STACKORIGIN-1+#*STACKWIDTH,x
   256 					rts
   257 				.endp
   258
   259 				/*
   260 				.proc	@pushBYTE
   261 					adc :STACKORIGIN+STACKWIDTH,x
   262 					sta bp+1
   263
   264 					mva (bp),y :STACKORIGIN,x
   265
   266 				;	lda #$00
   267 				;	sta :STACKORIGIN+STACKWIDTH,x
   268 				;	sta :STACKORIGIN+STACKWIDTH*2,x
   269 				;	sta :STACKORIGIN+STACKWIDTH*3,x
   270
   271 					rts
   272 				.endp
   273
   274
   275 				.proc	@pullWORD (.word ya) .reg
   276 					add :STACKORIGIN-1,x
   277 					sta bp2
   278 					tya
   279 					adc :STACKORIGIN-1+STACKWIDTH,x
   280 					sta bp2+1
   281
   282 					ldy #$00
   283
   284 					mva :STACKORIGIN,x (bp2),y
   285 					iny
   286 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   287
   288 					rts
   289 				.endp
   290
   291
   292 				.proc	@pullCARD (.word ya) .reg
   293 					add :STACKORIGIN-1,x
   294 					sta bp2
   295 					tya
   296 					adc :STACKORIGIN-1+STACKWIDTH,x
   297 					sta bp2+1
   298
   299 					ldy #$00
   300
   301 					mva :STACKORIGIN,x (bp2),y
   302 					iny
   303 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   304 					iny
   305 					mva :STACKORIGIN+STACKWIDTH*2,x (bp2),y
   306 					iny
   307 					mva :STACKORIGIN+STACKWIDTH*3,x (bp2),y
   308
   309 					rts
   310 				.endp
   311
   312
   313 				.proc	@pushWORD (.word ya) .reg
   314 					add :STACKORIGIN,x
   315 					sta bp2
   316 					tya
   317 					adc :STACKORIGIN+STACKWIDTH,x
   318 					sta bp2+1
   319
   320 					ldy #$00
   321
   322 					mva (bp2),y :STACKORIGIN,x
   323 					iny
   324 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   325
   326 					rts
   327 				.endp
   328
   329
   330 				.proc	@pushCARD (.word ya) .reg
   331 					add :STACKORIGIN,x
   332 					sta bp2
   333 					tya
   334 					adc :STACKORIGIN+STACKWIDTH,x
   335 					sta bp2+1
   336
   337 					ldy #$00
   338
   339 					mva (bp2),y :STACKORIGIN,x
   340 					iny
   341 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   342 					iny
   343 					mva (bp2),y :STACKORIGIN+STACKWIDTH*2,x
   344 					iny
   345 					mva (bp2),y :STACKORIGIN+STACKWIDTH*3,x
   346
   347 					rts
   348 				.endp
   349 				*/
   349
   350
   351 88E0			.proc	shlEAX_CL
   352
   353 				;SHORT	jsr @expandToCARD1.SHORT
   354 				;	jmp CARD
   355
   356 				;SMALL	jsr @expandToCARD1.SMALL
   357 				;	jmp CARD
   358
   359 88E0			BYTE	lda #0
   360 					sta :STACKORIGIN-1+STACKWIDTH,x
   361
   362 88E0			WORD	lda #0
   363 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   364 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   365
   366 88E0			CARD	clc
   367 					ldy :STACKORIGIN,x	; cl
   368 					beq stop
   369 88E0			@	asl :STACKORIGIN-1,x	; eax
   370 					rol :STACKORIGIN-1+STACKWIDTH,x
   371 					rol :STACKORIGIN-1+STACKWIDTH*2,x
   372 					rol :STACKORIGIN-1+STACKWIDTH*3,x
   373 					dey
   374 					bne @-
   375
   376 88E0			stop	rts
   377 				.endp
   378
   379
   380 88E0			.proc	shrAL_CL
   381
   382 				;SHORT	jsr @expandToCARD1.SHORT
   383 				;	jmp shrEAX_CL
   384
   385 88E0			BYTE	ldy :STACKORIGIN,x	; cl
   386 					beq stop
   387 88E0			@	lsr :STACKORIGIN-1,x
   388 					dey
   389 					bne @-
   390
   391 88E0			stop	lda #0
   392 					sta :STACKORIGIN-1+STACKWIDTH,x
   393 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   394 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   395
   396 					rts
   397 				.endp
   398
   399 88E0			.proc	shrAX_CL
   400
   401 				;SMALL	jsr @expandToCARD1.SMALL
   402 				;	jmp shrEAX_CL
   403
   404 88E0			WORD	ldy :STACKORIGIN,x	; cl
   405 					beq stop
   406 88E0			@	lsr :STACKORIGIN-1+STACKWIDTH,x
   407 					ror :STACKORIGIN-1,x
   408 					dey
   409 					bne @-
   410
   411 88E0			stop	lda #0
   412 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   413 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   414
   415 					rts
   416 				.endp
   417
   418 88E0			.proc	shrEAX_CL
   419
   420 					ldy :STACKORIGIN,x	; cl
   421 					beq stop
   422 88E0			@	lsr :STACKORIGIN-1+STACKWIDTH*3,x
   423 					ror :STACKORIGIN-1+STACKWIDTH*2,x
   424 					ror :STACKORIGIN-1+STACKWIDTH,x
   425 					ror :STACKORIGIN-1,x
   426 					dey
   427 					bne @-
   428
   429 88E0			stop	rts
   430 				.endp
   431
   432 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   433 				; wynik operacji ADD zostanie potraktowany jako INTEGER / CARDINAL
   434 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   435
   436 88E0			.proc	addAL_CL
   437
   438 88E0 A0 00			ldy #0
   439 88E2 98				tya
   440 88E3 9D 1F 2C			sta :STACKORIGIN-1+STACKWIDTH*2,x
   441 88E6 9D 2F 2C			sta :STACKORIGIN-1+STACKWIDTH*3,x
   442
   443 88E9 BD FF 2B			lda :STACKORIGIN-1,x
   444 88EC 18 7D 00 2C			add :STACKORIGIN,x
   445 88F0 9D FF 2B			sta :STACKORIGIN-1,x
   446 88F3 90 01			scc
   447 88F5 C8				iny
   448 88F6 98			  tya
   449 88F7 9D 0F 2C			sta :STACKORIGIN-1+STACKWIDTH,x
   450
   451 88FA 60				rts
   452 				.endp
   453
   454 88FB			.proc	addAX_CX
   455
   456 					ldy #0
   457
   458 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   459
   460 					lda :STACKORIGIN-1,x
   461 					add :STACKORIGIN,x
   462 					sta :STACKORIGIN-1,x
   463
   464 					lda :STACKORIGIN-1+STACKWIDTH,x
   465 					adc :STACKORIGIN+STACKWIDTH,x
   466 					sta :STACKORIGIN-1+STACKWIDTH,x
   467 					scc
   468 					iny
   469
   470 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   471
   472 					rts
   473 				.endp
   474
   475
   476 88FB			.proc	addEAX_ECX
   477 				/*
   478 				SHORT	jsr @expandToCARD.SHORT
   479 					jsr @expandToCARD1.SHORT
   480 					jmp CARD
   481
   482 				SMALL	jsr @expandToCARD.SMALL
   483 					jsr @expandToCARD1.SMALL
   484 				*/
   484
   485 88FB			CARD	lda :STACKORIGIN-1,x
   486 					add :STACKORIGIN,x
   487 					sta :STACKORIGIN-1,x
   488
   489 					lda :STACKORIGIN-1+STACKWIDTH,x
   490 					adc :STACKORIGIN+STACKWIDTH,x
   491 					sta :STACKORIGIN-1+STACKWIDTH,x
   492
   493 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   494 					adc :STACKORIGIN+STACKWIDTH*2,x
   495 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   496
   497 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   498 					adc :STACKORIGIN+STACKWIDTH*3,x
   499 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   500
   501 					rts
   502 				.endp
   503
   504
   505 88FB			.proc	subAL_CL
   506
   507 					ldy #0
   508
   509 					lda :STACKORIGIN-1,x
   510 					sub :STACKORIGIN,x
   511 					sta :STACKORIGIN-1,x
   512 					scs
   513 					dey
   514
   515 					sty :STACKORIGIN-1+STACKWIDTH,x
   516 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   517 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   518
   519 					rts
   520 				.endp
   521
   522 88FB			.proc	subAX_CX
   523
   524 					ldy #0
   525
   526 					lda :STACKORIGIN-1,x		; ax
   527 					sub :STACKORIGIN,x		; cx
   528 					sta :STACKORIGIN-1,x
   529
   530 					lda :STACKORIGIN-1+STACKWIDTH,x
   531 					sbc :STACKORIGIN+STACKWIDTH,x
   532 					sta :STACKORIGIN-1+STACKWIDTH,x
   533 					scs
   534 					dey
   535
   536 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   537 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   538
   539 					rts
   540 				.endp
   541
   542 88FB			.proc	subEAX_ECX
   543
   544 					lda :STACKORIGIN-1,x
   545 					sub :STACKORIGIN,x
   546 					sta :STACKORIGIN-1,x
   547
   548 					lda :STACKORIGIN-1+STACKWIDTH,x
   549 					sbc :STACKORIGIN+STACKWIDTH,x
   550 					sta :STACKORIGIN-1+STACKWIDTH,x
   551
   552 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   553 					sbc :STACKORIGIN+STACKWIDTH*2,x
   554 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   555
   556 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   557 					sbc :STACKORIGIN+STACKWIDTH*3,x
   558 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   559
   560 					rts
   561 				.endp
   562
   563
   564 88FB			.proc	@expandSHORT2SMALL
   565 					ldy #$00
   566 					lda :STACKORIGIN,x
   567 					spl
   568 					dey
   569 					sty :STACKORIGIN+STACKWIDTH,x
   570
   571 					rts
   572 				.endp
   573
   574 88FB			.proc	@expandSHORT2SMALL1
   575 					ldy #$00
   576 					lda :STACKORIGIN-1,x
   577 					spl
   578 					dey
   579 					sty :STACKORIGIN-1+STACKWIDTH,x
   580
   581 					rts
   582 				.endp
   583
   584
   585 88FB			.proc	@expandToCARD
   586
   587 88FB BD 10 2C		SMALL	lda :STACKORIGIN+STACKWIDTH,x
   588 88FE 10 04			bpl WORD
   589
   590 8900 A9 FF			lda #$ff
   591 8902 D0 12			bne _wo
   592
   593 8904 A9 00		WORD	lda #$00
   594 8906 F0 0E			beq _wo
   595
   596 8908 BD 00 2C		SHORT	lda :STACKORIGIN,x
   597 890B 10 04			bpl BYTE
   598
   599 890D A9 FF			lda #$ff
   600 890F D0 02			bne _by
   601
   602 8911 A9 00		BYTE	lda #$00
   603
   604 8913 9D 10 2C		_by	sta :STACKORIGIN+STACKWIDTH,x
   605 8916 9D 20 2C		_wo	sta :STACKORIGIN+STACKWIDTH*2,x
   606 8919 9D 30 2C		_lo	sta :STACKORIGIN+STACKWIDTH*3,x
   607 891C 60				rts
   608 				.endp
   609
   610
   611 891D			.proc	@expandToCARD1
   612
   613 891D			SMALL	lda :STACKORIGIN-1+STACKWIDTH,x
   614 					bpl WORD
   615
   616 					lda #$ff
   617 					bne _wo
   618
   619 891D			WORD	lda #$00
   620 					beq _wo
   621
   622 891D			SHORT	lda :STACKORIGIN-1,x
   623 					bpl BYTE
   624
   625 					lda #$ff
   626 					bne _by
   627
   628 891D			BYTE	lda #$00
   629
   630 891D			_by	sta :STACKORIGIN-1+STACKWIDTH,x
   631 891D			_wo	sta :STACKORIGIN-1+STACKWIDTH*2,x
   632 891D			_lo	sta :STACKORIGIN-1+STACKWIDTH*3,x
   633 					rts
   634 				.endp
   635
   636 				/*
   637 				.proc	@cmpFor_WORD (.word ya) .reg
   638 					sta ztmp
   639 					sty ztmp+1
   640
   641 					ldy #1
   642 					lda (ztmp),y
   643 					cmp :STACKORIGIN+1+STACKWIDTH,x
   644 					bne stop
   645 					dey
   646 					lda (ztmp),y
   647 					cmp :STACKORIGIN+1,x
   648 				stop	rts
   649 				.endp
   650
   651
   652 				.proc	@cmpFor_CARD (.word ya) .reg
   653 					sta ztmp
   654 					sty ztmp+1
   655
   656 					ldy #3
   657 					lda (ztmp),y
   658 					cmp :STACKORIGIN+1+STACKWIDTH*3,x
   659 					bne stop
   660 					dey
   661 					lda (ztmp),y
   662 					cmp :STACKORIGIN+1+STACKWIDTH*2,x
   663 					bne stop
   664 					dey
   665 					lda (ztmp),y
   666 					cmp :STACKORIGIN+1+STACKWIDTH,x
   667 					bne stop
   668 					dey
   669 					lda (ztmp),y
   670 					cmp :STACKORIGIN+1,x
   671
   672 				stop	rts
   673 				.endp
   674
   675
   676 				.proc	@cmpFor_SHORTINT(.word ya) .reg
   677 					sta ztmp
   678 					sty ztmp+1
   679
   680 					ldy	#0
   681 					lda	(ztmp),y
   682 					sec
   683 					sbc	:STACKORIGIN+1,x
   684 					bne	@cmpFor_INT.L4
   685
   686 					jmp	@cmpFor_INT.L1
   687 				.endp
   688
   689
   690 				.proc	@cmpFor_SMALLINT(.word ya) .reg
   691 					sta ztmp
   692 					sty ztmp+1
   693
   694 					ldy	#1
   695 					lda	(ztmp),y
   696 					sec
   697 					sbc	:STACKORIGIN+1+STACKWIDTH,x
   698 					bne	@cmpFor_INT.L4
   699
   700 					dey
   701 					lda	(ztmp),y
   702 					cmp	:STACKORIGIN+1,x
   703
   704 					jmp	@cmpFor_INT.L1
   705 				.endp
   706
   707
   708 				.proc	@cmpFor_INT(.word ya) .reg
   709 					sta ztmp
   710 					sty ztmp+1
   711
   712 					ldy	#3
   713 					lda	(ztmp),y
   714 					sec
   715 					sbc	:STACKORIGIN+1+STACKWIDTH*3,x
   716 					bne	L4
   717
   718 					dey
   719 					lda	(ztmp),y
   720 					cmp	:STACKORIGIN+1+STACKWIDTH*2,x
   721 					bne	L1
   722
   723 					dey
   724 					lda	(ztmp),y
   725 					cmp	:STACKORIGIN+1+STACKWIDTH,x
   726 					bne	L1
   727
   728 					dey
   729 					lda	(ztmp),y
   730 					cmp	:STACKORIGIN+1,x
   731
   732 				L1	beq	L2
   733 					bcs	L3
   734
   735 					lda	#$FF	; Set the N flag
   736 				L2	rts
   737
   738 				L3	lda	#$01	; Clear the N flag
   739 					rts
   740
   741 				L4	bvc	L5
   742 					eor	#$FF	; Fix the N flag if overflow
   743 					ora	#$01	; Clear the Z flag
   744 				L5	rts
   745 				.endp
   746 				*/
   746
   747
   748 				; Piotr Fusik, 15.04.2002
   749 				; originally by Ullrich von Bassewitz
   750
   751 891D			.proc	cmpSHORTINT
   752 					lda	:STACKORIGIN-1,x
   753 					clv:sec
   754 					sbc	:STACKORIGIN,x
   755 					bne	cmpINT.L4
   756
   757 					jmp	cmpINT.L1
   758 				.endp
   759
   760
   761 891D			.proc	cmpSMALLINT
   762 					lda	:STACKORIGIN-1+STACKWIDTH,x
   763 					clv:sec
   764 					sbc	:STACKORIGIN+STACKWIDTH,x
   765 					bne	cmpINT.L4
   766
   767 					lda	:STACKORIGIN-1,x
   768 					cmp	:STACKORIGIN,x
   769
   770 					jmp	cmpINT.L1
   771 				.endp
   772
   773
   774 891D			.proc	cmpINT
   775 					lda	:STACKORIGIN-1+STACKWIDTH*3,x
   776 					clv:sec
   777 					sbc	:STACKORIGIN+STACKWIDTH*3,x
   778 					bne	L4
   779
   780 					lda	:STACKORIGIN-1+STACKWIDTH*2,x
   781 					cmp	:STACKORIGIN+STACKWIDTH*2,x
   782 					bne	L1
   783
   784 					lda	:STACKORIGIN-1+STACKWIDTH,x
   785 					cmp	:STACKORIGIN+STACKWIDTH,x
   786 					bne	L1
   787
   788 					lda	:STACKORIGIN-1,x
   789 					cmp	:STACKORIGIN,x
   790
   791 891D			L1	beq	L2
   792 					bcs	L3
   793
   794 					lda	#$FF	; Set the N flag
   795 891D			L2	rts
   796
   797 891D			L3	lda	#$01	; Clear the N flag
   798 					rts
   799
   800 891D			L4	bvc	L5
   801 					eor	#$FF	; Fix the N flag if overflow
   802 					ora	#$01	; Clear the Z flag
   803 891D			L5	rts
   804 				.endp
   805
   806
   807 891D			.proc	cmpEAX_ECX
   808 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   809 					cmp :STACKORIGIN+STACKWIDTH*3,x
   810 					bne _done
   811 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   812 					cmp :STACKORIGIN+STACKWIDTH*2,x
   813 					bne _done
   814 891D			AX_CX
   815 					lda :STACKORIGIN-1+STACKWIDTH,x
   816 					cmp :STACKORIGIN+STACKWIDTH,x
   817 					bne _done
   818 					lda :STACKORIGIN-1,x
   819 					cmp :STACKORIGIN,x
   820
   821 891D			_done	rts
   822 				.endp
   823
   824
   825 891D			.proc	cmpSTRING2CHAR
   826
   827 					lda :STACKORIGIN-1,x
   828 					sta ztmp8
   829 					lda :STACKORIGIN-1+STACKWIDTH,x
   830 					sta ztmp8+1
   831
   832 					lda :STACKORIGIN,x
   833 					sta ztmp10
   834
   835 					ldy #0
   836
   837 					lda (ztmp8),y		; if length <> 1
   838 					cmp #1
   839 					bne fail
   840
   841 					iny
   842
   843 891D			loop	lda (ztmp8),y
   844 					cmp ztmp10
   845 					bne fail
   846
   847 					lda #0
   848 					seq
   849
   850 891D			fail	lda #$ff
   851
   852 					ldy #1
   853
   854 					cmp #0
   855 					rts
   856 				.endp
   857
   858
   859
   860 891D			.proc	cmpCHAR2STRING
   861
   862 					lda :STACKORIGIN-1,x
   863 					sta ztmp8
   864
   865 					lda :STACKORIGIN,x
   866 					sta ztmp10
   867 					lda :STACKORIGIN+STACKWIDTH,x
   868 					sta ztmp10+1
   869
   870 					ldy #0
   871
   872 					lda (ztmp10),y		; if length <> 1
   873 					cmp #1
   874 					bne fail
   875
   876 					iny
   877
   878 891D			loop	lda (ztmp10),y
   879 					cmp ztmp8
   880 					bne fail
   881
   882 					lda #0
   883 					seq
   884
   885 891D			fail	lda #$ff
   886
   887 					ldy #1
   888
   889 					cmp #0
   890 					rts
   891 				.endp
   892
   893
   894 891D			.proc	cmpSTRING
   895
   896 					lda :STACKORIGIN-1,x
   897 					sta ztmp8
   898 					lda :STACKORIGIN-1+STACKWIDTH,x
   899 					sta ztmp8+1
   900
   901 					lda :STACKORIGIN,x
   902 					sta ztmp10
   903 					lda :STACKORIGIN+STACKWIDTH,x
   904 					sta ztmp10+1
   905
   906 					ldy #0
   907
   908 					lda (ztmp8),y		; if length1 = 0
   909 					beq fail
   910 					lda (ztmp10),y		; if length2 = 0
   911 					beq fail
   912
   913 					lda (ztmp8),y		; if length1 <> length2
   914 					cmp (ztmp10),y
   915 					bne fail
   916
   917 					sta max
   918
   919 					inw ztmp8
   920 					inw ztmp10
   921
   922 891D			loop	lda (ztmp8),y
   923 					cmp (ztmp10),y
   924 					bne fail
   925
   926 					iny
   927
   928 					cpy #0
   929 891D			max	equ *-1
   930 					bne loop
   931
   932 					lda #0
   933 					seq
   934
   935 891D			fail	lda #$ff
   936
   937 					ldy #1
   938
   939 					cmp #0
   940 					rts
   941 				.endp
   942
   943
   944 891D			.proc	notaBX
   945
   946 					.rept MAXSIZE
   947 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   949 					STA :STACKORIGIN+#*STACKWIDTH,X
   950 					.ENDR
   950 					.endr
Source: REPT
   947 					LDA :STACKORIGIN+#*STACKWIDTH,X
   947 					EOR #$FF
   947 					STA :STACKORIGIN+#*STACKWIDTH,X
   947 					LDA :STACKORIGIN+#*STACKWIDTH,X
   947 					EOR #$FF
   947 					STA :STACKORIGIN+#*STACKWIDTH,X
   947 					LDA :STACKORIGIN+#*STACKWIDTH,X
   947 					EOR #$FF
   947 					STA :STACKORIGIN+#*STACKWIDTH,X
   947 					LDA :STACKORIGIN+#*STACKWIDTH,X
   947 					EOR #$FF
   947 					STA :STACKORIGIN+#*STACKWIDTH,X
Source: cpu6502.asm
   951
   952 					rts
   953 				.endp
   954
   955
   956 891D			.proc	notBOOLEAN
   957 					lda :STACKORIGIN,x
   958 					bne _0
   959
   960 					lda #true
   961 					sne
   962
   963 891D			_0	lda #false
   964 					sta :STACKORIGIN,x
   965
   966 					rts
   967 				.endp
   968
   969
   970 891D			.proc	negBYTE
   971 					lda #$00
   972 					sub :STACKORIGIN,x
   973 					sta :STACKORIGIN,x
   974
   975 					lda #$00
   976 					sbc #$00
   977 					sta :STACKORIGIN+STACKWIDTH,x
   978
   979 					lda #$00
   980 					sbc #$00
   981 					sta :STACKORIGIN+STACKWIDTH*2,x
   982
   983 					lda #$00
   984 					sbc #$00
   985 					sta :STACKORIGIN+STACKWIDTH*3,x
   986
   987 					rts
   988 				.endp
   989
   990 891D			.proc	negWORD
   991 					lda #$00
   992 					sub :STACKORIGIN,x
   993 					sta :STACKORIGIN,x
   994
   995 					lda #$00
   996 					sbc :STACKORIGIN+STACKWIDTH,x
   997 					sta :STACKORIGIN+STACKWIDTH,x
   998
   999 					lda #$00
  1000 					sbc #$00
  1001 					sta :STACKORIGIN+STACKWIDTH*2,x
  1002
  1003 					lda #$00
  1004 					sbc #$00
  1005 					sta :STACKORIGIN+STACKWIDTH*3,x
  1006
  1007 					rts
  1008 				.endp
  1009
  1010 891D			.proc	negCARD
  1011 891D A9 00			lda #$00
  1012 891F 38 FD 00 2C			sub :STACKORIGIN,x
  1013 8923 9D 00 2C			sta :STACKORIGIN,x
  1014
  1015 8926 A9 00			lda #$00
  1016 8928 FD 10 2C			sbc :STACKORIGIN+STACKWIDTH,x
  1017 892B 9D 10 2C			sta :STACKORIGIN+STACKWIDTH,x
  1018
  1019 892E A9 00			lda #$00
  1020 8930 FD 20 2C			sbc :STACKORIGIN+STACKWIDTH*2,x
  1021 8933 9D 20 2C			sta :STACKORIGIN+STACKWIDTH*2,x
  1022
  1023 8936 A9 00			lda #$00
  1024 8938 FD 30 2C			sbc :STACKORIGIN+STACKWIDTH*3,x
  1025 893B 9D 30 2C			sta :STACKORIGIN+STACKWIDTH*3,x
  1026
  1027 893E 60				rts
  1028 				.endp
  1029
  1030
  1031 893F			.proc	negBYTE1
  1032 					lda #$00
  1033 					sub :STACKORIGIN-1,x
  1034 					sta :STACKORIGIN-1,x
  1035
  1036 					lda #$00
  1037 					sbc #$00
  1038 					sta :STACKORIGIN-1+STACKWIDTH,x
  1039
  1040 					lda #$00
  1041 					sbc #$00
  1042 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1043
  1044 					lda #$00
  1045 					sbc #$00
  1046 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1047
  1048 					rts
  1049 				.endp
  1050
  1051 893F			.proc	negWORD1
  1052 					lda #$00
  1053 					sub :STACKORIGIN-1,x
  1054 					sta :STACKORIGIN-1,x
  1055
  1056 					lda #$00
  1057 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1058 					sta :STACKORIGIN-1+STACKWIDTH,x
  1059
  1060 					lda #$00
  1061 					sbc #$00
  1062 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1063
  1064 					lda #$00
  1065 					sbc #$00
  1066 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1067
  1068 					rts
  1069 				.endp
  1070
  1071 893F			.proc	negCARD1
  1072 					lda #$00
  1073 					sub :STACKORIGIN-1,x
  1074 					sta :STACKORIGIN-1,x
  1075
  1076 					lda #$00
  1077 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1078 					sta :STACKORIGIN-1+STACKWIDTH,x
  1079
  1080 					lda #$00
  1081 					sbc :STACKORIGIN-1+STACKWIDTH*2,x
  1082 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1083
  1084 					lda #$00
  1085 					sbc :STACKORIGIN-1+STACKWIDTH*3,x
  1086 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1087
  1088 					rts
  1089 				.endp
  1090
  1091
  1092 893F			.proc	andAL_CL
  1093
  1094 					lda :STACKORIGIN-1,x
  1095 					and :STACKORIGIN,x
  1096 					sta :STACKORIGIN-1,x
  1097
  1098 					rts
  1099 				.endp
  1100
  1101 893F			.proc	andAX_CX
  1102
  1103 					.rept 2
  1104 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					AND :STACKORIGIN+#*STACKWIDTH,X
  1106 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1107 					.ENDR
  1107 					.endr
Source: REPT
  1104 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1104 					AND :STACKORIGIN+#*STACKWIDTH,X
  1104 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1104 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1104 					AND :STACKORIGIN+#*STACKWIDTH,X
  1104 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1108
  1109 					rts
  1110 				.endp
  1111
  1112 893F			.proc	andEAX_ECX
  1113
  1114 					.rept MAXSIZE
  1115 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1117 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1118 					.ENDR
  1118 					.endr
Source: REPT
  1115 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1115 					AND :STACKORIGIN+#*STACKWIDTH,X
  1115 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1115 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1115 					AND :STACKORIGIN+#*STACKWIDTH,X
  1115 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1115 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1115 					AND :STACKORIGIN+#*STACKWIDTH,X
  1115 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1115 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1115 					AND :STACKORIGIN+#*STACKWIDTH,X
  1115 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1119
  1120 					rts
  1121 				.endp
  1122
  1123
  1124 893F			.proc	orAL_CL
  1125
  1126 					lda :STACKORIGIN-1,x
  1127 					ora :STACKORIGIN,x
  1128 					sta :STACKORIGIN-1,x
  1129
  1130 					rts
  1131 				.endp
  1132
  1133 893F			.proc	orAX_CX
  1134
  1135 					.rept 2
  1136 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1138 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1139 					.ENDR
  1139 					.endr
Source: REPT
  1136 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1136 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1136 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1136 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1136 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1136 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1140
  1141 					rts
  1142 				.endp
  1143
  1144 893F			.proc	orEAX_ECX
  1145
  1146 					.rept MAXSIZE
  1147 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1149 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1150 					.ENDR
  1150 					.endr
Source: REPT
  1147 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1147 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1147 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1147 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1147 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1147 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1147 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1147 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1147 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1147 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1147 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1147 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1151
  1152 					rts
  1153 				.endp
  1154
  1155
  1156 893F			.proc	xorAL_CL
  1157
  1158 					lda :STACKORIGIN-1,x
  1159 					eor :STACKORIGIN,x
  1160 					sta :STACKORIGIN-1,x
  1161
  1162 					rts
  1163 				.endp
  1164
  1165 893F			.proc	xorAX_CX
  1166
  1167 					.rept 2
  1168 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1170 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1171 					.ENDR
  1171 					.endr
Source: REPT
  1168 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1168 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1168 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1168 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1168 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1168 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1172
  1173 					rts
  1174 				.endp
  1175
  1176 893F			.proc	xorEAX_ECX
  1177
  1178 					.rept MAXSIZE
  1179 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1181 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1182 					.ENDR
  1182 					.endr
Source: REPT
  1179 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1179 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1179 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1179 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1179 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1179 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1179 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1179 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1179 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1179 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1179 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1179 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1183
  1184 					rts
  1185 				.endp
  1186
  1187
  1188 				/*
  1189 				.proc	iniEAX_ECX_BYTE
  1190
  1191 					mva :STACKORIGIN,x ecx
  1192 					mva :STACKORIGIN-1,x eax
  1193
  1194 					rts
  1195 				.endp
  1196 				*/
  1196
  1197
  1198
  1199 893F			.proc	iniEAX_ECX_WORD
  1200
  1201 					mva :STACKORIGIN,x ecx
  1202 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1203
  1204 					mva :STACKORIGIN-1,x eax
  1205 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1206
  1207 					mva #$00 ecx+2
  1208 					sta ecx+3
  1209
  1210 					sta eax+2
  1211 					sta eax+3
  1212
  1213 					rts
  1214 				.endp
  1215
  1216
  1217 893F			.proc	iniEAX_ECX_CARD
  1218 					mva :STACKORIGIN,x ecx
  1219 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1220 					mva :STACKORIGIN+STACKWIDTH*2,x ecx+2
  1221 					mva :STACKORIGIN+STACKWIDTH*3,x ecx+3
  1222
  1223 					mva :STACKORIGIN-1,x eax
  1224 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1225 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
  1226 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
  1227
  1228 					rts
  1229 				.endp
  1230
  1231 893F			.proc	movZTMP_aBX
  1232 					mva ZTMP8 :STACKORIGIN-1,x
  1233 					mva ZTMP9 :STACKORIGIN-1+STACKWIDTH,x
  1234 					mva ZTMP10 :STACKORIGIN-1+STACKWIDTH*2,x
  1235 					mva ZTMP11 :STACKORIGIN-1+STACKWIDTH*3,x
  1236
  1237 					rts
  1238 				.endp
  1239
  1240
  1241 893F				icl '6502\cpu6502_sio.asm'
Source: cpu6502_sio.asm
     1
     2 893F			.proc	@sio
     3
     4 					stx dbufa		;< adres bufora
     5 					sty dbufa+1		;> adres bufora
     6 					sta dcmnd		; 'R' read sector / 'P' write sector
     7
     8 					ldy dunit
     9 					lda lsector-1,y
    10 					sta dsctln		; < dlugosc sektora
    11 				;	sta dbyt		;< dlugosc bufora
    12
    13 					lda hsector-1,y
    14 					sta dsctln+1		; > dlugosc sektora 
    15 				;	sta dbyt+1		;> dlugosc bufora
    16
    17 					lda #$c0		; $40 read / $80 write
    18 					sta dstats
    19
    20 					lda #0
    21 					sta casflg		; = 00 to indicate that it isn't a cassette operation
    22
    23 					jmp jdskint
    24
    25 				// A = [1..8]
    26 893F			devnrm	tax
    27
    28 					CLC			; clear carry for add
    29 					ADC #$FF-8		; make m = $FF
    30 					ADC #8-1+1		; carry set if in range n to m
    31 					bcs ok
    32
    33 					ldy #-123		; kod bledu "DEVICE OR FILE NOT OPEN"
    34 					rts
    35 					
    36 893F			ok	txa
    37 					sta dunit		; nr stacji
    38 					ora #$30
    39 					sta ddevic		; nr stacji + $30
    40
    41 					lda #7
    42 					sta dtimlo		; timeout
    43
    44 					ldy #0
    45 					rts
    46
    47 893F			devsec	tya			; zapisz rozmiar sektora
    48 					ldy dunit
    49 					sta hsector-1,y
    50 					txa
    51 					sta lsector-1,y
    52 					rts
    53
    54 893F			lsector	:8 dta l(256)
    55 893F			hsector	:8 dta h(256)
    56
    57 				.endp
  1242 893F				icl '6502\cpu6502_cio.asm'
Source: cpu6502_cio.asm
     1
     2 				/*
     3 					Reset(f, record)
     4 					Rewrite(f, record)
     5
     6 					C = 1	SEC	IOCHECK TRUE
     7 					C = 0	CLC	IOCHECK FALSE
     8 				*/
     8
     9
    10 893F			.proc	@openfile (.word ya .byte x) .reg
    11
    12 					sta bp2
    13 					sty bp2+1
    14
    15 					stx code
    16
    17 					lda #0
    18 					rol @
    19 					sta iocheck
    20
    21 					ldy #s@file.status
    22 					lda (bp2),y
    23 					and #e@file.eof^$ff
    24 					sta (bp2),y
    25
    26 					ldy #s@file.pfname
    27 					lda (bp2),y
    28 					add #1
    29 					sta lfname
    30 					iny
    31 					lda (bp2),y
    32 					adc #0
    33 					sta hfname
    34
    35 					jsr lookup
    36 					bmi error
    37
    38 					ldy #s@file.chanel
    39 					txa
    40 					sta (bp2),y		;CHANNEL
    41
    42 				; -----------------------------------------
    43
    44 					lda #$03		;komenda: OPEN
    45 					sta iccmd,x
    46 					lda #$00		;adres nazwy pliku
    47 893F			lfname	equ *-1
    48 					sta icbufa,x
    49 					lda #$00
    50 893F			hfname	equ *-1
    51 					sta icbufa+1,x
    52 					lda #$00		;kod dostepu: $04 odczyt, $08 zapis, $09 dopisywanie, $0c odczyt/zapis, $0d odczyt/dopisywanie
    53 893F			code	equ *-1
    54 					sta icax1,x
    55 					lda #$00		;dodatkowy parametr, $00 jest zawsze dobre
    56 					sta icax2,x
    57 					jsr ciov
    58
    59 893F			error	sty MAIN.SYSTEM.IOResult
    60
    61 					bpl ok
    62
    63 893F			msg	lda #true
    64 893F			iocheck	equ *-1
    65 					beq skp
    66
    67 					sty dx
    68 				;	sty FX_CORE_RESET
    69
    70 					@clrscr
    71
    72 					lda <_error
    73 					ldy >_error
    74 					jsr @printSTRING
    75
    76 					lda #$00
    77 					sta dx+1
    78 					sta dx+2
    79 					sta dx+3
    80
    81 					jsr @printVALUE
    82
    83 					jmp MAIN.@halt
    84
    85 893F			skp	ldy #s@file.status
    86 					lda (bp2),y
    87 					ora #e@file.eof
    88 					sta (bp2),y
    89
    90 					ldy #s@file.record
    91 					lda #$00
    92 					sta (bp2),y
    93 					iny
    94 					sta (bp2),y
    95
    96 					rts
    97
    98 893F			ok	ldy #s@file.status
    99 					lda (bp2),y
   100 					ora #e@file.open
   101 					sta (bp2),y
   102
   103 					rts
   104
   105 893F			_error	dta 6,c'ERROR '
   106
   107 				; -----------------------------------------
   108
   109 893F			lookup	ldx #$00
   110 					ldy #$01
   111 893F			loop	lda icchid,x
   112 					cmp #$ff
   113 					beq found
   114 					txa
   115 					clc
   116 					adc #$10
   117 					tax
   118 					bpl loop
   119 					ldy #-95       		; kod bledu "TOO MANY CHANNELS OPEN"
   120 893F			found	rts
   121 				.endp
   122
   123
   124 				/*
   125 					Close(f)
   126
   127 					C = 1	SEC	IOCHECK TRUE
   128 					C = 0	CLC	IOCHECK FALSE
   129 				*/
   129
   130
   131 893F			.proc	@closefile (.word ya) .reg
   132 					sta	bp2
   133 					sty	bp2+1
   134
   135 					ldy	#s@file.status
   136
   137 					lda	#0
   138 					rol	@
   139 					sta	@openfile.iocheck
   140 				;	beq	ok_open
   141
   142 					lda	(bp2),y
   143 					and 	#e@file.open
   144 					bne	ok_open
   145
   146 					ldy	#-123		; kod bledu "DEVICE OR FILE NOT OPEN"
   147 					jmp	@openfile.error
   148
   149 893F			ok_open	lda	(bp2),y
   150 					ora	#e@file.eof
   151 					sta	(bp2),y
   152
   153 					ldy	#s@file.chanel
   154 					lda	(bp2),y
   155 					tax
   156
   157 					lda	#$0c		;komenda: CLOSE
   158 					sta	iccmd,x
   159 					jsr	ciov
   160
   161 				;	lda	#0		; iocheck off
   162 				;	sta	@openfile.iocheck
   163
   164 					jmp	@openfile.error
   165
   166 				.endp
   167
   168
   169 				/*
   170 					BlockRead(f, buf, num_records, numread)
   171 					BlockWrite(f, buf, num_records, numwrite)
   172
   173 					C = 1	SEC	IOCHECK TRUE
   174 					C = 0	CLC	IOCHECK FALSE
   175 				*/
   175
   176
   177 893F			.proc	@readfile (.word ya .byte x) .reg
   178
   179 					sta	bp2
   180 					sty	bp2+1
   181
   182 					stx	code
   183
   184 					lda	#$00
   185 					sta	eax+2
   186 					sta	eax+3
   187 					sta	ecx+2
   188 					sta	ecx+3
   189
   190 					sta	MAIN.SYSTEM.IOResult
   191
   192 					rol	@
   193 					sta	@openfile.iocheck
   194
   195 					ldy	#s@file.status
   196 					lda	(bp2),y
   197 					and	#e@file.open
   198 					bne	ok_open
   199
   200 					ldy	#-123			; kod bledu "DEVICE OR FILE NOT OPEN"
   201 					jmp	@openfile.error
   202
   203 893F			ok_open	ldy	#s@file.record
   204 					mwa	(bp2),y	ecx
   205
   206 					ldy	#s@file.nrecord
   207 					mwa	(bp2),y	eax
   208
   209 				;	lda	#0
   210 					jsr	imulCX			; record * nrecord = file length to load
   211
   212 					cpw	eax #0
   213 					beq	nothing
   214
   215 					ldy	#s@file.chanel
   216 					lda	(bp2),y
   217 					tax
   218
   219 					mwa	eax	icbufl,x
   220
   221 					ldy	#s@file.buffer
   222 					mwa	(bp2),y	icbufa,x
   223
   224 					lda	#$00
   225 893F			code	equ *-1
   226 					and	#$7f
   227 					sta	iccmd,x
   228
   229 					jsr	ciov
   230
   231 					sty	MAIN.SYSTEM.IOResult
   232
   233 					bpl ok
   234
   235 					cpy #136
   236 					beq done
   237
   238 					jsr eof
   239
   240 					lda #$00
   241 					sta eax
   242 					sta eax+1
   243
   244 					jmp	@openfile.msg
   245
   246 893F			done	jsr eof
   247
   248 893F			ok	mwa icbufl,x	eax
   249 					ldy #s@file.record
   250 					mwa (bp2),y	ecx
   251
   252 					lda #$00
   253 					jsr idivAX_CX.main
   254
   255 893F			nothing	lda code
   256 					bpl quit			; blockread(f, buf, len)   short version
   257
   258 					ldy #s@file.numread
   259 					mwa (bp2),y ztmp
   260
   261 					ldy #0
   262 					mwa eax (ztmp),y		; length of loaded data / record = number of records
   263
   264 893F			quit	rts
   265
   266 893F			eof	ldy #s@file.status
   267 					lda (bp2),y
   268 					ora #e@file.eof
   269 					sta (bp2),y
   270
   271 					rts
   272 				.endp
   273
   274
   275 893F			.proc	@ReadDirFileName (.word ya) .reg
   276
   277 					ldx #5
   278 					clc		; iocheck off
   279 					jsr @readfile	; (ya, x)
   280
   281 					ldy eax
   282
   283 					lda MAIN.SYSTEM.IOResult
   284 					smi
   285 					lda #0		; ok
   286
   287 					rts
   288 				.endp
   289
   290
   291 893F			.proc	@DirFileName
   292
   293 					lda #0
   294 					sta attr
   295
   296 					cpy #$12
   297 					bne stop
   298
   299 					lda @buf
   300 					cmp #'*'
   301 					bne skp
   302
   303 					lda #MAIN.SYSUTILS.faReadOnly
   304 					sta attr
   305
   306 893F			skp	ldy #1
   307 					ldx #2
   308 					lda #10
   309 					jsr cpName
   310
   311 					ldx #10
   312 					lda @buf,x
   313 					pha
   314 					bpl files
   315
   316 					lda attr
   317 					ora #MAIN.SYSUTILS.faDirectory
   318 					sta attr
   319
   320 					jmp skp2
   321
   322 893F			files	lda attr
   323 					ora #MAIN.SYSUTILS.faArchive
   324 					sta attr
   325
   326 893F			skp2	pla
   327 					beq stp2
   328
   329 					lda #'.'
   330 					sta (bp2),y
   331 					iny
   332
   333 					lda #13
   334 					jsr cpName
   335 893F			stp2
   336 					dey
   337 					tya
   338 893F			stop	ldy #0
   339 					sta (bp2),y
   340
   341 					ldx #0
   342 893F			attr	equ *-1
   343 					rts
   344
   345 893F			cpName	sta ln
   346 893F			cp	lda @buf,x
   347 					cmp #' '
   348 					beq stp
   349 					sta (bp2),y
   350 					iny
   351 					inx
   352 					cpx #0
   353 893F			ln	equ *-1
   354 					bne cp
   355 893F			stp	rts
   356 				.endp
   357
  1243
  1244 893F				icl '6502\cpu6502_shortint.asm'		; mul / div -> SHORTINT
Source: cpu6502_shortint.asm
     1
     2 				/*
     3 					mulSHORTINT
     4 					divmulSHORTINT
     5 				*/
     5
     6
     7
     8 893F			.proc	mulSHORTINT
     9
    10 					jsr imulBYTE
    11
    12 					lda :STACKORIGIN-1,x
    13 					bpl @+
    14 						sec
    15 						lda eax+1
    16 						sbc :STACKORIGIN,x
    17 						sta eax+1
    18 893F			@
    19 					lda :STACKORIGIN,x
    20 					bpl @+
    21 						sec
    22 						lda eax+1
    23 						sbc :STACKORIGIN-1,x
    24 						sta eax+1
    25 893F			@
    26 					jmp movaBX_EAX
    27 				.endp
    28
    29
    30 893F			.proc	divmulSHORTINT
    31
    32 893F			MOD	mva #{jsr} _mod
    33
    34 					lda :STACKORIGIN,x		; divisor sign
    35 					spl
    36 					jsr negBYTE
    37
    38 893F			DIV	ldy <idivBYTE
    39 					lda >idivBYTE
    40
    41 893F			skp	sty addr
    42 					sta addr+1
    43
    44 					ldy #0
    45
    46 					lda :STACKORIGIN-1,x		; dividend sign
    47 					bpl @+
    48 					jsr negBYTE1
    49 					iny
    50
    51 893F			@	lda :STACKORIGIN,x		; divisor sign
    52 					bpl @+
    53 					jsr negBYTE
    54 					iny
    55
    56 893F			@	tya
    57 					and #1
    58 					pha
    59
    60 					jsr $ffff			; idiv ecx
    61 893F			addr	equ *-2
    62
    63 					jsr movaBX_EAX
    64
    65 893F			_mod	bit movZTMP_aBX			; mod
    66 					mva #{bit} _mod
    67
    68 					pla
    69 					seq
    70 					jmp negCARD1
    71
    72 					rts
    73 				.endp
  1245 893F				icl '6502\cpu6502_smallint.asm'		; mul / div -> SMALLINT
Source: cpu6502_smallint.asm
     1
     2 				/*
     3 					mulSMALLINT
     4 					divmulSMALLINT
     5 				*/
     5
     6
     7
     8 893F			.proc	mulSMALLINT
     9
    10 					jsr imulWORD
    11
    12 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    13 					bpl @+
    14 						sec
    15 						lda eax+2
    16 						sbc :STACKORIGIN,x
    17 						sta eax+2
    18 						lda eax+3
    19 						sbc :STACKORIGIN+STACKWIDTH,x
    20 						sta eax+3
    21 893F			@
    22 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    23 					bpl @+
    24 						sec
    25 						lda eax+2
    26 						sbc :STACKORIGIN-1,x
    27 						sta eax+2
    28 						lda eax+3
    29 						sbc :STACKORIGIN-1+STACKWIDTH,x
    30 						sta eax+3
    31 893F			@
    32 					jmp movaBX_EAX
    33 				.endp
    34
    35
    36 893F			.proc	divmulSMALLINT
    37
    38 893F			SHORTREAL
    39 					ldy <divSHORTREAL
    40 					lda >divSHORTREAL
    41 					bne skp
    42
    43 893F			MOD	mva #{jsr} _mod
    44
    45 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    46 					spl
    47 					jsr negWORD
    48
    49 893F			DIV	ldy <idivWORD
    50 					lda >idivWORD
    51
    52 893F			skp	sty addr
    53 					sta addr+1
    54
    55 					ldy #0
    56
    57 					lda :STACKORIGIN-1+STACKWIDTH,x	; dividend sign
    58 					bpl @+
    59 					jsr negWORD1
    60 					iny
    61 893F			@
    62 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    63 					bpl @+
    64 					jsr negWORD
    65 					iny
    66 893F			@
    67 					tya
    68 					and #1
    69 					pha
    70
    71 					jsr $ffff			; idiv cx
    72 893F			addr	equ *-2
    73
    74 					jsr movaBX_EAX
    75
    76 893F			_mod	bit movZTMP_aBX			; mod
    77 					mva #{bit} _mod
    78
    79 					pla
    80 					seq
    81 					jmp negCARD1
    82
    83 					rts
    84 				.endp
  1246 893F				icl '6502\cpu6502_integer.asm'		; mul / div -> INTEGER
Source: cpu6502_integer.asm
     1
     2 				/*
     3 					mulINTEGER
     4 					divmulINT
     5 				*/
     5
     6
     7 893F			.proc	mulINTEGER
     8
     9 					jsr imulCARD
    10
    11 					jmp movaBX_EAX
    12 				.endp
    13
    14
    15 893F			.proc	divmulINT
    16
    17 893F			REAL	ldy <divREAL
    18 					lda >divREAL
    19 					bne skp
    20
    21 893F			MOD	mva #{jsr} _mod
    22
    23 					lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    24 					spl
    25 					jsr negCARD
    26
    27 893F			DIV	ldy <idivCARD
    28 					lda >idivCARD
    29
    30 893F			skp	sty addr
    31 					sta addr+1
    32
    33 					ldy #0
    34
    35 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; dividend sign
    36 					bpl @+
    37 					jsr negCARD1
    38 					iny
    39
    40 893F			@	lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    41 					bpl @+
    42 					jsr negCARD
    43 					iny
    44
    45 893F			@	tya
    46 					and #1
    47 					pha
    48
    49 					jsr $ffff				; idiv ecx
    50 893F			addr	equ *-2
    51 					jsr movaBX_EAX
    52
    53 893F			_mod	bit movZTMP_aBX				; mod
    54 					mva #{bit} _mod
    55
    56 					pla
    57 					seq
    58 					jmp negCARD1
    59
    60 					rts
    61 				.endp
  1247
  1248 893F				icl '6502\cpu6502_byte.asm'		; mul / div -> BYTE
Source: cpu6502_byte.asm
     1
     2 				/*
     3 					fmulu_8
     4 					imulCL
     5 					imulBYTE
     6 					idivBYTE
     7 					idiv_AL_CL
     8 				*/
     8
     9
    10 				; Description: Unsigned 8-bit multiplication with unsigned 16-bit result.
    11 				;
    12 				; Input: 8-bit unsigned value in T1
    13 				;	 8-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 16-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 893F			.proc fmulu_8
    31
    32 = 00A2			t1	= eax
    33 = 00AA			t2	= ecx
    34
    35 = 00A2			product	= eax
    36
    37 					txa:tay
    38 				;		bcc :+
    39 						    lda T1
    40 						    sta sm1+1
    41 						    sta sm3+1
    42 						    eor #$ff
    43 						    sta sm2+1
    44 						    sta sm4+1
    45
    46 						ldx T2
    47 						sec
    48 893F			sm1:		lda square1_lo,x
    49 893F			sm2:		sbc square2_lo,x
    50 						sta PRODUCT+0
    51 893F			sm3:		lda square1_hi,x
    52 893F			sm4:		sbc square2_hi,x
    53
    54 						sta PRODUCT+1
    55
    56 					tya:tax
    57 						rts
    58 				.endp
    59
    60
    61 				/*
    62
    63 				 8 bit multiply and divide routines.
    64 				 Three 8 bit locations
    65 				 ACC, AUX and EXT must be set up,
    66 				 preferably on zero page.
    67
    68 				 MULTIPLY ROUTINE
    69
    70 				 EAX*ECX -> EAX (low,hi) 16 bit result
    71
    72 				*/
    72
    73
    74 893F			.proc	imulCL
    75
    76 893F A9 00			lda #$00
    77
    78 8941 A0 09			LDY #$09
    79 8943 18				CLC
    80 8944 6A			LOOP	ROR @
    81 8945 66 A2			ROR eax
    82 8947 90 03			BCC MUL2
    83 8949 18				CLC		;DEC AUX above to remove CLC
    84 894A 65 AA			ADC ecx
    85 894C 88			MUL2	DEY
    86 894D D0 F5			BNE LOOP
    87
    88 894F 85 A3			STA eax+1
    89
    90 8951 60				RTS
    91 				.endp
    92
    93
    94 8952			.proc	imulBYTE
    95
    96 					mva :STACKORIGIN,x ecx
    97 					mva :STACKORIGIN-1,x eax
    98
    99 					lda #$00
   100
   101 					sta eax+2
   102 					sta eax+3
   103
   104 					.ifdef fmulinit
   105 					jmp fmulu_8
   106 					els
   107 					jmp imulCL
   108 					eif
   109
   110 				.endp
   111
   112
   113 				.define	jsr_imodBYTE jsr idivBYTE
   114
   115 8952			.proc	idivBYTE
   116
   117 					mva :STACKORIGIN,x ecx
   118 					mva :STACKORIGIN-1,x eax
   119
   120 					jmp idivAL_CL
   121 				.endp
   122
   123
   124 				; DIVIDE ROUTINE (8 BIT)
   125 				; AL/CL -> ACC, remainder in ZTMP
   126
   127 8952			.proc idivAL_CL
   128
   129 				;	mva :STACKORIGIN,x cl
   130 				;	mva :STACKORIGIN-1,x al
   131
   132 					lda #$00
   133
   134 					sta eax+1
   135 					sta eax+2
   136 					sta eax+3
   137
   138 					STA ztmp+1
   139 					STA ztmp+2
   140 					STA ztmp+3
   141
   142 					LDY #$08
   143 8952			LOOP	ASL AL
   144 					ROL @
   145 					CMP CL
   146 					BCC DIV2
   147 					SBC CL
   148 					INC AL
   149 8952			DIV2
   150 					DEY
   151 					BNE LOOP
   152
   153 					STA ZTMP
   154
   155 					rts
   156 				.endp
   157
  1249 8952				icl '6502\cpu6502_word.asm'		; mul / div -> WORD
Source: cpu6502_word.asm
     1
     2 				/*
     3 					fmulu_16
     4 					imulCX
     5 					imulWORD
     6 					idivWORD
     7 					idivAX_CX
     8 				*/
     8
     9
    10 				; Description: Unsigned 16-bit multiplication with unsigned 32-bit result.
    11 				;
    12 				; Input: 16-bit unsigned value in T1
    13 				;	 16-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 32-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 				//.proc multiply_16bit_unsigned
    31 						; <T1 * <T2 = AAaa
    32 						; <T1 * >T2 = BBbb
    33 						; >T1 * <T2 = CCcc
    34 						; >T1 * >T2 = DDdd
    35 						;
    36 						;	AAaa
    37 						;     BBbb
    38 						;     CCcc
    39 						; + DDdd
    40 						; ----------
    41 						;   PRODUCT!
    42
    43 						; Setup T1 if changed
    44 8952			.proc	fmulu_16
    45
    46 = 00A2			t1	= eax
    47 = 00AA			t2	= ecx
    48
    49 = 00A2			product	= eax
    50
    51 					txa:pha
    52 				;		bcc @+
    53 						    lda T1+0
    54 						    sta sm1a+1
    55 						    sta sm3a+1
    56 						    sta sm5a+1
    57 						    sta sm7a+1
    58 						    eor #$ff
    59 						    sta sm2a+1
    60 						    sta sm4a+1
    61 						    sta sm6a+1
    62 						    sta sm8a+1
    63 						    lda T1+1
    64 						    sta sm1b+1
    65 						    sta sm3b+1
    66 						    sta sm5b+1
    67 						    sta sm7b+1
    68 						    eor #$ff
    69 						    sta sm2b+1
    70 						    sta sm4b+1
    71 						    sta sm6b+1
    72 						    sta sm8b+1
    73 				;@
    74 						; Perform <T1 * <T2 = AAaa
    75 						ldx T2+0
    76 						sec
    77 8952			sm1a:		lda square1_lo,x
    78 8952			sm2a:		sbc square2_lo,x
    79 						sta PRODUCT+0
    80 8952			sm3a:		lda square1_hi,x
    81 8952			sm4a:		sbc square2_hi,x
    82 						;sta _AA+1
    83 						tay
    84
    85 						; Perform >T1_hi * <T2 = CCcc
    86 						sec
    87 8952			sm1b:		lda square1_lo,x
    88 8952			sm2b:		sbc square2_lo,x
    89 						sta _cc+1
    90 8952			sm3b:		lda square1_hi,x
    91 8952			sm4b:		sbc square2_hi,x
    92 						sta _CC_+1
    93
    94 						; Perform <T1 * >T2 = BBbb
    95 						ldx T2+1
    96 						sec
    97 8952			sm5a:		lda square1_lo,x
    98 8952			sm6a:		sbc square2_lo,x
    99 						sta _bb+1
   100 8952			sm7a:		lda square1_hi,x
   101 8952			sm8a:		sbc square2_hi,x
   102 						sta _BB_+1
   103
   104 						; Perform >T1 * >T2 = DDdd
   105 						sec
   106 8952			sm5b:		lda square1_lo,x
   107 8952			sm6b:		sbc square2_lo,x
   108 						sta _dd+1
   109 8952			sm7b:		lda square1_hi,x
   110 8952			sm8b:		sbc square2_hi,x
   111 				;		sta PRODUCT+3
   112 						tax
   113
   114 						; Add the separate multiplications together
   115 						clc
   116 				;_AA:		lda #0
   117 						tya
   118 8952			_bb:		adc #0
   119 				;		sta PRODUCT+1
   120 						tay
   121 8952			_BB_:		lda #0
   122 8952			_CC_:		adc #0
   123 						sta PRODUCT+2
   124 						bcc @+
   125 				;		    inc PRODUCT+3
   126 						inx
   127 						    clc
   128 8952			@
   129 						tya
   130 8952			_cc:		adc #0
   131 				;		adc PRODUCT+1
   132 						sta PRODUCT+1
   133 8952			_dd:		lda #0
   134 						adc PRODUCT+2
   135 						sta PRODUCT+2
   136 						scc
   137 				;		    inc PRODUCT+3
   138 						inx
   139
   140 					stx PRODUCT+3
   141
   142 					pla:tax
   143
   144 					rts
   145 				.endp
   146
   147
   148 				/*
   149
   150 				 16 bit multiply and divide routines.
   151 				 Three 16 bit (two-byte) locations
   152 				 ACC, AUX and EXT must be set up,
   153 				 preferably on zero page.
   154
   155 				 MULTIPLY ROUTINE
   156
   157 				 EAX*ECX -> EAX (low,hi) 32 bit result
   158
   159 				*/
   159
   160
   161 8952			.proc	imulCX
   162
   163 					lda #$00
   164 					sta eax+3
   165
   166 					LDY #$11			; A = 0 !
   167 					CLC
   168 8952			LOOP	ROR eax+3
   169 					ROR @
   170 					ROR eax+1
   171 					ROR eax
   172 					BCC MUL2
   173 					CLC
   174 					ADC ecx
   175 					PHA
   176 					LDA ecx+1
   177 					ADC eax+3
   178 					STA eax+3
   179 					PLA
   180 8952			MUL2	DEY
   181 					BNE LOOP
   182
   183 					STA eax+2
   184
   185 					rts
   186 				.endp
   187
   188
   189 8952			.proc	imulWORD
   190
   191 					mva :STACKORIGIN,x ecx
   192 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   193
   194 					mva :STACKORIGIN-1,x eax
   195 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   196
   197 					.ifdef fmulinit
   198 					jmp fmulu_16
   199 					els
   200 					jmp imulCX
   201 					eif
   202 				.endp
   203
   204
   205 				.define	jsr_imodWORD jsr idivWORD
   206
   207 8952			.proc	idivWORD
   208
   209 					mva :STACKORIGIN,x ecx
   210 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   211
   212 					mva :STACKORIGIN-1,x eax
   213 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   214
   215 					jmp idivAX_CX
   216 				.endp
   217
   218
   219 				; DIVIDE ROUTINE (16 BIT)
   220 				; AX/CX -> ACC, remainder in ZTMP
   221
   222 8952			.proc	idivAX_CX
   223
   224 				;	jsr iniEAX_ECX_WORD
   225 8952			main
   226 					LDA #0
   227 					STA ztmp+1
   228 					STA ztmp+2
   229 					STA ztmp+3
   230
   231 					sta eax+2
   232 					sta eax+3
   233
   234 					.ifdef fmulinit
   235 					.rept 16
   236 					ASL ax
   237 					ROL ax+1
   238 					ROL @
   239 					ROL ztmp+1
   240 					tay
   241 					CMP cx
   242 					LDA ztmp+1
   243 					SBC cx+1
   244 					BCC @+
   245 					STA ztmp+1
   246 					tya
   247 					SBC cx
   248 					tay
   249 					INC ax
   250 				@	tya
   251 					.endr
   252
   253 					els
   254 					LDY #$10
   255
   256 8952			LOOP	ASL ax
   257 					ROL ax+1
   258 					ROL @
   259 					ROL ztmp+1
   260 					sta edx
   261 					CMP cx
   262 					LDA ztmp+1
   263 					SBC cx+1
   264 					BCC DIV2
   265 					STA ztmp+1
   266 					lda edx
   267 					SBC cx
   268 					sta edx
   269 					INC ax
   270 8952			DIV2	lda edx
   271 					DEY
   272 					BNE LOOP
   273 					eif
   274
   275 					STA ztmp
   276
   277 					rts
   278 				.endp
   279
  1250 8952				icl '6502\cpu6502_cardinal.asm'		; mul / div -> CARDINAL
Source: cpu6502_cardinal.asm
     1
     2 				/*
     3 					imulECX
     4 					imulCARD
     5 					idivCARD
     6 					idivEAX_ECX
     7 				*/
     7
     8
     9 				; *** MUL32: 32-bit multiply
    10 				; EAX * ECX -> ZTMP8-ZTMP11
    11 8952			.proc	imulECX
    12
    13 					lda #0
    14 					sta ZTMP10
    15 					sta ZTMP9
    16 					sta ZTMP8
    17
    18 					ldy #32
    19 8952			MUL320	lsr ZTMP10
    20 					ror ZTMP9
    21 					ror ZTMP8
    22 					ror @
    23 					ror eax+3
    24 					ror eax+2
    25 					ror eax+1
    26 					ror eax
    27 					bcc MUL321
    28 					clc
    29 					adc ecx
    30 					pha
    31 					lda ecx+1
    32 					adc ZTMP8
    33 					sta ZTMP8
    34 					lda ecx+2
    35 					adc ZTMP9
    36 					sta ZTMP9
    37 					lda ecx+3
    38 					adc ZTMP10
    39 					sta ZTMP10
    40 					pla
    41 8952			MUL321	dey
    42 				       	bpl MUL320
    43
    44 					rts
    45 				.endp
    46
    47
    48 8952			.proc	imulCARD
    49
    50 					jsr iniEAX_ECX_CARD
    51
    52 					jmp imulECX
    53 				.endp
    54
    55
    56 				.define	jsr_imodCARD jsr idivCARD
    57
    58 8952			.proc	idivCARD
    59
    60 					jsr iniEAX_ECX_CARD
    61
    62 					jmp idivEAX_ECX.CARD
    63 				.endp
    64
    65
    66 				; *** UDIV32: 32-bit unsigned division
    67 				; input: dividend at ZTMP0-ZTMP3
    68 				;        divisor at ZTMP4-ZTMP7
    69 				; output: result at ZTMP0-ZTMP3
    70 				;         remainder at ZTMP8-ZTMP11
    71 				; X,Y preserved
    72
    73 8952			.proc	idivEAX_ECX
    74
    75 8952			REAL	mva :STACKORIGIN-1+STACKWIDTH*2,x :STACKORIGIN-1+STACKWIDTH*3,x
    76 					mva :STACKORIGIN-1+STACKWIDTH,x :STACKORIGIN-1+STACKWIDTH*2,x
    77 					mva :STACKORIGIN-1,x :STACKORIGIN-1+STACKWIDTH,x
    78 					mva #$00 :STACKORIGIN-1,x
    79
    80 8952			CARD	;jsr iniEAX_ECX_CARD
    81
    82 8952			MAIN	LDA #0
    83 					STA ZTMP8
    84 					STA ZTMP9
    85 					STA ZTMP10
    86 					STA ZTMP11
    87
    88 					LDY #32
    89 8952			UDIV320	ASL eax
    90 					ROL eax+1
    91 					ROL eax+2
    92 					ROL eax+3
    93 					ROL ZTMP8
    94 					ROL ZTMP9
    95 					ROL ZTMP10
    96 					ROL ZTMP11
    97 							;do a subtraction
    98 					LDA ZTMP8
    99 					CMP ecx
   100 					LDA ZTMP9
   101 					SBC ecx+1
   102 					LDA ZTMP10
   103 					SBC ecx+2
   104 					LDA ZTMP11
   105 					SBC ecx+3
   106 					BCC UDIV321
   107 				 			;overflow, do the subtraction again, this time store the result
   108 					STA ecx+3	;we have the high byte already
   109 					LDA ZTMP8
   110 					SBC ecx		;byte 0
   111 					STA ZTMP8
   112 					LDA ZTMP9
   113 					SBC ecx+1
   114 					STA ZTMP9	;byte 1
   115 					LDA ZTMP10
   116 					SBC ecx+2
   117 					STA ZTMP10	;byte 2
   118 					INC eax		;set result bit
   119
   120 8952			UDIV321	DEY
   121 					BNE UDIV320
   122
   123 					rts
   124 				.endp
   125
  1251
  1252 8952				icl '6502\cpu6502_shortreal.asm'	; mul / div -> SHORTREAL	Q8.8
Source: cpu6502_shortreal.asm
     1 				; SHORTREAL	fixed-point Q8.8, 16bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulSHORTREAL
     6 					divSHORTREAL
     7 				*/
     7
     8
     9
    10 8952			.proc	mulSHORTREAL
    11
    12 					jsr imulWORD
    13
    14 					mva #0 eax+3
    15 					mva eax+1 eax
    16 					mva eax+2 eax+1
    17
    18 					ldy eax+3
    19
    20 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    21 					bpl @+
    22 					sec
    23 					lda eax+1
    24 					sbc :STACKORIGIN,x
    25 					sta eax+1
    26 					tya
    27 					sbc :STACKORIGIN+STACKWIDTH,x
    28 					tay
    29 8952			@
    30 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    31 					bpl @+
    32 					sec
    33 					lda eax+1
    34 					sbc :STACKORIGIN-1,x
    35 					sta eax+1
    36 					tya
    37 					sbc :STACKORIGIN-1+STACKWIDTH,x
    38 					tay
    39 8952			@
    40 					sty eax+2
    41
    42 					jmp movaBX_EAX
    43 				.endp
    44
    45
    46
    47 8952			.proc	divSHORTREAL
    48 					jsr iniEAX_ECX_WORD
    49
    50 					mva eax+1 eax+2
    51 					mva eax eax+1
    52 					lda #0
    53 					sta eax
    54 					sta eax+3
    55 					sta ecx+3
    56
    57 					jmp idivEAX_ECX.main
    58 				.endp
  1253 8952				icl '6502\cpu6502_real.asm'		; mul / div -> REAL		Q24.8
Source: cpu6502_real.asm
     1 				; REAL	fixed-point Q24.8, 32bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulREAL
     6 					divREAL
     7 				*/
     7
     8
     9
    10 8952			.proc	mulREAl
    11
    12 				;	jsr iniEAX_ECX_CARD
    13
    14 					mva :STACKORIGIN,x ecx0
    15 					mva :STACKORIGIN+STACKWIDTH,x ecx1
    16 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
    17 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
    18
    19 					mva :STACKORIGIN-1,x eax
    20 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
    21 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
    22 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
    23
    24 				;	jsr imul64				; imul ecx 64 bit
    25
    26 					lda #$00
    27 					sta edx		;Clear upper half of
    28 					sta edx+1	;product
    29 					sta edx+2
    30 					sta edx+3
    31
    32 					sta ztmp8
    33 					sta ztmp9
    34 					sta ztmp10
    35 					sta ztmp11
    36
    37 					ldy #$20	;Set binary count to 32
    38 8952			SHIFT_R	lsr eax+3	;Shift multiplyer right
    39 					ror eax+2
    40 					ror eax+1
    41 					ror eax
    42 					bcc ROTATE_R	;Go rotate right if c = 0
    43 					lda edx		;Get upper half of product
    44 					clc		;and add multiplicand to
    45 					adc #0		;it
    46 8952			ecx0	equ *-1
    47 					sta edx
    48 					lda edx+1
    49 					adc #0
    50 8952			ecx1	equ *-1
    51 					sta edx+1
    52 					lda edx+2
    53 					adc #0
    54 8952			ecx2	equ *-1
    55 					sta edx+2
    56 					lda edx+3
    57 					adc #0
    58 8952			ecx3	equ *-1
    59 8952			ROTATE_R  ror @		;Rotate partial product
    60 				        sta edx+3	;right
    61 				        ror edx+2
    62 				        ror edx+1
    63 				        ror edx
    64 				        ror ztmp11
    65 				        ror ztmp10
    66 				        ror ztmp9
    67 				        ror ztmp8
    68 				        dey		;Decrement bit count and
    69 				        bne SHIFT_R	;loop until 32 bits are
    70
    71 				;	mva ztmp8 eax
    72 					mva ztmp9 eax
    73 					mva ztmp10 eax+1
    74 					mva ztmp11 eax+2
    75
    76
    77 				;	mva eax+1 eax
    78 				;	mva eax+2 eax+1
    79 				;	mva eax+3 eax+2
    80
    81 					ldy edx
    82
    83 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; t1
    84 					bpl @+
    85 					sec
    86 					tya
    87 					sbc :STACKORIGIN,x
    88 					tay
    89 8952			@
    90 					lda :STACKORIGIN+STACKWIDTH*3,x		; t2
    91 					bpl @+
    92 					sec
    93 					tya
    94 					sbc :STACKORIGIN-1,x
    95 					tay
    96 8952			@
    97 					sty eax+3
    98
    99 					jmp movaBX_EAX
   100 				.endp
   101
   102
   103 				/*
   104 				;32 bit multiply with 64 bit product
   105
   106 				.proc	imul64
   107
   108 					lda #$00
   109 					sta edx		;Clear upper half of
   110 					sta edx+1	;product
   111 					sta edx+2
   112 					sta edx+3
   113
   114 					sta ztmp8
   115 					sta ztmp9
   116 					sta ztmp10
   117 					sta ztmp11
   118
   119 					ldy #$20	;Set binary count to 32
   120 				SHIFT_R	lsr eax+3	;Shift multiplyer right
   121 					ror eax+2
   122 					ror eax+1
   123 					ror eax
   124 					bcc ROTATE_R	;Go rotate right if c = 0
   125 					lda edx		;Get upper half of product
   126 					clc		;and add multiplicand to
   127 					adc ecx		;it
   128 					sta edx
   129 					lda edx+1
   130 					adc ecx+1
   131 					sta edx+1
   132 					lda edx+2
   133 					adc ecx+2
   134 					sta edx+2
   135 					lda edx+3
   136 					adc ecx+3
   137 				ROTATE_R  ror @		;Rotate partial product
   138 				        sta edx+3	;right
   139 				        ror edx+2
   140 				        ror edx+1
   141 				        ror edx
   142 				        ror ztmp11
   143 				        ror ztmp10
   144 				        ror ztmp9
   145 				        ror ztmp8
   146 				        dey		;Decrement bit count and
   147 				        bne SHIFT_R	;loop until 32 bits are
   148
   149 					mva ztmp8 eax
   150 					mva ztmp9 eax+1
   151 					mva ztmp10 eax+2
   152 					mva ztmp11 eax+3
   153
   154 					rts
   155 				.endp
   156 				*/
   156
   157
   158 				; 64bit / 32bit = 32bit
   159 				; eax = eax + edx
   160
   161 8952			.proc	divREAL
   162
   163 					mva :STACKORIGIN,x ecx0
   164 					sta ecx0_
   165 					mva :STACKORIGIN+STACKWIDTH,x ecx1
   166 					sta ecx1_
   167 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
   168 					sta ecx2_
   169 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
   170
   171 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+4
   172 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+3
   173 					mva :STACKORIGIN-1+STACKWIDTH,x eax+2
   174 					mva :STACKORIGIN-1,x eax+1
   175
   176 					lda #$00
   177 					sta eax
   178 					sta eax+5
   179 					sta eax+6
   180 					sta eax+7
   181
   182 					STA ZTMP8
   183 					STA ZTMP9
   184 					STA ZTMP10
   185 					STA ZTMP11
   186
   187 					LDY #64
   188 8952			UDIV320	ASL eax
   189 					ROL eax+1
   190 					ROL eax+2
   191 					ROL eax+3
   192 					ROL eax+4
   193 					ROL eax+5
   194 					ROL eax+6
   195 					ROL eax+7
   196
   197 					ROL ZTMP8
   198 					ROL ZTMP9
   199 					ROL ZTMP10
   200 					ROL ZTMP11
   201 							;do a subtraction
   202 					LDA ZTMP8
   203 					CMP #0
   204 8952			ecx0	equ *-1
   205 					LDA ZTMP9
   206 					SBC #0
   207 8952			ecx1	equ *-1
   208 					LDA ZTMP10
   209 					SBC #0
   210 8952			ecx2	equ *-1
   211 					LDA ZTMP11
   212 					SBC #0
   213 8952			ecx3	equ *-1
   214 					BCC UDIV321
   215 				 			;overflow, do the subtraction again, this time store the result
   216 					STA ecx3	;we have the high byte already
   217 					LDA ZTMP8
   218 					SBC #0		;byte 0
   219 8952			ecx0_	equ *-1
   220 					STA ZTMP8
   221 					LDA ZTMP9
   222 					SBC #0
   223 8952			ecx1_	equ *-1
   224 					STA ZTMP9	;byte 1
   225 					LDA ZTMP10
   226 					SBC #0
   227 8952			ecx2_	equ *-1
   228 					STA ZTMP10	;byte 2
   229
   230 					INC eax		;set result bit
   231
   232 8952			UDIV321	DEY
   233 					BNE UDIV320
   234
   235 					rts
   236 				.endp
   237
   238
   239 				/*
   240 				.proc	divREAL
   241
   242 					jsr iniEAX_ECX_CARD
   243
   244 					mva eax+3 eax+4
   245 					mva eax+2 eax+3
   246 					mva eax+1 eax+2
   247 					mva eax eax+1
   248
   249 					lda #$00
   250 					sta eax
   251 					sta eax+5
   252 					sta eax+6
   253 					sta eax+7
   254
   255 					STA ZTMP8
   256 					STA ZTMP9
   257 					STA ZTMP10
   258 					STA ZTMP11
   259
   260 					LDY #64
   261 				UDIV320	ASL eax
   262 					ROL eax+1
   263 					ROL eax+2
   264 					ROL eax+3
   265 					ROL eax+4
   266 					ROL eax+5
   267 					ROL eax+6
   268 					ROL eax+7
   269
   270 					ROL ZTMP8
   271 					ROL ZTMP9
   272 					ROL ZTMP10
   273 					ROL ZTMP11
   274 							;do a subtraction
   275 					LDA ZTMP8
   276 					CMP ecx
   277 					LDA ZTMP9
   278 					SBC ecx+1
   279 					LDA ZTMP10
   280 					SBC ecx+2
   281 					LDA ZTMP11
   282 					SBC ecx+3
   283 					BCC UDIV321
   284 				 			;overflow, do the subtraction again, this time store the result
   285 					STA ecx+3	;we have the high byte already
   286 					LDA ZTMP8
   287 					SBC ecx		;byte 0
   288 					STA ZTMP8
   289 					LDA ZTMP9
   290 					SBC ecx+1
   291 					STA ZTMP9	;byte 1
   292 					LDA ZTMP10
   293 					SBC ecx+2
   294 					STA ZTMP10	;byte 2
   295
   296 					INC eax		;set result bit
   297
   298 				UDIV321	DEY
   299 					BNE UDIV320
   300
   301 					rts
   302 				.endp
   303 				*/
   303
  1254 8952				icl '6502\cpu6502_single.asm'		; mul / div -> SINGLE		IEEE-754
Source: cpu6502_single.asm
     1 				; JAVA IEEE-32 (IEEE-754)
     2 				; David Schmenk
     3 				; https://sourceforge.net/projects/vm02/
     4 				; http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/src/
     5
     6 				/*
     7 					org eax
     8
     9 				FP1MAN0	.ds 1
    10 				FP1MAN1	.ds 1
    11 				FP1MAN2	.ds 1
    12 				FP1MAN3	.ds 1
    13
    14 					org ztmp8
    15
    16 				FP1SGN	.ds 1
    17 				FP1EXP	.ds 1
    18
    19 					org edx
    20
    21 				FP2MAN0	.ds 1
    22 				FP2MAN1	.ds 1
    23 				FP2MAN2	.ds 1
    24 				FP2MAN3	.ds 1
    25
    26 					org ztmp10
    27
    28 				FP2SGN	.ds 1
    29 				FP2EXP	.ds 1
    30
    31 					org ecx
    32
    33 				FPMAN0	.ds 1
    34 				FPMAN1	.ds 1
    35 				FPMAN2	.ds 1
    36 				FPMAN3	.ds 1
    37
    38 					org bp2
    39
    40 				FPSGN	.ds 1
    41 				FPEXP	.ds 1
    42
    43 				*/
    43
    44
    45 = 00AF			@rx	= bp+1
    46
    47 = 000A			MIN_EXPONENT	= 10
    48 = 00FF			MAX_EXPONENT	= 255
    49
    50
    51 8952			.proc	NEGINT
    52
    53 					LDA	#$00
    54 					SEC
    55
    56 8952			enter	SBC	FPMAN0
    57 					STA	FPMAN0
    58 					LDA	#$00
    59 					SBC	FPMAN1
    60 					STA	FPMAN1
    61 					LDA	#$00
    62 					SBC	FPMAN2
    63 					STA	FPMAN2
    64 					LDA	#$00
    65 					SBC	FPMAN3
    66 					STA	FPMAN3
    67 					RTS
    68 				.endp
    69
    70
    71 8952			.proc	FFRAC
    72 					inx
    73 					lda :STACKORIGIN-1,x
    74 					sta :STACKORIGIN,x
    75
    76 					lda :STACKORIGIN-1+STACKWIDTH,x
    77 					sta :STACKORIGIN+STACKWIDTH,x
    78
    79 					lda :STACKORIGIN-1+STACKWIDTH*2,x
    80 					sta :STACKORIGIN+STACKWIDTH*2,x
    81
    82 					lda :STACKORIGIN-1+STACKWIDTH*3,x
    83 					eor #$80
    84 					sta :STACKORIGIN+STACKWIDTH*3,x
    85
    86 					dex
    87
    88 					jsr F2I
    89 					jsr I2F
    90
    91 					lda :STACKORIGIN+STACKWIDTH*3,x
    92 					eor #$80
    93 					sta :STACKORIGIN+STACKWIDTH*3,x
    94
    95 					inx
    96
    97 					jsr FSUB
    98
    99 					dex
   100
   101 					rts
   102 				.endp
   103
   104
   105 8952			.proc	FROUND
   106 				;	LDA	#$00
   107 				;	STA	FP2SGN
   108
   109 					lda :STACKORIGIN,x
   110 					STA	FP2MAN0
   111 					lda :STACKORIGIN+STACKWIDTH,x
   112 					STA	FP2MAN1
   113 					lda :STACKORIGIN+STACKWIDTH*2,x
   114 					CMP	#$80		; SET CARRY FROM MSB
   115 					ORA	#$80		; SET HIDDEN BIT
   116 					STA	FP2MAN2
   117 					lda :STACKORIGIN+STACKWIDTH*3,x
   118 				;	EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   119 					ROL
   120 					STA	FP2EXP
   121 					LDA	#$00
   122 					STA	FPSGN
   123 					BCC	@+
   124 					SBC	FP2MAN0
   125 					STA	FP2MAN0
   126 					LDA	#$00
   127 					SBC	FP2MAN1
   128 					STA	FP2MAN1
   129 					LDA	#$00
   130 					SBC	FP2MAN2
   131 					STA	FP2MAN2
   132 					LDA	#$FF
   133 8952			@	STA	FP2MAN3
   134 					lda #$00
   135 					STA	FP1MAN0
   136 					STA	FP1MAN1
   137 					CMP	#$80		; SET CARRY FROM MSB
   138 					ORA	#$80		; SET HIDDEN BIT
   139 					STA	FP1MAN2
   140
   141 					lda :STACKORIGIN+STACKWIDTH*3,x
   142 					and #$80
   143 					ora #$3f		; 0.5 / -0.5
   144
   145 					inx
   146
   147 					jsr FSUB.enter
   148
   149 					dex
   150
   151 					rts
   152 				.endp
   153
   154
   155 8952			.proc	FSUB
   156 					LDA	#$80		; TOGGLE SIGN
   157 					BNE	@+
   158 8952			FADD:	LDA	#$00
   159 8952			@	STA	FP2SGN
   160 				;	stx @rx
   161
   162 					lda :STACKORIGIN,x
   163 					STA	FP2MAN0
   164 					lda :STACKORIGIN+STACKWIDTH,x
   165 					STA	FP2MAN1
   166 					lda :STACKORIGIN+STACKWIDTH*2,x
   167 					CMP	#$80		; SET CARRY FROM MSB
   168 					ORA	#$80		; SET HIDDEN BIT
   169 					STA	FP2MAN2
   170 					lda :STACKORIGIN+STACKWIDTH*3,x
   171 					EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   172 					ROL
   173 					STA	FP2EXP
   174 					LDA	#$00
   175 					STA	FPSGN
   176 					BCC	@+
   177 					SBC	FP2MAN0
   178 					STA	FP2MAN0
   179 					LDA	#$00
   180 					SBC	FP2MAN1
   181 					STA	FP2MAN1
   182 					LDA	#$00
   183 					SBC	FP2MAN2
   184 					STA	FP2MAN2
   185 					LDA	#$FF
   186 8952			@	STA	FP2MAN3
   187 					lda :STACKORIGIN-1,x
   188 					STA	FP1MAN0
   189 					lda :STACKORIGIN-1+STACKWIDTH,x
   190 					STA	FP1MAN1
   191 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   192 					CMP	#$80		; SET CARRY FROM MSB
   193 					ORA	#$80		; SET HIDDEN BIT
   194 					STA	FP1MAN2
   195 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   196 8952			enter	ROL
   197 					STA	FP1EXP
   198 					LDA	#$00
   199 					BCC	@+
   200 					SBC	FP1MAN0
   201 					STA	FP1MAN0
   202 					LDA	#$00
   203 					SBC	FP1MAN1
   204 					STA	FP1MAN1
   205 					LDA	#$00
   206 					SBC	FP1MAN2
   207 					STA	FP1MAN2
   208 					LDA	#$FF
   209 8952			@	STA	FP1MAN3
   210 					LDA	FP1EXP		; CALCULATE WHICH MANTISSA TO SHIFT
   211 					STA	FPEXP
   212 					SEC
   213 					SBC	FP2EXP
   214 					BEQ	FADDMAN
   215 					BCS	@+
   216 					EOR	#$FF
   217 					TAY
   218 					INY
   219 					LDA	FP2EXP
   220 					STA	FPEXP
   221 					LDA	FP1MAN3
   222 					CPY	#24		; KEEP SHIFT RANGE VALID
   223 					BCC	FP1SHFT
   224 					LDA	#$00
   225 					STA	FP1MAN3
   226 					STA	FP1MAN2
   227 					STA	FP1MAN1
   228 					STA	FP1MAN0
   229 					BEQ	FADDMAN
   230 8952			FP1SHFT:	CMP	#$80	; SHIFT FP1 DOWN
   231 					ROR
   232 					ROR	FP1MAN2
   233 					ROR	FP1MAN1
   234 					ROR	FP1MAN0
   235 					DEY
   236 					BNE	FP1SHFT
   237 					STA	FP1MAN3
   238 					JMP	FADDMAN
   239
   240 8952			@	TAY
   241 					LDA	FP2MAN3
   242 					CPY	#24		; KEEP SHIFT RANGE VALID
   243 					BCC	FP2SHFT
   244 					LDA	#$00
   245 					STA	FP2MAN3
   246 					STA	FP2MAN2
   247 					STA	FP2MAN1
   248 					STA	FP2MAN0
   249 					BEQ	FADDMAN
   250 8952			FP2SHFT:	CMP	#$80	; SHIFT FP2 DOWN
   251 					ROR
   252 					ROR	FP2MAN2
   253 					ROR	FP2MAN1
   254 					ROR	FP2MAN0
   255 					DEY
   256 					BNE	FP2SHFT
   257 					STA	FP2MAN3
   258 8952			FADDMAN:	LDA	FP1MAN0
   259 					CLC
   260 					ADC	FP2MAN0
   261 					STA	FPMAN0
   262 					LDA	FP1MAN1
   263 					ADC	FP2MAN1
   264 					STA	FPMAN1
   265 					LDA	FP1MAN2
   266 					ADC	FP2MAN2
   267 					STA	FPMAN2
   268 					LDA	FP1MAN3
   269 					ADC	FP2MAN3
   270 					STA	FPMAN3
   271 					BPL	FPNORM
   272
   273 					LDA	#$80
   274 					STA	FPSGN
   275
   276 					JSR	NEGINT
   277
   278 					jmp FPNORM
   279 				.endp
   280
   281
   282 8952			.proc	FPNORM
   283 					BEQ	FPNORMLEFT	; NORMALIZE FP, A = FPMANT3
   284 8952			FPNORMRIGHT:	INC	FPEXP
   285 					LSR
   286 					STA	FPMAN3
   287 					ROR	FPMAN2
   288 					ROR	FPMAN1
   289 					LDA	FPMAN0
   290 					ROR
   291 					ADC	#$00
   292 					STA	FPMAN0
   293 					LDA	FPMAN1
   294 					ADC	#$00
   295 					STA	FPMAN1
   296 					LDA	FPMAN2
   297 					ADC	#$00
   298 					STA	FPMAN2
   299 					LDA	FPMAN3
   300 					ADC	#$00
   301 					BNE	FPNORMRIGHT
   302 					LDA	FPEXP
   303 					ASL	FPMAN2
   304 					LSR
   305 					ORA	FPSGN
   306
   307 				;	ldx @rx
   308 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   309 					LDA	FPMAN2
   310 					ROR
   311 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   312
   313 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   314 					asl @
   315 					tay
   316 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   317 					spl
   318 					iny
   319 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   320 					bcc zero
   321 					cpy #MAX_EXPONENT
   322 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   323
   324 					LDA	FPMAN1
   325 					sta :STACKORIGIN-1+STACKWIDTH,x
   326 					LDA	FPMAN0
   327 					sta :STACKORIGIN-1,x
   328 					rts
   329
   330 8952			FPNORMLEFT:	LDA	FPMAN2
   331 					BNE	FPNORMLEFT1
   332 					LDA	FPMAN1
   333 					BNE	FPNORMLEFT8
   334 					LDA	FPMAN0
   335 					BNE	FPNORMLEFT16
   336
   337 				;	ldx @rx			; RESULT IS ZERO
   338 8952			zero	lda #0
   339
   340 					sta :STACKORIGIN-1,x
   341 					sta :STACKORIGIN-1+STACKWIDTH,x
   342 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   343 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   344 					rts
   345
   346 8952			FPNORMLEFT16:	TAY
   347 					LDA	FPEXP
   348 					SEC
   349 					SBC	#$10
   350 					STA	FPEXP
   351 					LDA	#$00
   352 					STA	FPMAN1
   353 					STA	FPMAN0
   354 					TYA
   355 					BNE	FPNORMLEFT1
   356 8952			FPNORMLEFT8:	TAY
   357 					LDA	FPMAN0
   358 					STA	FPMAN1
   359 					LDA	FPEXP
   360 					SEC
   361 					SBC	#$08
   362 					STA	FPEXP
   363 					LDA	#$00
   364 					STA	FPMAN0
   365 					TYA
   366 8952			FPNORMLEFT1:	BMI	FPNORMDONE
   367 8952			@	DEC	FPEXP
   368 					ASL	FPMAN0
   369 					ROL	FPMAN1
   370 					ROL
   371 					BPL	@-
   372 8952			FPNORMDONE:	ASL
   373 					TAY
   374 					LDA	FPEXP
   375 					LSR
   376 					ORA	FPSGN
   377
   378 				;	ldx @rx
   379 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   380 					TYA
   381 					ROR
   382 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   383
   384 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   385 					asl @
   386 					tay
   387 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   388 					spl
   389 					iny
   390 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   391 					bcc zero
   392 					cpy #MAX_EXPONENT
   393 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   394
   395 					LDA	FPMAN1
   396 					sta :STACKORIGIN-1+STACKWIDTH,x
   397 					LDA	FPMAN0
   398 					sta :STACKORIGIN-1,x
   399
   400 					rts
   401 				.endp
   402
   403
   404 8952			.proc	FMUL
   405
   406 					stx @rx
   407
   408 					lda :STACKORIGIN,x
   409 					STA	FP2MAN0
   410 					lda :STACKORIGIN+STACKWIDTH,x
   411 					STA	FP2MAN1
   412 					lda :STACKORIGIN+STACKWIDTH*2,x
   413 					CMP	#$80		; SET CARRY FROM MSB
   414 					ORA	#$80		; SET HIDDEN BIT
   415 					STA	FP2MAN2
   416 				 	lda :STACKORIGIN+STACKWIDTH*3,x
   417 					ROL
   418 					STA	FP2EXP
   419 					BNE	@+
   420
   421 				; MUL BY ZERO, RESULT ZERO
   422 				;	LDA	#$00
   423 8952			ZERO:	STA :STACKORIGIN-1,x
   424 					STA :STACKORIGIN-1+STACKWIDTH,x
   425 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   426 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   427 					rts
   428
   429 8952			@	LDA	#$00
   430 					ROR
   431 					STA	FPSGN
   432 					lda :STACKORIGIN-1,x
   433 					STA	FP1MAN0
   434 					lda :STACKORIGIN-1+STACKWIDTH,x
   435 					STA	FP1MAN1
   436 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   437 					CMP	#$80		; SET CARRY FROM MSB
   438 					ORA	#$80		; SET HIDDEN BIT
   439 					STA	FP1MAN2
   440 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   441 					ROL
   442 					STA	FP1EXP
   443 					BEQ	ZERO		; MUL BY ZERO, RESULT ZERO
   444
   445 					LDA	#$00
   446 					ROR
   447 					EOR	FPSGN
   448 					STA	FPSGN
   449 					LDA	FP1EXP
   450 					CLC			; ADD EXPONENTS
   451 					ADC	FP2EXP
   452 					SEC			; SUBTRACT BIAS
   453 					SBC	#$7F
   454 					STA	FPEXP
   455 					LDX	#$00
   456 					STX	FPMAN0
   457 					STX	FPMAN1
   458 					STX	FPMAN2
   459 					STX	FPMAN3
   460 					STX	TMP
   461 8952			FMULNEXTBYTE:	LDA	FP1MAN0,X
   462 					BNE	@+
   463 					LDX	FPMAN1		; SHORT CIRCUIT BYTE OF ZERO BITS
   464 					STX	FPMAN0
   465 					LDX	FPMAN2
   466 					STX	FPMAN1
   467 					LDX	FPMAN3
   468 					STX	FPMAN2
   469 					STA	FPMAN3
   470 					INC	TMP
   471 					LDX	TMP
   472 					CPX	#$03
   473 					BNE	FMULNEXTBYTE
   474
   475 					ldx @rx
   476 					LDA	FPMAN3
   477 					JMP	FPNORM
   478
   479 8952			@	EOR	#$FF
   480 					LDX	#$08
   481 8952			FMULTSTBITS:	LSR	FPMAN3
   482 					ROR	FPMAN2
   483 					ROR	FPMAN1
   484 					ROR	FPMAN0
   485 					LSR
   486 					BCS	FMULNEXTTST
   487 					TAY
   488 					LDA	FP2MAN0
   489 					ADC	FPMAN0
   490 					STA	FPMAN0
   491 					LDA	FP2MAN1
   492 					ADC	FPMAN1
   493 					STA	FPMAN1
   494 					LDA	FP2MAN2
   495 					ADC	FPMAN2
   496 					STA	FPMAN2
   497 					LDA	#$00
   498 					ADC	FPMAN3
   499 					STA	FPMAN3
   500 					TYA
   501 8952			FMULNEXTTST:	DEX
   502 					BNE	FMULTSTBITS
   503 					INC	TMP
   504 					LDX	TMP
   505 					CPX	#$03
   506 					BNE	FMULNEXTBYTE
   507
   508 					ldx @rx
   509 					LDA	FPMAN3
   510 					JMP	FPNORM
   511 				.endp
   512
   513
   514 8952			.proc	FDIV
   515
   516 					stx @rx
   517
   518 					lda :STACKORIGIN,x
   519 					STA	FP2MAN0
   520 					lda :STACKORIGIN+STACKWIDTH,x
   521 					STA	FP2MAN1
   522 					lda :STACKORIGIN+STACKWIDTH*2,x
   523 					CMP	#$80		; SET CARRY FROM MSB
   524 					ORA	#$80		; SET HIDDEN BIT
   525 					STA	FP2MAN2
   526 					lda :STACKORIGIN+STACKWIDTH*3,x
   527 					ROL
   528 					STA	FP2EXP
   529 					BNE	@+
   530
   531 				;	LDA	#$00
   532 8952			ZERO:	STA :STACKORIGIN-1,x
   533 					STA :STACKORIGIN-1+STACKWIDTH,x
   534 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   535 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   536 					rts
   537 				;	LDA	#23		; DIVIDE BY ZERO, ERROR
   538 				;	JMP	SYSTHROW
   539
   540 8952			@	LDA	#$00
   541 					ROR
   542 					STA	FPSGN
   543 					lda :STACKORIGIN-1,x
   544 					STA	FP1MAN0
   545 					lda :STACKORIGIN-1+STACKWIDTH,x
   546 					STA	FP1MAN1
   547 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   548 					CMP	#$80		; SET CARRY FROM MSB
   549 					ORA	#$80		; SET HIDDEN BIT
   550 					STA	FP1MAN2
   551 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   552 					ROL
   553 					STA	FP1EXP
   554 					BEQ	ZERO		; DIVIDE ZERO, RESULT ZERO
   555
   556 					LDA	#$00
   557 					STA	FP1MAN3
   558 					ROR
   559 					EOR	FPSGN
   560 					STA	FPSGN
   561 					LDA	FP1EXP
   562 					SEC			; SUBTRACT EXPONENTS
   563 					SBC	FP2EXP
   564 					CLC
   565 					ADC	#$7F		; ADD BACK BIAS
   566 					STA	FPEXP
   567
   568 					LDX	#24		; #BITS
   569 8952			FDIVLOOP:	LDA	FP1MAN0
   570 					SEC
   571 					SBC	FP2MAN0
   572 					STA	TMP
   573 					LDA	FP1MAN1
   574 					SBC	FP2MAN1
   575 					STA	TMP+1
   576 					LDA	FP1MAN2
   577 					SBC	FP2MAN2
   578 					TAY
   579 					LDA	FP1MAN3
   580 					SBC	#$00
   581 					BCC	FDIVNEXTBIT
   582 					STA	FP1MAN3
   583 					STY	FP1MAN2
   584 					LDA	TMP+1
   585 					STA	FP1MAN1
   586 					LDA	TMP
   587 					STA	FP1MAN0
   588 8952			FDIVNEXTBIT:	ROL	FPMAN0
   589 					ROL	FPMAN1
   590 					ROL	FPMAN2
   591 					ASL	FP1MAN0
   592 					ROL	FP1MAN1
   593 					ROL	FP1MAN2
   594 					ROL	FP1MAN3
   595 					DEX
   596 					BNE	FDIVLOOP
   597
   598 					ldx @rx
   599 					LDA	#$00
   600 					JMP	FPNORM
   601 				.endp
   602
   603
   604 8952			.proc	FCMPL
   605 8952			FCMPG:
   606 					CLV
   607
   608 					LDA	:STACKORIGIN+STACKWIDTH*3,X	; COMPARE SIGNS
   609 					AND	#$80
   610 					STA	FP2SGN
   611 					LDA	:STACKORIGIN-1+STACKWIDTH*3,X
   612 					AND	#$80
   613 					CMP	FP2SGN
   614 					BCC	FCMPGTSGN
   615 					BEQ	@+
   616 					BCS	FCMPLTSGN
   617 8952			@	LDA	:STACKORIGIN-1+STACKWIDTH*3,X	; COMPARE AS MAGNITUDE
   618 					CMP	:STACKORIGIN+STACKWIDTH*3,X
   619 					BCC	FCMPLT
   620 					BEQ	@+
   621 					BCS	FCMPGT
   622 8952			@	LDA	:STACKORIGIN-1+STACKWIDTH*2,X
   623 					CMP	:STACKORIGIN+STACKWIDTH*2,X
   624 					BCC	FCMPLT
   625 					BEQ	@+
   626 					BCS	FCMPGT
   627 8952			@	LDA	:STACKORIGIN-1+STACKWIDTH,X
   628 					CMP	:STACKORIGIN+STACKWIDTH,X
   629 					BCC	FCMPLT
   630 					BEQ	@+
   631 					BCS	FCMPGT
   632 8952			@	LDA	:STACKORIGIN-1,X
   633 					CMP	:STACKORIGIN,X
   634 					BCC	FCMPLT
   635 					BEQ	FCMPEQ
   636 					BCS	FCMPGT
   637 8952			FCMPEQ:	LDA #0			; EQUAL
   638 					RTS
   639
   640 8952			FCMPGT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   641 					BMI	FCMPLTSGN
   642 8952			FCMPGTSGN:	LDA	#$01	; GREATER THAN
   643 					RTS
   644
   645 8952			FCMPLT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   646 					BMI	FCMPGTSGN
   647 8952			FCMPLTSGN:	LDA	#$FF	; LESS THAN
   648 					RTS
   649 				.endp
   650
   651
   652 8952			.proc	F2I
   653
   654 					lda :STACKORIGIN,x
   655 					STA	FPMAN0
   656 					lda :STACKORIGIN+STACKWIDTH,x
   657 					STA	FPMAN1
   658 					lda :STACKORIGIN+STACKWIDTH*2,x
   659 					CMP	#$80		; SET CARRY FROM MSB
   660 					ORA	#$80		; SET HIDDEN BIT
   661 					STA	FPMAN2
   662 					lda :STACKORIGIN+STACKWIDTH*3,x
   663 					ROL	@
   664 					STA	FPEXP
   665 					LDA	#$00
   666 					ROR	@
   667 					STA	FPSGN
   668 					LDA	FPEXP		; CHECK FOR LESS THAN ONE
   669 					SEC
   670 					SBC	#$7F
   671 					BCS	@+
   672
   673 8952			ZERO:	LDA	#$00		; RETURN ZERO
   674 					STA :STACKORIGIN,x
   675 					STA :STACKORIGIN+STACKWIDTH,x
   676 					STA :STACKORIGIN+STACKWIDTH*2,x
   677 					STA :STACKORIGIN+STACKWIDTH*3,x
   678 					rts
   679
   680 8952			@	CMP	#23
   681 					BCS	F2ISHL
   682 					STA	FPEXP
   683 					LDA	#23
   684 					SEC
   685 					SBC	FPEXP
   686 					TAY			; SHIFT MANTISSA RIGHT
   687 					LDA	FPMAN2
   688 8952			F2ISHR:	LSR	@
   689 					ROR	FPMAN1
   690 					ROR	FPMAN0
   691 					DEY
   692 					BNE	F2ISHR
   693 					STA	FPMAN2
   694 					STY	FPMAN3
   695 8952			F2ICHKNEG:	LDA	FPSGN
   696 					BPL	@+		; CHECK FOR NEGATIVE
   697 					ASL	@		; LDA #$00; SEC
   698
   699 					JSR	NEGINT.enter
   700
   701 8952			@	LDA	FPMAN3
   702 					STA :STACKORIGIN+STACKWIDTH*3,x
   703 					LDA	FPMAN2
   704 					STA :STACKORIGIN+STACKWIDTH*2,x
   705 					LDA	FPMAN1
   706 					STA :STACKORIGIN+STACKWIDTH,x
   707 					LDA	FPMAN0
   708 					STA :STACKORIGIN,x
   709 					rts
   710
   711 8952			F2ISHL:	CMP	#32
   712 					BCC	@+
   713 					LDA	#$FF		; OVERFLOW, STORE MAXINT
   714 					STA	FPMAN0
   715 					STA	FPMAN1
   716 					STA	FPMAN2
   717 					LSR	@
   718 					STA	FPMAN3
   719 					BNE	F2ICHKNEG
   720 8952			@	SEC
   721 					SBC	#23
   722 					BNE	@+
   723 					STA	FPMAN3
   724 					BEQ	F2ICHKNEG
   725 8952			@	TAY			; SHIFT MANTISSA LEFT
   726 					LDA	#$00
   727 8952			@	ASL	FPMAN0
   728 					ROL	FPMAN1
   729 					ROL	FPMAN2
   730 					ROL	@
   731 					DEY
   732 					BNE	@-
   733 					STA	FPMAN3
   734 					BEQ	F2ICHKNEG
   735 				.endp
   736
   737
   738 8952			.proc	I2F
   739
   740 					lda :STACKORIGIN,x
   741 					STA	FPMAN0
   742 					lda :STACKORIGIN+STACKWIDTH,x
   743 					STA	FPMAN1
   744 					lda :STACKORIGIN+STACKWIDTH*2,x
   745 					STA	FPMAN2
   746 					lda :STACKORIGIN+STACKWIDTH*3,x
   747 					STA	FPMAN3
   748 					AND	#$80
   749 					STA	FPSGN
   750 					BPL	@+
   751 				;	LDX	#FPMAN0
   752 					JSR	NEGINT
   753 8952			@	LDA	#$7F+23
   754 					STA	FPEXP
   755
   756 					inx			; ten zabieg zapisze pod :STACKORIGIN,x
   757 								; zamiast :STACKORIGIN-1,x
   758 					LDA	FPMAN3
   759 					JSR	FPNORM
   760
   761 					dex
   762 					rts
   763 				.endp
   764
   765
   766 8952			.proc	I2F_m
   767
   768 					lda :STACKORIGIN-1,x
   769 					STA	FPMAN0
   770 					lda :STACKORIGIN-1+STACKWIDTH,x
   771 					STA	FPMAN1
   772 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   773 					STA	FPMAN2
   774 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   775
   776 					STA	FPMAN3
   777 					AND	#$80
   778 					STA	FPSGN
   779 					BPL	@+
   780 				;	LDX	#FPMAN0
   781 					JSR	NEGINT
   782 8952			@	LDA	#$7F+23
   783 					STA	FPEXP
   784
   785 					LDA	FPMAN3
   786 					JMP	FPNORM
   787 				.endp
  1255
  1256
  1257 8952			.proc	@printCHAR
  1258 					ldy :STACKORIGIN,x
  1259 					jmp @print
  1260 				.endp
  1261
  1262
  1263 8952			.proc	@printEOL
  1264 					ldy #eol
  1265 					jmp @print
  1266 				.endp
  1267
  1268
  1269 8952			.proc	@print (.byte y) .reg
  1270 8952 8A 48			txa:pha
  1271
  1272 8954 98				tya
  1273 8955 20 26 8A			jsr @putchar
  1274
  1275 8958 68 AA			pla:tax
  1276 895A 60				rts
  1277 				.endp
  1278
  1279
  1280 895B			.proc	@printPCHAR (.word ya) .reg
  1281 					sta addr
  1282 					sty addr+1
  1283
  1284 					stx @sp
  1285
  1286 					lda #0
  1287 					sta loop+1
  1288
  1289 895B			loop	ldy #0
  1290 					lda $ffff,y
  1291 895B			addr	equ *-2
  1292 					beq stop
  1293
  1294 					inc loop+1
  1295 					beq stop
  1296
  1297 					jsr @putchar
  1298
  1299 					jmp loop
  1300
  1301 895B			stop	ldx #0
  1302 895B			@sp	equ *-1
  1303 					rts
  1304 				.endp
  1305
  1306
  1307 895B			.proc	@printSTRING (.word ya) .reg
  1308 					sta ztmp
  1309 					sty ztmp+1
  1310
  1311 					stx @sp
  1312
  1313 					ldy #0
  1314 					sty loop+1
  1315 					lda (ztmp),y
  1316 					sta ln
  1317
  1318 					inw ztmp
  1319
  1320 895B			loop	ldy #0
  1321 					lda (ztmp),y
  1322 				;	beq stop
  1323
  1324 					cpy #0
  1325 895B			ln	equ *-1
  1326 					beq stop
  1327
  1328 					inc loop+1
  1329
  1330 					jsr @putchar
  1331
  1332 					jmp loop
  1333
  1334 895B			stop	ldx #0
  1335 895B			@sp	equ *-1
  1336 					rts
  1337 				.endp
  1338
  1339
  1340 895B			.proc	@printBOOLEAN
  1341 					lda :STACKORIGIN,x
  1342 					beq _0
  1343
  1344 895B			_1	lda <_true
  1345 					ldy >_true
  1346 					jmp @printSTRING
  1347
  1348 895B			_0	lda <_false
  1349 					ldy >_false
  1350 					jmp @printSTRING
  1351
  1352 895B			_true	dta 4,c'TRUE'
  1353 895B			_false	dta 5,c'FALSE'
  1354 				.endp
  1355
  1356
  1357 895B			.proc	mov_BYTE_DX
  1358 					mva :STACKORIGIN,x dx
  1359 					mva #$00 dx+1
  1360 					sta dx+2
  1361 					sta dx+3
  1362
  1363 					rts
  1364 				.endp
  1365
  1366 895B			.proc	mov_WORD_DX
  1367 					mva :STACKORIGIN,x dx
  1368 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1369 					mva #$00 dx+2
  1370 					sta dx+3
  1371
  1372 					rts
  1373 				.endp
  1374
  1375 895B			.proc	mov_CARD_DX
  1376 895B BD 00 2C 85 A6		mva :STACKORIGIN,x dx
  1377 8960 BD 10 2C 85 A7		mva :STACKORIGIN+STACKWIDTH,x dx+1
  1378 8965 BD 20 2C 85 A8		mva :STACKORIGIN+STACKWIDTH*2,x dx+2
  1379 896A BD 30 2C 85 A9		mva :STACKORIGIN+STACKWIDTH*3,x dx+3
  1380
  1381 896F 60				rts
  1382 				.endp
  1383
  1384
  1385 8970			.proc	@printMINUS
  1386 8970 A0 2D			ldy #'-'
  1387 8972 20 DF 89			jsr @printVALUE.pout
  1388
  1389 8975 4C 1D 89			jmp negCARD
  1390 				.endp
  1391
  1392
  1393 8978			.proc	@printSHORTREAL
  1394 					jsr @expandToCARD.SMALL
  1395 					jmp @printREAL
  1396 				.endp
  1397
  1398
  1399 8978			.proc	@FTOA
  1400
  1401 = 00A6			i	= edx
  1402 = 00AA			fra	= ecx
  1403 = 00A2			hlp	= eax
  1404
  1405 = 00B2			exp	= ztmp
  1406 = 00B3			b	= ztmp+1
  1407 = 00B4			sht	= ztmp+2
  1408
  1409 = 0440			bit	= @buf+64
  1410
  1411 					stx @sp
  1412
  1413 					mva :STACKORIGIN,x I
  1414 					sta :STACKORIGIN+9
  1415 					mva :STACKORIGIN+STACKWIDTH,x I+1
  1416 					sta :STACKORIGIN+STACKWIDTH+9
  1417 					mva :STACKORIGIN+STACKWIDTH*2,x I+2
  1418 					sta :STACKORIGIN+STACKWIDTH*2+9
  1419 					mva :STACKORIGIN+STACKWIDTH*3,x I+3
  1420 					sta :STACKORIGIN+STACKWIDTH*3+9	; Sign
  1421
  1422 					bpl skp
  1423
  1424 					ldy #'-'
  1425 					jsr @printVALUE.pout
  1426
  1427 8978			skp
  1428 				; optimize OK (test_3.pas), line = 32
  1429
  1430 					lda :STACKORIGIN+STACKWIDTH*3+9
  1431 					asl :STACKORIGIN+9
  1432 					rol :STACKORIGIN+STACKWIDTH+9
  1433 					rol :STACKORIGIN+STACKWIDTH*2+9
  1434 					rol @
  1435 					sta EXP				; Exponent
  1436
  1437 				; optimize OK (test_3.pas), line = 33
  1438
  1439 					lda I
  1440 					sta FRA
  1441 					lda I+1
  1442 					sta FRA+1
  1443 					lda I+2
  1444 					sta FRA+2
  1445 					lda I+3
  1446 					sta FRA+3
  1447 					asl FRA
  1448 					rol FRA+1
  1449 					rol FRA+2
  1450 					rol FRA+3
  1451
  1452 				; optimize OK (test_3.pas), line = 35
  1453
  1454 					lda EXP
  1455 					sub #$7F
  1456 					sta SHT
  1457
  1458 				; optimize OK (test_3.pas), line = 37
  1459
  1460 					ldx #$3f
  1461 					lda #0
  1462 					sta:rpl bit,x-
  1463
  1464 				; For
  1465
  1466 				; optimize OK (test_3.pas), line = 39
  1467
  1468 				;	sta B
  1469 					tax
  1470
  1471 				; optimize OK (test_3.pas), line = 39
  1472
  1473 8978			l_01D4
  1474 				;	lda B
  1475 				;	cmp #$17
  1476 					cpx #$17
  1477 					bcc *+7
  1478 					beq *+5
  1479
  1480 				; ForToDoProlog
  1481 					jmp l_01EE
  1482
  1483 				; optimize OK (test_3.pas), line = 40
  1484
  1485 				;	lda #$20
  1486 				;	add B
  1487 				;	tax
  1488
  1489 					lda FRA+2
  1490 					sta BIT+$20,x
  1491
  1492 				; optimize OK (test_3.pas), line = 41
  1493
  1494 					asl FRA
  1495 					rol FRA+1
  1496 					rol FRA+2
  1497 					rol FRA+3
  1498
  1499 				; ForToDoEpilog
  1500 8978			c_01D4
  1501 				;	inc B
  1502 					inx
  1503
  1504 					seq
  1505
  1506 				; WhileDoEpilog
  1507 					jmp l_01D4
  1508 8978			l_01EE
  1509 8978			b_01D4
  1510
  1511 				; optimize OK (test_3.pas), line = 44
  1512
  1513 					mva #$80 BIT+$1f
  1514
  1515 				; optimize OK (test_3.pas), line = 46
  1516
  1517 					mva #$00 I
  1518 					sta I+1
  1519 					sta I+2
  1520 					sta I+3
  1521
  1522 				; optimize OK (test_3.pas), line = 47
  1523
  1524 					sta FRA+1
  1525 					sta FRA+2
  1526 					sta FRA+3
  1527
  1528 					mva #$01 FRA
  1529
  1530 				; For
  1531
  1532 				; optimize OK (test_3.pas), line = 49
  1533
  1534 					lda SHT
  1535 					add #$1F
  1536 					sta B
  1537
  1538 				; optimize OK (test_3.pas), line = 49
  1539
  1540 					tay
  1541
  1542 8978			l_035B
  1543 				;	lda B
  1544 				;	cmp #$00
  1545 				;	bcs *+5
  1546
  1547 				; ForToDoProlog
  1548 				;	jmp l_0375
  1549
  1550 				; optimize OK (test_3.pas), line = 50
  1551
  1552 				;	ldy B
  1553 					lda BIT,y
  1554 					bpl l_03D7
  1555
  1556 				; optimize OK (test_3.pas), line = 50
  1557
  1558 					lda I				; Mantissa
  1559 					add FRA
  1560 					sta I
  1561 					lda I+1
  1562 					adc FRA+1
  1563 					sta I+1
  1564 					lda I+2
  1565 					adc FRA+2
  1566 					sta I+2
  1567 					lda I+3
  1568 					adc FRA+3
  1569 					sta I+3
  1570
  1571 				; IfThenEpilog
  1572 8978			l_03D7
  1573
  1574 				; optimize OK (test_3.pas), line = 52
  1575
  1576 					asl FRA
  1577 					rol FRA+1
  1578 					rol FRA+2
  1579 					rol FRA+3
  1580
  1581 				; ForToDoEpilog
  1582 8978			c_035B
  1583 				;	dec B
  1584 					dey
  1585
  1586 				;	lda B
  1587 				;	cmp #$ff
  1588 					cpy #$ff
  1589 					seq
  1590
  1591 				; WhileDoEpilog
  1592 					jmp l_035B
  1593 8978			l_0375
  1594 8978			b_035B
  1595
  1596 				; optimize OK (test_3.pas), line = 55
  1597
  1598 					mva #$00 FRA
  1599 					sta FRA+1
  1600 					sta FRA+2
  1601 					sta FRA+3
  1602
  1603 				; optimize OK (test_3.pas), line = 56
  1604
  1605 					sta EXP
  1606
  1607 					sta hlp
  1608 					sta hlp+1
  1609
  1610 					lda #$80
  1611 					sta hlp+2
  1612 				; For
  1613
  1614 				; optimize OK (test_3.pas), line = 58
  1615
  1616 					lda SHT
  1617 					add #$20
  1618 				;	sta B
  1619
  1620 					tay
  1621
  1622 				; optimize OK (test_3.pas), line = 58
  1623
  1624 					add #23
  1625 					sta FORTMP_1273
  1626 				; To
  1627 8978			l_0508
  1628
  1629 				; ForToDoCondition
  1630
  1631 				; optimize OK (test_3.pas), line = 58
  1632
  1633 				;	lda B
  1634 				;	cmp #0
  1635 					cpy #0
  1636 8978			FORTMP_1273	equ *-1
  1637 					bcc *+7
  1638 					beq *+5
  1639
  1640 				; ForToDoProlog
  1641 					jmp l_0534
  1642
  1643 				; optimize OK (test_3.pas), line = 59
  1644
  1645 				;	ldy B
  1646 					lda BIT,y
  1647 					bpl l_0596
  1648
  1649 				; optimize OK (test_3.pas), line = 59
  1650
  1651 					lda FRA
  1652 					add hlp
  1653 					sta FRA
  1654 					lda FRA+1
  1655 					adc hlp+1
  1656 					sta FRA+1
  1657 					lda FRA+2
  1658 					adc hlp+2
  1659 					sta FRA+2
  1660
  1661 				; IfThenEpilog
  1662 8978			l_0596
  1663
  1664 					lsr hlp+2
  1665 					ror hlp+1
  1666 					ror hlp
  1667
  1668 				; ForToDoEpilog
  1669 8978			c_0508
  1670 				;	inc B						; inc ptr byte [CounterAddress]
  1671 					iny
  1672
  1673 					seq
  1674
  1675 				; WhileDoEpilog
  1676 					jmp l_0508
  1677 8978			l_0534
  1678 8978			b_0508
  1679 8978				:3 mva fra+# fracpart+#
  1680
  1681 					mva #6 @float.afterpoint	; wymagana liczba miejsc po przecinku
  1682 					@float #500000
  1683
  1684 					ldx #0
  1685 8978			@sp	equ *-1
  1686
  1687 					rts
  1688 				.endp
  1689
  1690
  1691 8978			.proc	@printREAL
  1692
  1693 					stx @sp
  1694
  1695 					lda :STACKORIGIN+STACKWIDTH*3,x
  1696 					spl
  1697 					jsr @printMINUS
  1698
  1699 					jsr mov_CARD_DX
  1700
  1701 					mva dx+1 intpart		; intpart := uvalue shr 8
  1702 					mva dx+2 intpart+1
  1703 					mva dx+3 intpart+2
  1704 					mva #$00 intpart+3
  1705
  1706 					sta dx+3			; fracpart := uvalue and $FF (dx)
  1707 					sta dx+2
  1708 					sta dx+1
  1709
  1710 					sta fracpart
  1711 					sta fracpart+1
  1712
  1713 					lda dx
  1714 					sta fracpart+2
  1715
  1716 8978				:4 mva intpart+# dx+#		; integer part
  1717
  1718 					mva #4 @float.afterpoint		; wymagana liczba miejsc po przecinku
  1719 					@float #5000
  1720
  1721 					ldx #0
  1722 8978			@sp	equ *-1
  1723 					rts
  1724
  1725 8978 00 00 00 00		intpart		.dword
  1726
  1727 				.endp
  1728
  1729
  1730 897C			.proc	@float (.long axy) .reg
  1731
  1732 					sty cx
  1733 					stx cx+1
  1734 					sta cx+2
  1735
  1736 					lda @printVALUE.pout		; print integer part
  1737 					pha
  1738 					jsr @printVALUE
  1739 					pla
  1740 					sta @printVALUE.pout
  1741
  1742 					lda #0
  1743 					sta dx
  1744 					sta dx+1
  1745 					sta dx+2
  1746 					sta dx+3
  1747
  1748 897C			loop	lda fracpart+2
  1749 					bpl skp
  1750
  1751 					clc
  1752 				;	lda cx
  1753 				;	spl
  1754 				;	sec
  1755
  1756 					lda dx
  1757 					adc cx
  1758 					sta dx
  1759 					lda dx+1
  1760 					adc cx+1
  1761 					sta dx+1
  1762 					lda dx+2
  1763 					adc cx+2
  1764 					sta dx+2
  1765 				;	lda dx+3
  1766 				;	adc #0
  1767 				;	sta dx+3
  1768
  1769 897C			skp	lsr cx+2
  1770 					ror cx+1
  1771 					ror cx
  1772
  1773 					asl fracpart
  1774 					rol fracpart+1
  1775 					rol fracpart+2
  1776
  1777 					lda cx
  1778 					ora cx+1
  1779 					ora cx+2
  1780
  1781 					bne loop
  1782
  1783 					ldy #'.'
  1784 					jsr @printVALUE.pout
  1785
  1786 897C				:4 mva dx+# fracpart+#
  1787
  1788 					lda @printVALUE.pout
  1789 					pha
  1790
  1791 					lda #{rts}
  1792 					sta @printVALUE.pout
  1793 					jsr @printVALUE			; floating part length
  1794
  1795 					sta cnt
  1796
  1797 					pla
  1798 					sta @printVALUE.pout
  1799
  1800 897C			lp	lda #0
  1801 897C			cnt	equ *-1
  1802 					cmp #4				; N miejsc po przecinku
  1803 897C			afterpoint equ *-1
  1804 					bcs ok
  1805
  1806 					ldy #'0'
  1807 					jsr @printVALUE.pout
  1808
  1809 					inc cnt
  1810 					bne lp
  1811
  1812 897C			ok	:4 mva fracpart+# dx+#
  1813 					jmp @printVALUE			; print floating part
  1814
  1815 				.endp
  1816
  1817
  1818 897C			.proc	@printSHORTINT
  1819
  1820 					lda :STACKORIGIN,x
  1821 					spl
  1822 					jsr @printMINUS
  1823
  1824 					jmp @printBYTE
  1825 				.endp
  1826
  1827
  1828 897C			.proc	@printSMALLINT
  1829
  1830 					lda :STACKORIGIN+STACKWIDTH,x
  1831 					spl
  1832 					jsr @printMINUS
  1833
  1834 					jmp @printWORD
  1835 				.endp
  1836
  1837
  1838 897C			.proc	@printINT
  1839
  1840 897C BD 30 2C			lda :STACKORIGIN+STACKWIDTH*3,x
  1841 897F 10 03			spl
  1842 8981 20 70 89			jsr @printMINUS
  1843
  1844 8984 4C 87 89			jmp @printCARD
  1845 				.endp
  1846
  1847
  1848 8987			.proc	@printCARD
  1849 8987 20 5B 89			jsr mov_CARD_DX
  1850 898A 4C 8D 89			jmp @printVALUE
  1851 				.endp
  1852
  1853
  1854 898D			.proc	@printWORD
  1855 					jsr mov_WORD_DX
  1856 					jmp @printVALUE
  1857 				.endp
  1858
  1859
  1860 898D			.proc	@printBYTE
  1861 					jsr mov_BYTE_DX
  1862 					jmp @printVALUE
  1863 				.endp
  1864
  1865
  1866 898D			.proc	@printVALUE
  1867
  1868 898D A5 A9			lda dx+3
  1869 898F D0 14			bne _32bit
  1870
  1871 8991 A5 A8			lda dx+2
  1872 8993 D0 0C			bne _24bit
  1873
  1874 8995 A5 A7			lda dx+1
  1875 8997 D0 04			bne _16bit
  1876
  1877 8999 A9 03		_8bit	lda #3
  1878 899B D0 0A			bne l3
  1879
  1880 899D A9 05		_16bit	lda #5
  1881 899F D0 06			bne l3
  1882
  1883 89A1 A9 08		_24bit	lda #8
  1884 89A3 D0 02			bne l3
  1885
  1886 					; prints a 32 bit value to the screen (Graham)
  1887
  1888 89A5 A9 0A		_32bit	lda #10
  1889
  1890 89A7 8D BA 89		l3	sta limit
  1891
  1892 89AA 8E DD 89			stx @sp
  1893
  1894 89AD A2 00			ldx #0
  1895 89AF 8E DB 89			stx cnt
  1896
  1897 89B2 20 F3 89		lp	jsr div10
  1898
  1899 89B5 9D E9 89			sta tmp,x
  1900 89B8 E8				inx
  1901 89B9 E0 0A			cpx #10
  1902 = 89BA			limit	equ *-1
  1903 89BB D0 F5			bne lp
  1904
  1905 					;ldx #9
  1906 89BD CA				dex
  1907
  1908 89BE BD E9 89		l1	lda tmp,x
  1909 89C1 D0 03			bne l2
  1910 89C3 CA				dex		; skip leading zeros
  1911 89C4 D0 F8			bne l1
  1912
  1913 89C6 BD E9 89		l2	lda tmp,x
  1914 89C9 09 30			ora #$30
  1915 89CB A8				tay
  1916
  1917 89CC 20 DF 89			jsr pout
  1918 89CF EE DB 89			inc cnt
  1919
  1920 89D2 CA				dex
  1921 89D3 10 F1			bpl l2
  1922
  1923 89D5 A9 4C 8D DF 89		mva #{jmp*} pout
  1924
  1925 89DA A9 00			lda #0
  1926 = 89DB			cnt	equ *-1
  1927
  1928 89DC A2 00			ldx #0
  1929 = 89DD			@sp	equ *-1
  1930 89DE 60				rts
  1931
  1932 89DF 4C 52 89		pout	jmp @print
  1933
  1934 89E2 8C 01 04			sty @buf+1
  1935 = 89E3			pbuf	equ *-2
  1936 89E5 EE E3 89			inc pbuf
  1937
  1938 89E8 60				rts
  1939
  1940 89E9 00 00 00 00 00 00 + tmp	.byte 0,0,0,0,0,0,0,0,0,0
  1941
  1942 				.endp
  1943
  1944
  1945 				; divides a 32 bit value by 10
  1946 				; remainder is returned in akku
  1947
  1948 89F3			.proc	div10
  1949 89F3 A0 20		        ldy #32		; 32 bits
  1950 89F5 A9 00		        lda #0
  1951 89F7 18			        clc
  1952 89F8 2A			l4      rol @
  1953 89F9 C9 0A		        cmp #10
  1954 89FB 90 02		        bcc skip
  1955 89FD E9 0A		        sbc #10
  1956 89FF 26 A6		skip    rol dx
  1957 8A01 26 A7		        rol dx+1
  1958 8A03 26 A8		        rol dx+2
  1959 8A05 26 A9		        rol dx+3
  1960 8A07 88			        dey
  1961 8A08 10 EE		        bpl l4
  1962
  1963 8A0A 60				rts
  1964 				.endp
  1965
  1966
  1967 8A0B			.proc	@hexStr
  1968
  1969 = 00A6			Value	= edx
  1970 = 00AA			Digits	= ecx
  1971
  1972 					ldx Digits
  1973 					cpx #32
  1974 					scc
  1975 					ldx #32
  1976
  1977 					stx Digits
  1978
  1979 					lda Value
  1980 					jsr hex
  1981 					lda Value+1
  1982 					jsr hex
  1983 					lda Value+2
  1984 					jsr hex
  1985 					lda Value+3
  1986 					jsr hex
  1987
  1988 					lda Digits
  1989 					sta @buf
  1990 					rts
  1991
  1992 8A0B			hex	pha
  1993 					and #$f
  1994 					jsr put
  1995 					pla
  1996 8A0B				:4 lsr @
  1997 8A0B			put	tay
  1998 					lda thex,y
  1999 					sta @buf,x
  2000 					dex
  2001 					rts
  2002
  2003 8A0B			thex	dta c'0123456789ABCDEF'
  2004 				.endp
  2005
  2006
  2007 8A0B			.proc	@ValueToStr (.word ya) .reg
  2008
  2009 8A0B 8D 1C 8A			sta adr
  2010 8A0E 8C 1D 8A			sty adr+1
  2011
  2012 8A11 A9 2C 8D DF 89		mva #{bit*} @printVALUE.pout
  2013 8A16 A9 01 8D E3 89		mva <@buf+1 @printVALUE.pbuf
  2014
  2015 8A1B 20 FF FF			jsr $ffff
  2016 = 8A1C			adr	equ *-2
  2017
  2018 8A1E AC E3 89			ldy @printVALUE.pbuf
  2019 8A21 88				dey
  2020 8A22 8C 00 04			sty @buf
  2021
  2022 8A25 60				rts
  2023 				.endp
  2024
  2025
  2026 				;	ecx	isSign
  2027 				;	edx	Result
  2028
  2029 8A26			.proc	@StrToInt (.word ya) .reg
  2030
  2031 					sta bp2
  2032 					sty bp2+1
  2033
  2034 					ldy #0
  2035 					sty MAIN.SYSTEM.IOResult
  2036 					sty edx
  2037 					sty edx+1
  2038 					sty edx+2
  2039 					sty edx+3
  2040
  2041 					lda (bp2),y
  2042 					beq stop
  2043 					sta len
  2044
  2045 					inw bp2
  2046
  2047 					lda (bp2),y
  2048 					cmp #'-'
  2049 					sne
  2050 					iny
  2051
  2052 					sty ecx
  2053
  2054 8A26			l1	lda (bp2),y
  2055
  2056 					CLC
  2057 					ADC #$FF-'9'	; make m = $FF
  2058 					ADC #'9'-'0'+1	; carry set if in range n to m
  2059 					bcs ok
  2060
  2061 					lda #106	; Invalid numeric format
  2062 					sta MAIN.SYSTEM.IOResult
  2063
  2064 					rts		; reg Y contains the index of the character in S which prevented the conversion
  2065
  2066 8A26			ok	jsr fmul10
  2067
  2068 					lda (bp2),y
  2069 					sub #$30
  2070 					sta ztmp
  2071
  2072 					lda #$00
  2073 					sta ztmp+1
  2074 					sta ztmp+2
  2075 					sta ztmp+3
  2076
  2077 					jsr fmul10.add32bit
  2078
  2079 					iny
  2080 					cpy #0
  2081 8A26			len	equ *-1
  2082 					bne l1
  2083
  2084 					lda ecx
  2085 					beq stop
  2086
  2087 					jsr negEDX
  2088
  2089 8A26			stop	ldy #0		; reg Y = 0 conversion successful
  2090 					rts
  2091 				.endp
  2092
  2093
  2094 8A26			.proc	negEDX
  2095 					lda #$00	; minus
  2096 					sub edx
  2097 					sta edx
  2098
  2099 					lda #$00
  2100 					sbc edx+1
  2101 					sta edx+1
  2102
  2103 					lda #$00
  2104 					sbc edx+2
  2105 					sta edx+2
  2106
  2107 					lda #$00
  2108 					sbc edx+3
  2109 					sta edx+3
  2110
  2111 					rts
  2112 				.endp
  2113
  2114
  2115 8A26			.proc	fmul10
  2116 					asl edx		;multiply by 2
  2117 					rol edx+1	;temp store in ZTMP
  2118 					rol edx+2
  2119 					rol edx+3
  2120
  2121 					lda edx
  2122 					sta ztmp
  2123 					lda edx+1
  2124 					sta ztmp+1
  2125 					lda edx+2
  2126 					sta ztmp+2
  2127 					lda edx+3
  2128 					sta ztmp+3
  2129
  2130 					asl edx
  2131 					rol edx+1
  2132 					rol edx+2
  2133 					rol edx+3
  2134
  2135 					asl edx
  2136 					rol edx+1
  2137 					rol edx+2
  2138 					rol edx+3
  2139
  2140 8A26			add32bit
  2141 					lda edx
  2142 					add ztmp
  2143 					sta edx
  2144 					lda edx+1
  2145 					adc ztmp+1
  2146 					sta edx+1
  2147 					lda edx+2
  2148 					adc ztmp+2
  2149 					sta edx+2
  2150 					lda edx+3
  2151 					adc ztmp+3
  2152 					sta edx+3
  2153
  2154 					rts
  2155 				.endp
  2156
  2157
  2158 8A26			.proc	@trunc
  2159
  2160 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2161 					spl
  2162 					jsr negCARD
  2163
  2164 					mva :STACKORIGIN+STACKWIDTH,x :STACKORIGIN,x
  2165 					mva :STACKORIGIN+STACKWIDTH*2,x :STACKORIGIN+STACKWIDTH,x
  2166 					mva :STACKORIGIN+STACKWIDTH*3,x :STACKORIGIN+STACKWIDTH*2,x
  2167 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2168
  2169 					tya
  2170 					spl
  2171 					jsr negCARD
  2172
  2173 					rts
  2174 				.endp
  2175
  2176
  2177 8A26			.proc	@round
  2178
  2179 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2180 					spl
  2181 					jsr negCARD
  2182
  2183 					lda :STACKORIGIN,x
  2184 				//	add #$80
  2185 					cmp #$80
  2186 					lda :STACKORIGIN+STACKWIDTH,x
  2187 					adc #0
  2188 					sta :STACKORIGIN,x
  2189 					lda :STACKORIGIN+STACKWIDTH*2,x
  2190 					adc #0
  2191 					sta :STACKORIGIN+STACKWIDTH,x
  2192 					lda :STACKORIGIN+STACKWIDTH*3,x
  2193 					adc #0
  2194 					sta :STACKORIGIN+STACKWIDTH*2,x
  2195
  2196 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2197
  2198 					tya
  2199 					spl
  2200 					jsr negCARD
  2201
  2202 					rts
  2203 				.endp
  2204
  2205
  2206 8A26			.proc	@frac
  2207
  2208 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2209 					spl
  2210 					jsr negCARD
  2211
  2212 					lda #$00
  2213 					sta :STACKORIGIN+STACKWIDTH,x
  2214 					sta :STACKORIGIN+STACKWIDTH*2,x
  2215 					sta :STACKORIGIN+STACKWIDTH*3,x
  2216
  2217 					tya
  2218 					spl
  2219 					jsr negCARD
  2220
  2221 					rts
  2222 				.endp
  2223
  2224
  2225 8A26			.proc	@int
  2226
  2227 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2228 					spl
  2229 					jsr negCARD
  2230
  2231 					lda #$00
  2232 					sta :STACKORIGIN,x
  2233
  2234 					tya
  2235 					spl
  2236 					jsr negCARD
  2237
  2238 					rts
  2239 				.endp
  2240
  2241
  2242 				;----------------------------;
  2243 				; Biblioteka procedur        ;
  2244 				; graficznych                ;
  2245 				;----------------------------;
  2246 				; Autorzy:                   ;
  2247 				;  Slawomir 'SERO' Ritter,   ;
  2248 				;  Jakub Cebula,             ;
  2249 				;  Winfried Hofacker         ;
  2250 				;----------------------------;
  2251 				; Wersja:1.1 DATA:09.01.2008 ;
  2252 				;----------------------------;
  2253
  2254 = 0003			@open	= $03		; Otworz kanal
  2255 = 000C			@close	= $0c		; Zamknij kanal
  2256
  2257 = 0007			@IDget	= $07		; Narysuj punkt
  2258 = 0009			@IDput	= $09		; Narysuj punkt
  2259 = 0011			@IDdraw	= $11		; Narysuj linie
  2260 = 0012			@IDfill	= $12		; Wypelnij obszar
  2261
  2262
  2263 				;------------------------;
  2264 				;Wy:.Y-numer bledu (1-OK);
  2265 				;   f(N)=1-wystapil blad ;
  2266 				;------------------------;
  2267 8A26			.proc	@COMMAND
  2268
  2269 					ldx	#$00
  2270 8A26			scrchn	equ *-1
  2271
  2272 					sta	iocom,x
  2273
  2274 					lda	#$00
  2275 8A26			colscr	equ *-1
  2276 					sta	atachr
  2277
  2278 					jmp	ciov
  2279 				.endp
  2280
  2281 				;------------------------;
  2282 				; Ustaw tryb ekranu      ;
  2283 				;------------------------;
  2284 				;We:.X-numer kanalu      ;
  2285 				;      (normalnie 0)     ;
  2286 				;   .Y-numer trybu (O.S.);
  2287 				;   .A-Ustawiony bit nr :;
  2288 				;     5-Nie kasowanie    ;
  2289 				;       pamieci ekranu   ;
  2290 				;     4-Obecnosc okna    ;
  2291 				;       tekstowego       ;
  2292 				;     2-Odczyt z ekranu  ;
  2293 				;------------------------;
  2294 				;Wy:SCRCHN-numer kanalu  ;
  2295 				;  .Y-numer bledu (1-OK) ;
  2296 				;   f(N)=1 wystapil blad ;
  2297 				;------------------------;
  2298 8A26			@GRAPHICS .proc (.byte x,y,a) .reg
  2299
  2300 					sta	byte1
  2301 					sty	byte2
  2302
  2303 					stx	@COMMAND.scrchn
  2304
  2305 					lda	#@close
  2306 					jsr	xcio
  2307
  2308 					lda	#0		; =opcje
  2309 8A26			byte1	equ	*-1
  2310 					ora	#8		; +zapis na ekranie
  2311 					sta	ioaux1,x
  2312
  2313 					lda	#0
  2314 8A26			byte2	equ	*-1
  2315 					sta	ioaux2,x	;=nr.trybu
  2316
  2317 					mwa	#sname	ioadr,x
  2318
  2319 					lda	#@open
  2320
  2321 8A26			xcio	sta iocom,x
  2322 					jmp ciov
  2323
  2324 8A26			sname	dta c'S:',$9b
  2325
  2326 					.endp
  2327
  2328
  2329 8A26			.proc	@ata2int
  2330 				        asl
  2331 				        php
  2332 				        cmp #2*$60
  2333 				        bcs @+
  2334 				        sbc #2*$20-1
  2335 				        bcs @+
  2336 				        adc #2*$60
  2337 8A26			@       plp
  2338 				        ror
  2339 					rts
  2340 				.endp
  2341
  2342
  2343 				/*
  2344 				  PUT CHAR
  2345
  2346 				  Procedura wyprowadza znak na ekran na pozycji X/Y kursora okreslonej przez zmienne odpowiednio
  2347 				  COLCRS ($55-$56) i ROWCRS ($54). Zaklada sie, ze obowiazuja przy tym domyslne ustawienia OS-u,
  2348 				  to jest ekran jest w trybie Graphics 0, a kanal IOCB 0 jest otwarty dla edytora ekranowego.
  2349
  2350 				  Wyprowadzenie znaku polega na zaladowaniu jego kodu ATASCII do akumulatora i wykonaniu rozkazu
  2351 				  JSR PUTCHR.
  2352 				*/
  2352
  2353
  2354 8A26			.proc	@putchar (.byte a) .reg
  2355
  2356 8A26 2C 26 8A		vbxe	bit *
  2357
  2358 8A29 A2 00			ldx #$00
  2359 					.ifdef MAIN.CRT.TextAttr
  2360 					ora MAIN.CRT.TextAttr
  2361 					.endif
  2362 8A2B A8				tay
  2363 8A2C BD 47 03			lda icputb+1,x
  2364 8A2F 48				pha
  2365 8A30 BD 46 03			lda icputb,x
  2366 8A33 48				pha
  2367 8A34 98				tya
  2368
  2369 8A35 60				rts
  2370
  2371 				.endp
  2372
  2373
  2374 				/*
  2375 				  GETLINE
  2376
  2377 				  Program czeka, az uzytkownik wpisze ciag znak�w z klawiatury i nacisnie klawisz RETURN.
  2378 				  Znaki podczas wpisywania sa wyswietlane na ekranie, dzialaja tez normalne znaki kontrolne
  2379 				  (odczyt jest robiony z edytora ekranowego).
  2380
  2381 				  Wywolanie funkcji polega na zaladowaniu adresu, pod jaki maja byc wpisane znaki,
  2382 				  do rejestr�w A/Y (mlodszy/starszy) i wykonaniu rozkazu JSR GETLINE.
  2383
  2384 				*/
  2384
  2385
  2386 8A36			.proc	@GetLine
  2387
  2388 					stx @sp
  2389
  2390 					ldx #0
  2391
  2392 					stx MAIN.SYSTEM.EoLn
  2393
  2394 					mwa	#@buf+1	icbufa,x
  2395
  2396 					mwa	#$ff	icbufl,x	; maks. wielkosc tekstu
  2397
  2398 					mva	#$05	iccmd,x
  2399
  2400 					jsr	ciov
  2401
  2402 					dew icbufl
  2403 					mva icbufl @buf			; length
  2404
  2405 					ldx @buf+1
  2406 					cpx #EOL
  2407 					bne skp
  2408
  2409 					ldx #TRUE
  2410 					stx MAIN.SYSTEM.EoLn
  2411 8A36			skp
  2412 					ldx #0
  2413 8A36			@sp	equ *-1
  2414
  2415 					rts
  2416 				.endp
  2417
  2418
  2419 8A36			.proc	@GetKey
  2420
  2421 8A36			getk	lda kbcodes	; odczytaj kbcodes
  2422 					cmp #255		; czy jest znak?
  2423 					beq getk	; nie: czekaj
  2424 					ldy #255		; daj zna�, �e klawisz
  2425 					sty kbcodes	; zosta� odebrany
  2426 					tay		; kod klawisza jako indeks
  2427 					lda (keydef),y	; do tablicy w ROM-ie
  2428
  2429 					rts
  2430 				.endp
  2431
  2432
  2433 8A36			.proc	@moveSTRING (.word ya) .reg
  2434
  2435 					sta @move.dst
  2436 					sty @move.dst+1
  2437
  2438 					mva :STACKORIGIN,x @move.src
  2439 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2440
  2441 					ldy #$00
  2442 					lda (@move.src),y
  2443 					add #1
  2444 					sta @move.cnt
  2445 					scc
  2446 					iny
  2447 					sty @move.cnt+1
  2448
  2449 					jmp @move
  2450 				.endp
  2451
  2452
  2453 8A36			.proc	@moveSTRING_1 (.word ya) .reg
  2454
  2455 					sta @move.dst
  2456 					sty @move.dst+1
  2457
  2458 					mva :STACKORIGIN,x @move.src
  2459 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2460
  2461 					ldy #$00
  2462 					lda (@move.src),y
  2463 				;	add #1
  2464 					sta @move.cnt
  2465 					sty @move.cnt+1
  2466
  2467 					inw @move.src
  2468
  2469 					jmp @move
  2470 				.endp
  2471
  2472
  2473 				; Ullrich von Bassewitz, 2003-08-20
  2474 				; Performance increase (about 20%) by
  2475 				; Christian Krueger, 2009-09-13
  2476
  2477 8A36			.proc	@moveu		; assert Y = 0
  2478
  2479 = 00A6			ptr1	= edx
  2480 = 00AA			ptr2	= ecx
  2481 = 00A2			ptr3	= eax
  2482
  2483 8A36 8E 5F 8A			stx @sp
  2484
  2485 8A39 A0 00			ldy	#0
  2486
  2487 8A3B A6 A3			ldx     ptr3+1		; Get high byte of n
  2488 8A3D F0 13			beq     L2		; Jump if zero
  2489
  2490 				L1:     .rept 2		; Unroll this a bit to make it faster...
  2491 					LDA     (PTR1),Y	
  2492 					STA     (PTR2),Y
  2493 					INY
  2494 					.ENDR
  2494 					.endr
Source: REPT
  2491 8A3F B1 A6			LDA     (PTR1),Y	
  2491 8A41 91 AA			STA     (PTR2),Y
  2491 8A43 C8				INY
  2491 8A44 B1 A6			LDA     (PTR1),Y	
  2491 8A46 91 AA			STA     (PTR2),Y
  2491 8A48 C8				INY
Source: cpu6502.asm
  2495
  2496 8A49 D0 F4			bne     L1
  2497 8A4B E6 A7			inc     ptr1+1
  2498 8A4D E6 AB			inc     ptr2+1
  2499 8A4F CA				dex			; Next 256 byte block
  2500 8A50 D0 ED			bne	L1		; Repeat if any
  2501
  2502 					; the following section could be 10% faster if we were able to copy
  2503 					; back to front - unfortunately we are forced to copy strict from
  2504 					; low to high since this function is also used for
  2505 					; memmove and blocks could be overlapping!
  2506 					; {
  2507 8A52			L2:				; assert Y = 0
  2508 8A52 A6 A2			ldx     ptr3		; Get the low byte of n
  2509 8A54 F0 08			beq     done		; something to copy
  2510
  2511 8A56 B1 A6		L3:     lda     (ptr1),Y	; copy a byte
  2512 8A58 91 AA			sta     (ptr2),Y
  2513 8A5A C8				iny
  2514 8A5B CA				dex
  2515 8A5C D0 F8			bne     L3
  2516
  2517 					; }
  2518
  2519 8A5E A2 00		done	ldx #0
  2520 = 8A5F			@sp	equ *-1
  2521 8A60 60				rts
  2522 				.endp
  2523
  2524
  2525 8A61			@move	.proc (.word ptr1, ptr2, ptr3) .var
  2526
  2527 = 00A6			ptr1	= edx
  2528 = 00AA			ptr2	= ecx
  2529 = 00A2			ptr3	= eax
  2530
  2531 = 00A6			src	= ptr1
  2532 = 00AA			dst	= ptr2
  2533 = 00A2			cnt	= ptr3
  2534
  2535 8A61 A5 AB C5 A7 D0 04 + 	cpw ptr2 ptr1
  2536 8A6B B0 03			scs
  2537 8A6D 4C 36 8A			jmp @moveu
  2538
  2539 8A70 8E B4 8A			stx @sp
  2540
  2541 				; Copy downwards. Adjust the pointers to the end of the memory regions.
  2542
  2543 8A73 A5 A7			lda     ptr1+1
  2544 8A75 18 65 A3			add     ptr3+1
  2545 8A78 85 A7			sta     ptr1+1
  2546
  2547 8A7A A5 AB			lda     ptr2+1
  2548 8A7C 18 65 A3			add     ptr3+1
  2549 8A7F 85 AB			sta     ptr2+1
  2550
  2551 				; handle fractions of a page size first
  2552
  2553 8A81 A4 A2			ldy     ptr3		; count, low byte
  2554 8A83 D0 06			bne     @entry		; something to copy?
  2555 8A85 F0 0B			beq     PageSizeCopy	; here like bra...
  2556
  2557 8A87			@copyByte:
  2558 8A87 B1 A6			lda     (ptr1),y
  2559 8A89 91 AA			sta     (ptr2),y
  2560 8A8B			@entry:
  2561 8A8B 88				dey
  2562 8A8C D0 F9			bne     @copyByte
  2563 8A8E B1 A6			lda     (ptr1),y	; copy remaining byte
  2564 8A90 91 AA			sta     (ptr2),y
  2565
  2566 8A92			PageSizeCopy:			; assert Y = 0
  2567 8A92 A6 A3			ldx     ptr3+1		; number of pages
  2568 8A94 F0 1D			beq     done		; none? -> done
  2569
  2570 8A96			@initBase:
  2571 8A96 C6 A7			dec     ptr1+1		; adjust base...
  2572 8A98 C6 AB			dec     ptr2+1
  2573 8A9A 88				dey			; in entry case: 0 -> FF
  2574 8A9B B1 A6			lda     (ptr1),y	; need to copy this 'intro byte'
  2575 8A9D 91 AA			sta     (ptr2),y	; to 'land' later on Y=0! (as a result of the '.repeat'-block!)
  2576 8A9F 88				dey			; FF ->FE
  2577 8AA0			@copyBytes:
  2578 					.rept 2		; Unroll this a bit to make it faster...
  2579 					LDA     (PTR1),Y
  2580 					STA     (PTR2),Y
  2581 					DEY
  2582 					.ENDR
  2582 					.endr
Source: REPT
  2579 8AA0 B1 A6			LDA     (PTR1),Y
  2579 8AA2 91 AA			STA     (PTR2),Y
  2579 8AA4 88				DEY
  2579 8AA5 B1 A6			LDA     (PTR1),Y
  2579 8AA7 91 AA			STA     (PTR2),Y
  2579 8AA9 88				DEY
Source: cpu6502.asm
  2583 8AAA			@copyEntry:			; in entry case: 0 -> FF
  2584 8AAA D0 F4			bne     @copyBytes
  2585 8AAC B1 A6			lda     (ptr1),y	; Y = 0, copy last byte
  2586 8AAE 91 AA			sta     (ptr2),y
  2587 8AB0 CA				dex			; one page to copy less
  2588 8AB1 D0 E3			bne     @initBase	; still a page to copy?
  2589
  2590 8AB3 A2 00		done	ldx #0
  2591 = 8AB4			@sp	equ *-1
  2592 8AB5 60				rts
  2593 				.endp
  2594
  2595
  2596 				; Ullrich von Bassewitz, 29.05.1998
  2597 				; Performance increase (about 20%) by
  2598 				; Christian Krueger, 12.09.2009, slightly improved 12.01.2011
  2599
  2600 8AB6			.proc	@fill (.word ptr1, ptr3 .byte ptr2) .var
  2601
  2602 = 00A6			ptr1 = edx
  2603 = 00AA			ptr3 = ecx
  2604 = 00A2			ptr2 = eax
  2605
  2606 8AB6 8E FD 8A			stx @sp
  2607
  2608 8AB9 A6 A2			ldx ptr2
  2609
  2610 8ABB A0 00			ldy #0
  2611
  2612 8ABD 46 AB		        lsr	ptr3+1          ; divide number of
  2613 8ABF 66 AA		        ror	ptr3            ; bytes by two to increase
  2614 8AC1 90 09		        bcc	evenCount       ; speed (ptr3 = ptr3/2)
  2615 8AC3			oddCount:
  2616 								; y is still 0 here
  2617 8AC3 8A			        txa			; restore fill value
  2618 8AC4 91 A6		        sta	(ptr1),y	; save value and increase
  2619 8AC6 E6 A6		        inc	ptr1		; dest. pointer
  2620 8AC8 D0 02		        bne	evenCount
  2621 8ACA E6 A7		        inc	ptr1+1
  2622 8ACC			evenCount:
  2623 8ACC A5 A6			lda	ptr1		; build second pointer section
  2624 8ACE 18				clc
  2625 8ACF 65 AA			adc	ptr3		; ptr2 = ptr1 + (length/2) <- ptr3
  2626 8AD1 85 A2			sta     ptr2
  2627 8AD3 A5 A7			lda     ptr1+1
  2628 8AD5 65 AB			adc     ptr3+1
  2629 8AD7 85 A3			sta     ptr2+1
  2630
  2631 8AD9 8A			        txa			; restore fill value
  2632 8ADA A6 AB		        ldx	ptr3+1		; Get high byte of n
  2633 8ADC F0 13		        beq	L2		; Jump if zero
  2634
  2635 				; Set 256/512 byte blocks
  2636 								; y is still 0 here
  2637 				L1:	.rept 2		; Unroll this a bit to make it faster
  2638 					STA	(PTR1),Y	
  2639 					STA	(PTR2),Y	
  2640 					INY
  2641 					.ENDR
  2641 					.endr
Source: REPT
  2638 8ADE 91 A6			STA	(PTR1),Y	
  2638 8AE0 91 A2			STA	(PTR2),Y	
  2638 8AE2 C8				INY
  2638 8AE3 91 A6			STA	(PTR1),Y	
  2638 8AE5 91 A2			STA	(PTR2),Y	
  2638 8AE7 C8				INY
Source: cpu6502.asm
  2642 8AE8 D0 F4		        bne	L1
  2643 8AEA E6 A7		        inc	ptr1+1
  2644 8AEC E6 A3		        inc	ptr2+1
  2645 8AEE CA			        dex                     ; Next 256 byte block
  2646 8AEF D0 ED		        bne	L1              ; Repeat if any
  2647
  2648 				; Set the remaining bytes if any
  2649
  2650 8AF1 A4 AA		L2:	ldy	ptr3            ; Get the low byte of n
  2651 8AF3 F0 07			beq	leave           ; something to set? No -> leave
  2652
  2653 8AF5 88			L3:	dey
  2654 8AF6 91 A6			sta	(ptr1),y	; set bytes in low
  2655 8AF8 91 A2			sta	(ptr2),y	; and high section
  2656 8AFA D0 F9			bne     L3		; flags still up to date from dey!
  2657
  2658 8AFC A2 00		leave	ldx #0
  2659 = 8AFD			@sp	equ *-1
  2660 8AFE 60				rts			; return
  2661 				.endp
  2662
  2663
  2664 				/*
  2665 				 add strings
  2666 				 result -> @buf
  2667 				*/
  2667
  2668 8AFF			.proc	@addString(.word ya) .reg
  2669
  2670 					sta ztmp
  2671 					sty ztmp+1
  2672
  2673 					stx @sp
  2674
  2675 					ldx @buf
  2676 					inx
  2677 					beq stop
  2678
  2679 					ldy #0
  2680 					lda (ztmp),y
  2681 					sta ile
  2682 					beq stop
  2683
  2684 					iny
  2685
  2686 8AFF			load	lda (ztmp),y
  2687 					sta @buf,x
  2688
  2689 					iny
  2690 					inx
  2691 					beq stop
  2692 					dec ile
  2693 					bne load
  2694
  2695 8AFF			stop	dex
  2696 					stx @buf
  2697
  2698 					ldx #0
  2699 8AFF			@sp	equ *-1
  2700 					rts
  2701
  2702 8AFF			ile	brk
  2703 				.endp
  2704
  2705
  2706 				/* ----------------------------------------------------------------------- */
  2707
  2708
  2709 8AFF			.proc	@AllocMem(.word ztmp .word ztmp+2) .var
  2710
  2711 					jsr swap
  2712
  2713 					adw spoint ztmp+2
  2714
  2715 					rts
  2716
  2717 8AFF			swap	txa:pha
  2718
  2719 					mwa spoint bp2
  2720
  2721 					ldx #0
  2722 					ldy #0
  2723
  2724 8AFF			loop	cpy ztmp+2
  2725 					bne @+
  2726 					cpx ztmp+3
  2727 					beq stop
  2728
  2729 8AFF			@	lda (bp2),y
  2730 					pha
  2731
  2732 					lda (ztmp),y
  2733 					sta (bp2),y
  2734
  2735 					pla
  2736 					sta (ztmp),y
  2737
  2738 					iny
  2739 					bne loop
  2740
  2741 					inc ztmp+1
  2742 					inc bp2+1
  2743 					inx
  2744
  2745 					jmp loop
  2746
  2747 8AFF			stop	pla:tax
  2748
  2749 					rts
  2750
  2751 8AFF			spoint	dta a(PROGRAMSTACK)
  2752 				.endp
  2753
  2754
  2755 8AFF			.proc	@FreeMem(.word ztmp .word ztmp+2) .var
  2756
  2757 					sbw @AllocMem.spoint ztmp+2
  2758
  2759 					jmp @AllocMem.swap
  2760 				.endp
  2761
  2762
  2763 				/* ----------------------------------------------------------------------- */
  2764
  2765
  2766 8AFF			.proc	@vbxe_detect
  2767
  2768 					ldy #.sizeof(detect)-1
  2769 					mva:rpl copy,y detect,y-
  2770
  2771 					jmp detect
  2772
  2773 8AFF			copy
  2774 0400				.local	detect,@buf
  2775 				;
  2776 				; 2009 by KMK/DLT
  2777 				;
  2778 					lda #0
  2779 					sta fxptr
  2780
  2781 				        lda #$d6
  2782 				        sta fxptr+1
  2783 				        ldy #FX_MEMB
  2784 				        jsr ?clr
  2785
  2786 				        jsr ?try
  2787 				        bcc ok
  2788
  2789 				        inc fxptr+1
  2790
  2791 					jsr ?try
  2792 					bcc ok
  2793
  2794 					lda #0
  2795 					sta fxptr+1
  2796 					rts
  2797
  2798 0400			?try    ldx $4000
  2799 				        jsr ?chk
  2800 				        bcc ?ret
  2801 				        inx
  2802 				        stx $4000
  2803 				        jsr ?chk
  2804 				        dec $4000
  2805 0400			?ret    rts
  2806
  2807 0400			ok	ldy	#VBXE_MINOR		; get core minor version
  2808 					lda	(fxptr),y
  2809 					rts
  2810
  2811 0400			?chk    lda #$80
  2812 				        jsr _vbxe_write
  2813 				        cpx $4000
  2814 				        bne ?fnd
  2815 				        sec
  2816 0400			        .byte $24
  2817 0400			?fnd    clc
  2818 0400			?clr    lda #$00
  2819 0400			_vbxe_write
  2820 				        sta (fxptr),y
  2821 				        rts
  2822
  2823 				/*
  2824 					lda	#0
  2825 					ldx	#0xd6
  2826 					sta	0xd640			; make sure it isn't coincidence
  2827 					lda	0xd640
  2828 					cmp	#0x10			; do we have major version here?
  2829 					beq	VBXE_Detected		; if so, then VBXE is detected
  2830 					lda	#0
  2831 					inx
  2832 					sta	0xd740			; no such luck, try other location
  2833 					lda	0xd740
  2834 					cmp	#0x10
  2835 					beq	VBXE_Detected
  2836 					ldx 	#0  			; not here, so not present or FX core version too low
  2837 					stx	fxptr+1
  2838 					stx	fxptr
  2839
  2840 					sec
  2841 					rts
  2842
  2843 				VBXE_Detected
  2844 					stx	fxptr+1
  2845 					lda	#0
  2846 					sta	fxptr
  2847
  2848 					ldy	#VBXE_MINOR		; get core minor version
  2849 					lda	(fxptr),y
  2850
  2851 					clc
  2852 					rts	 			; x - page of vbxe
  2853 				*/
  2853
  2854
  2855 					.endl
  2856
  2857 				.endp
  2858
  2859
  2860 8AFF			.proc	@setxdl(.byte a) .reg
  2861
  2862 					asl @
  2863 					sta idx
  2864
  2865 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000
  2866
  2867 					ldy #0
  2868 8AFF			idx	equ *-1
  2869
  2870 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2871 					and msk,y
  2872 					ora val,y
  2873 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2874
  2875 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2876 					and msk+1,y
  2877 					ora val+1,y
  2878 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2879
  2880 					fxs FX_MEMS #0
  2881 					rts
  2882
  2883 8AFF			msk	.array [6] .word
  2884 					[e@xdl.mapon]  = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2885 					[e@xdl.mapoff] = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2886 					[e@xdl.ovron]  = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2887 					[e@xdl.ovroff] = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2888 					[e@xdl.hr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2889 					[e@xdl.lr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2890 					.enda
  2891
  2892 8AFF			val	.array [6] .word
  2893 					[e@xdl.mapon]  = XDLC_MAPON
  2894 					[e@xdl.mapoff] = XDLC_MAPOFF
  2895 					[e@xdl.ovron]  = XDLC_GMON
  2896 					[e@xdl.ovroff] = XDLC_OVOFF
  2897 					[e@xdl.hr]     = XDLC_GMON|XDLC_HR
  2898 					[e@xdl.lr]     = XDLC_GMON|XDLC_LR
  2899 					.enda
  2900
  2901 				.endp
  2902
  2903
  2904 8AFF			.proc	@vbxe_init
  2905
  2906 					fxs FX_MEMC #%1000+>MAIN.SYSTEM.VBXE_WINDOW	; $b000..$bfff (4K window), cpu on, antic off
  2907 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000	; enable VBXE BANK #0
  2908
  2909 					ldx #.sizeof(s@xdl)-1
  2910 					mva:rpl xdlist,x MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW,x-
  2911
  2912 					jsr cmapini		; init color map
  2913
  2914 					fxsa FX_P1		; A = 0
  2915 					fxsa FX_P2
  2916 					fxsa FX_P3
  2917
  2918 					fxsa FX_IRQ_CONTROL
  2919 					fxsa FX_BLITTER_START
  2920
  2921 					fxsa FX_XDL_ADR0	; XDLIST PROGRAM ADDRES (VBXE_XDLADR = $0000) = bank #0
  2922 					fxsa FX_XDL_ADR1
  2923 					fxsa FX_XDL_ADR2
  2924
  2925 					sta colpf0s
  2926
  2927 					fxs FX_P0 #$ff
  2928
  2929 					mwa #@vbxe_cmap @putchar.vbxe+1
  2930 					mva #{jsr*} @putchar.vbxe
  2931
  2932 					fxs FX_VIDEO_CONTROL #VC_XDL_ENABLED|VC_XCOLOR	;|VC_NO_TRANS
  2933
  2934 					rts
  2935
  2936 8AFF			cmapini	lda colpf1s
  2937 					and #$0f
  2938 					sta colpf1s
  2939
  2940 					lda #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2941 					sta ztmp
  2942
  2943 					mva #4 ztmp+1
  2944
  2945 8AFF			loop	fxs FX_MEMS ztmp
  2946
  2947 					lda >MAIN.SYSTEM.VBXE_WINDOW
  2948 					sta bp+1
  2949
  2950 					ldx #16
  2951 					ldy #0
  2952
  2953 8AFF			lop	mva #$00	(bp),y+
  2954 					mva colpf1s	(bp),y+
  2955 					mva colpf2s	(bp),y+
  2956 					mva #%00010000	(bp),y+		; overlay palette #1
  2957 					bne lop
  2958
  2959 					inc bp+1
  2960 					dex
  2961 					bne lop
  2962
  2963 					inc ztmp
  2964
  2965 					dec ztmp+1
  2966 					bne loop
  2967
  2968 					fxs FX_MEMS #$00		; disable VBXE BANK
  2969 					rts
  2970
  2971 				xdlist	dta s@xdl [0] (XDLC_RPTL, 24-1,\
  2972 					XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,\	;|XDLC_GMON,\
  2973 					192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,\
  2974 					MAIN.SYSTEM.VBXE_MAPADR, $100,\
  2975 					0, 0, 7, 7, %00010001, $ff)
  2975 8AFF			XDLIST	DTA S@XDL [0] (XDLC_RPTL, 24-1,	XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,	192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,	MAIN.SYSTEM.VBXE_MAPADR, $100,	0, 0, 7, 7, %00010001, $ff)
  2976 				.endp
  2977
  2978
  2979 8AFF			.proc	@vbxe_cmap
  2980
  2981 					pha
  2982
  2983 					cmp #eol
  2984 					beq stop
  2985
  2986 					cmp #$7d		; clrscr
  2987 					bne skp
  2988
  2989 					jsr @vbxe_init.cmapini
  2990 					jmp stop
  2991
  2992 8AFF			skp	lda rowcrs
  2993 					pha
  2994 8AFF				:4 lsr @
  2995 					add #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2996 					fxsa FX_MEMS
  2997
  2998 					pla
  2999 					and #$0f
  3000 					add >MAIN.SYSTEM.VBXE_WINDOW
  3001 					sta bp+1
  3002
  3003 					lda colcrs
  3004 					asl @
  3005 					asl @
  3006 					tay
  3007 					mva colpf0s (bp),y
  3008 					iny
  3009 					mva colpf1s (bp),y
  3010 					iny
  3011 					mva colpf2s (bp),y
  3012
  3013 					fxs FX_MEMS #$00
  3014
  3015 8AFF			stop	pla
  3016
  3017 					rts
  3018 				.endp
  3019
  3020
  3021 				/* ----------------------------------------------------------------------- */
  3022
  3023
  3024 				/*
  3025 				.proc	@cmdline (.byte a) .reg
  3026
  3027 					stx @sp
  3028
  3029 					sta idpar
  3030
  3031 					lda #0
  3032 					sta parno
  3033
  3034 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3035 					lsr
  3036 					bcc _no_command_line
  3037
  3038 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3039 					cmp #$c0
  3040 					bcs _no_command_line
  3041
  3042 					ldy #$03
  3043 					lda (dosvec),y
  3044 					cmp #{jmp}
  3045 					bne _no_command_line
  3046
  3047 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3048 					lda (dosvec),y
  3049 					sta lbuf
  3050 					iny
  3051 					lda (dosvec),y
  3052 					sta hbuf
  3053
  3054 					adw dosvec #3 zcr
  3055
  3056 				loop	lda #0
  3057 					sta @buf
  3058
  3059 					jsr $ffff
  3060 				zcr	equ *-2
  3061 					beq stop
  3062
  3063 					lda idpar
  3064 					bne skp
  3065
  3066 					ldy #33			; ParamStr(0)
  3067 				_par0	lda (dosvec),y
  3068 					sta @buf-33+1,y
  3069 					iny
  3070 					cpy #36
  3071 					bne _par0
  3072
  3073 					lda #3
  3074 					sta @buf
  3075 					bne stop
  3076
  3077 				skp	ldy #36
  3078 				_cp	lda (dosvec),y
  3079 					sta @buf-36+1,y
  3080 					iny
  3081 					cmp #$9b
  3082 					bne _cp
  3083
  3084 					tya
  3085 					sub #37
  3086 					sta @buf
  3087
  3088 					inc parno
  3089 					lda #0
  3090 				parno	equ *-1
  3091 					cmp #0
  3092 				idpar	equ *-1
  3093
  3094 					bne loop
  3095
  3096 				stop	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3097 					lda #0
  3098 				lbuf	equ *-1
  3099 					sta (dosvec),y
  3100 					iny
  3101 					lda #0
  3102 				hbuf	equ *-1
  3103 					sta (dosvec),y
  3104
  3105 				_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3106
  3107 					lda parno
  3108
  3109 					ldx #0
  3110 				@sp	equ *-1
  3111 					rts
  3112 				.endp
  3113 				*/
  3113
  3114
  3115
  3116 8AFF			.proc	@CmdLine (.byte a) .reg
  3117
  3118 					stx @sp
  3119
  3120 					sta idpar
  3121
  3122 					lda #0
  3123 					sta parno
  3124 					sta loop+1
  3125
  3126 					lda	#{jsr*}
  3127 					sta	res
  3128
  3129 				; Get filename from SpartaDOS...
  3130 8AFF			get_param
  3131 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3132 					lsr
  3133 					bcc no_sparta
  3134
  3135 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3136 					cmp #$c0
  3137 					bcs no_sparta
  3138
  3139 					ldy #$03
  3140 					lda (dosvec),y
  3141 					cmp #{jmp}
  3142 					bne no_sparta
  3143
  3144 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3145 					lda (dosvec),y
  3146 					sta lbuf
  3147 					iny
  3148 					lda (dosvec),y
  3149 					sta hbuf
  3150
  3151 					adw dosvec #33 tmp
  3152
  3153 					ldy #0
  3154 8AFF			fnm	lda (tmp),y
  3155 					iny
  3156 					cmp #$9b
  3157 					bne fnm
  3158
  3159 					tya			; remove .COM
  3160 					sub #5
  3161 					tay
  3162 					lda #0
  3163 					sta (tmp),y
  3164 					tay
  3165
  3166 					lda	#3
  3167 					sta	loop+1
  3168 					add	dosvec
  3169 					sta	get_adr
  3170 					lda	#0
  3171 					adc	dosvec+1
  3172 					sta	get_adr+1
  3173
  3174 					jmp	_ok
  3175
  3176 8AFF			no_sparta
  3177 					mwa #next get_adr
  3178
  3179 					lda	#{bit*}
  3180 					sta	res
  3181
  3182 				; ... or channel #0
  3183 					lda	MAIN.IOCB@COPY+2	; command
  3184 					cmp	#5			; read line
  3185 					bne	_no_command_line
  3186 					lda	MAIN.IOCB@COPY+3	; status
  3187 					bmi	_no_command_line
  3188 				; don't assume the line is EOL-terminated
  3189 				; DOS II+/D overwrites the EOL with ".COM"
  3190 				; that's why we rely on the length
  3191 					lda	MAIN.IOCB@COPY+9	; length hi
  3192 					bne	_no_command_line
  3193 					ldx	MAIN.IOCB@COPY+8	; length lo
  3194 					beq	_no_command_line
  3195 					inx:inx
  3196 					stx	arg_len
  3197 				; give access to three bytes before the input buffer
  3198 				; in DOS II+/D the device prompt ("D1:") is there
  3199 					lda	MAIN.IOCB@COPY+4
  3200 					sub	#3
  3201 					sta	tmp
  3202 					lda	MAIN.IOCB@COPY+5
  3203 					sbc	#0
  3204 					sta	tmp+1
  3205
  3206 					lda	#0
  3207 					ldy	#0
  3208 8AFF			arg_len	equ *-1
  3209 					sta	(tmp),y
  3210
  3211
  3212 8AFF			loop	ldy	#0
  3213
  3214 8AFF			_ok	ldx	#0
  3215
  3216 8AFF			lprea	lda	(tmp),y
  3217 					sta	@buf+1,x
  3218
  3219 					beq	stop
  3220
  3221 					cmp	#$9b
  3222 					beq	stop
  3223 					cmp	#' '
  3224 					beq	stop
  3225
  3226 					iny
  3227 					inx
  3228 					cpx #32
  3229 					bne lprea
  3230
  3231 8AFF			stop	lda #0
  3232 8AFF			parno	equ *-1
  3233 					cmp #0
  3234 8AFF			idpar	equ *-1
  3235 					beq found
  3236
  3237 					jsr $ffff		; sty loop+1
  3238 8AFF			get_adr	equ *-2
  3239 					beq found
  3240
  3241 					inc parno
  3242 					bne loop
  3243
  3244 8AFF			found	lda #0	;+$9b
  3245 					sta @buf+1,x
  3246 					stx @buf
  3247
  3248 8AFF			res	jsr sdxres
  3249
  3250 8AFF			_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3251
  3252 					lda parno
  3253
  3254 					ldx #0
  3255 8AFF			@sp	equ *-1
  3256 					rts
  3257
  3258
  3259 8AFF			sdxres	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3260 					lda #0
  3261 8AFF			lbuf	equ *-1
  3262 					sta (dosvec),y
  3263 					iny
  3264 					lda #0
  3265 8AFF			hbuf	equ *-1
  3266 					sta (dosvec),y
  3267 					rts
  3268
  3269
  3270 8AFF			_next	iny
  3271 8AFF			next	lda (tmp),y
  3272 					beq _eol
  3273 					cmp #' '
  3274 					beq _next
  3275
  3276 					cmp #$9b
  3277 					beq _eol
  3278
  3279 					sty loop+1
  3280 					rts
  3281
  3282 8AFF			_eol	lda #0
  3283 					rts
  3284
  3285 				.endp
  3286
  3287
  3288 				/* ----------------------------------------------------------------------- */
  3289
  3290 				/*
  3291 				.proc	@rstsnd
  3292 					lda #0
  3293 					sta $d208
  3294 					sta $d218
  3295
  3296 					ldy #3
  3297 					sty $d20f
  3298 					sty $d21f
  3299 					rts
  3300 				.endp
  3301 				*/
  3301
  3302
  3303 				;	ert (*>$3fff) .and (*<$8000)
  3304
  3305
  3306 				/* ----------------------------------------------------------------------- */
  3307
  3308
  3309 8AFF			.proc	@xmsBank
  3310
  3311 = 00A2			ptr3 = eax			; position	(4)
  3312
  3313 					mva ptr3+3 ztmp+1	; position shr 14
  3314 					mva ptr3+2 ztmp
  3315 					lda ptr3+1
  3316
  3317 					.rept 6
  3318 					LSR ZTMP+1
  3319 					ROR ZTMP
  3320 					ROR @
  3321 					.ENDR
  3321 					.endr
Source: REPT
  3318 					LSR ZTMP+1
  3318 					ROR ZTMP
  3318 					ROR @
  3318 					LSR ZTMP+1
  3318 					ROR ZTMP
  3318 					ROR @
  3318 					LSR ZTMP+1
  3318 					ROR ZTMP
  3318 					ROR @
  3318 					LSR ZTMP+1
  3318 					ROR ZTMP
  3318 					ROR @
  3318 					LSR ZTMP+1
  3318 					ROR ZTMP
  3318 					ROR @
  3318 					LSR ZTMP+1
  3318 					ROR ZTMP
  3318 					ROR @
Source: cpu6502.asm
  3322
  3323 					tax			; index to bank
  3324
  3325 					lda portb
  3326 					and #1
  3327 					ora main.misc.adr.banks,x
  3328 					sta portb
  3329
  3330 					lda ptr3 		; offset
  3331 					sta ztmp
  3332 					lda ptr3+1
  3333 					and #$3f
  3334 					ora #$40
  3335 					sta ztmp+1
  3336
  3337 					rts
  3338 				.endp
  3339
  3340
  3341 8AFF			.proc	@xmsReadBuf (.word ptr1, ptr2) .var
  3342
  3343 = 00A6			ptr1 = dx	; buffer	(2)
  3344
  3345 = 00AA			ptr2 = cx	; count		(2)
  3346 = 00AC			pos = cx+2	; position	(2) pointer
  3347
  3348 = 00A2			ptr3 = eax	; position	(4)
  3349
  3350 					txa:pha
  3351
  3352 					ldy #0
  3353 					lda (pos),y
  3354 					sta ptr3
  3355 					iny
  3356 					lda (pos),y
  3357 					sta ptr3+1
  3358 					iny
  3359 					lda (pos),y
  3360 					sta ptr3+2
  3361 					iny
  3362 					lda (pos),y
  3363 					sta ptr3+3
  3364
  3365 					lda ptr2+1
  3366 					beq lp2
  3367
  3368 8AFF			lp1	jsr @xmsBank
  3369
  3370 					lda ztmp+1
  3371 					cmp #$7f
  3372 					bne skp
  3373 					lda ztmp
  3374 					beq skp
  3375
  3376 					lda #0
  3377 					jsr nextBank
  3378 					jmp skp2
  3379
  3380 8AFF			skp	ldy #0
  3381 					mva:rne (ztmp),y @buf,y+
  3382
  3383 8AFF			skp2	lda portb
  3384 					and #1
  3385 					ora #$fe
  3386 					sta portb
  3387
  3388 					ldy #0
  3389 					mva:rne @buf,y (dx),y+
  3390
  3391 					inc dx+1	// inc(dx, $100)
  3392
  3393 					inl ptr3+1	// inc(position, $100)
  3394
  3395 					dec ptr2+1
  3396 					bne lp1
  3397
  3398 8AFF			lp2	jsr @xmsBank
  3399
  3400 					lda ztmp+1		; zakonczenie kopiowania
  3401 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3402 					bne skp_
  3403
  3404 					lda ztmp
  3405 					add ptr2
  3406 					bcc skp_
  3407
  3408 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3409 					jsr nextBank
  3410 					jmp skp3
  3411
  3412 8AFF			skp_	ldy #0
  3413 8AFF			mv	lda (ztmp),y
  3414 					sta @buf,y
  3415 					iny
  3416 					cpy ptr2
  3417 					bne mv
  3418
  3419 8AFF			skp3	lda portb
  3420 					and #1
  3421 					ora #$fe
  3422 					sta portb
  3423
  3424 					ldy #0
  3425 8AFF			lp3	lda @buf,y
  3426 					sta (dx),y
  3427 					iny
  3428 					cpy ptr2
  3429 					bne lp3
  3430
  3431 					jmp @xmsUpdatePosition
  3432
  3433 8AFF			.local	nextBank
  3434
  3435 					sta max
  3436
  3437 					mwa ztmp src
  3438
  3439 					ldy #0
  3440 8AFF			mv0	lda $ffff,y
  3441 8AFF			src	equ *-2
  3442 					sta @buf,y
  3443 					iny
  3444 					inc ztmp
  3445 					bne mv0
  3446
  3447 					lda portb
  3448 					and #1
  3449 					ora main.misc.adr.banks+1,x
  3450 					sta portb
  3451
  3452 					ldx #0
  3453 8AFF			mv1	cpy #0
  3454 8AFF			max	equ *-1
  3455 					beq stp
  3456 					lda $4000,x
  3457 					sta @buf,y
  3458 					inx
  3459 					iny
  3460 					bne mv1
  3461 8AFF			stp	rts
  3462 				.endl
  3463
  3464 				.endp
  3465
  3466
  3467 8AFF			.proc	@xmsWriteBuf (.word ptr1, ptr2) .var
  3468
  3469 = 00A6			ptr1 = dx	; buffer	(2)
  3470
  3471 = 00AA			ptr2 = cx	; count		(2)
  3472 = 00AC			pos = cx+2	; position	(2) pointer
  3473
  3474 = 00A2			ptr3 = eax	; position	(4)
  3475
  3476 					txa:pha
  3477
  3478 					ldy #0			; przepisz POSITION spod wskaznika
  3479 					lda (pos),y
  3480 					sta ptr3
  3481 					iny
  3482 					lda (pos),y
  3483 					sta ptr3+1
  3484 					iny
  3485 					lda (pos),y
  3486 					sta ptr3+2
  3487 					iny
  3488 					lda (pos),y
  3489 					sta ptr3+3
  3490
  3491 8AFF			lp1	lda portb		; wylacz dodatkowe banki
  3492 					and #1
  3493 					ora #$fe
  3494 					sta portb
  3495
  3496 					ldy #0			; przepisz 256b z BUFFER do @BUF
  3497 					mva:rne (dx),y @buf,y+
  3498
  3499 					jsr @xmsBank		; wlacz dodatkowy bank
  3500
  3501 					lda ptr2+1
  3502 					beq lp2
  3503
  3504 					lda ztmp+1		; jesli przekraczamy granice banku $7FFF
  3505 					cmp #$7f
  3506 					bne skp
  3507 					lda ztmp
  3508 					beq skp
  3509
  3510 					lda #0			; to realizuj wyjatek NEXTBANK, kopiuj 256b
  3511 					jsr nextBank
  3512 					jmp skp2
  3513
  3514 8AFF			skp	mva:rne @buf,y (ztmp),y+
  3515
  3516 8AFF			skp2	inc dx+1		// inc(dx, $100)
  3517
  3518 					inl ptr3+1		// inc(position, $100)
  3519
  3520 					dec ptr2+1
  3521 					bne lp1
  3522
  3523 8AFF			lp2	lda ztmp+1		; zakonczenie kopiowania
  3524 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3525 					bne skp_
  3526
  3527 					lda ztmp
  3528 					add ptr2
  3529 					bcc skp_
  3530
  3531 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3532 					jsr nextBank
  3533 					jmp quit
  3534
  3535 8AFF			skp_	ldy #0
  3536 8AFF			lp3	lda @buf,y
  3537 					sta (ztmp),y
  3538
  3539 					iny
  3540 					cpy ptr2
  3541 					bne lp3
  3542
  3543 8AFF			quit	lda portb
  3544 					and #1
  3545 					ora #$fe
  3546 					sta portb
  3547
  3548 					jmp @xmsUpdatePosition
  3549
  3550 8AFF			.local	nextBank
  3551
  3552 					sta max
  3553
  3554 					mwa ztmp dst
  3555
  3556 					ldy #0
  3557 8AFF			mv0	lda @buf,y
  3558 					sta $ffff,y
  3559 8AFF			dst	equ *-2
  3560 					iny
  3561 					inc ztmp
  3562 					bne mv0
  3563
  3564 					lda portb
  3565 					and #1
  3566 					ora main.misc.adr.banks+1,x
  3567 					sta portb
  3568
  3569 					ldx #0
  3570 8AFF			mv1	cpy #0
  3571 8AFF			max	equ *-1
  3572 					beq stp
  3573 					lda @buf,y
  3574 					sta $4000,x
  3575 					inx
  3576 					iny
  3577 					bne mv1
  3578 8AFF			stp	rts
  3579 				.endl
  3580
  3581 				.endp
  3582
  3583
  3584 8AFF			.proc	@xmsAddPosition
  3585
  3586 8AFF				.use @xmsReadBuf
  3587
  3588 					add ptr3
  3589 					sta ptr3
  3590 					lda #$00
  3591 					adc ptr3+1
  3592 					sta ptr3+1
  3593 					lda #$00
  3594 					adc ptr3+2
  3595 					sta ptr3+2
  3596 					lda #$00
  3597 					adc ptr3+3
  3598 					sta ptr3+3
  3599
  3600 					rts
  3601 				.endp
  3602
  3603
  3604 8AFF			.proc	@xmsUpdatePosition
  3605
  3606 8AFF				.use @xmsReadBuf
  3607
  3608 					tya
  3609 					jsr @xmsAddPosition
  3610
  3611 					ldy #0
  3612 					lda ptr3
  3613 					sta (pos),y
  3614 					iny
  3615 					lda ptr3+1
  3616 					sta (pos),y
  3617 					iny
  3618 					lda ptr3+2
  3619 					sta (pos),y
  3620 					iny
  3621 					lda ptr3+3
  3622 					sta (pos),y
  3623
  3624 					pla:tax
  3625 					rts
  3626 				.endp
  3627
  3628
  3629 				/* ----------------------------------------------------------------------- */
  3630
  3631
  3632 8AFF			.proc	@ClrScr
  3633
  3634 					ldx #$00
  3635 					lda #$0c
  3636 					jsr xcio
  3637
  3638 					mwa #ename ioadr,x
  3639
  3640 					mva #$0c ioaux1,x
  3641 					mva #$00 ioaux2,x
  3642
  3643 					lda #$03
  3644
  3645 8AFF			xcio	sta iocom,x
  3646 					jmp ciov
  3647
  3648 8AFF			ename	.byte 'E:',$9b
  3649
  3650 				.endp
  3651
  3652
  3653 				/* ----------------------------------------------------------------------- */
  3654
  3655
  3656 					opt l+
  1774
  1775 				; -----------------------------------------------------------
  1776
  1777 				.macro UNITINITIALIZATION
  1778 				
  1779 					.ifdef MAIN.SYSTEM.@UnitInit
  1780 					jsr MAIN.SYSTEM.@UnitInit
  1781 					eif
  1782 				
  1783 					.ifdef MAIN.ATARI.@UnitInit
  1784 					jsr MAIN.ATARI.@UnitInit
  1785 					eif
  1786 				
  1787 					.ifdef MAIN..@UnitInit
  1788 					jsr MAIN..@UnitInit
  1789 					eif
  1790 				
  1791 					.ifdef MAIN.B_SYSTEM.@UnitInit
  1792 					jsr MAIN.B_SYSTEM.@UnitInit
  1793 					eif
  1794 				
  1795 					.ifdef MAIN.SYSUTILS.@UnitInit
  1796 					jsr MAIN.SYSUTILS.@UnitInit
  1797 					eif
  1798 				
  1799 					.ifdef MAIN..@UnitInit
  1800 					jsr MAIN..@UnitInit
  1801 					eif
  1802 				
  1803 					.ifdef MAIN.B_CRT.@UnitInit
  1804 					jsr MAIN.B_CRT.@UnitInit
  1805 					eif
  1806 				.endm
  1807
  1808 					ift .SIZEOF(MAIN.SYSTEM) > 0
  1809 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  1809 				SYSTEM: $82BA..$8316
  1810 					eif
  1811
  1812 					ift .SIZEOF(MAIN.ATARI) > 0
  1813 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
  1814 					eif
  1815
  1816 					ift .SIZEOF(MAIN.B_SYSTEM) > 0
  1817 					.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
  1817 				B_SYSTEM: $8317..$8324
  1818 					eif
  1819
  1820 					ift .SIZEOF(MAIN.SYSUTILS) > 0
  1821 					.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
  1821 				SYSUTILS: $8325..$8361
  1822 					eif
  1823
  1824 					ift .SIZEOF(MAIN.B_CRT) > 0
  1825 					.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
  1825 				B_CRT: $8362..$85C3
  1826 					eif
  1827
  1828 					.print 'CODE: ',CODEORIGIN,'..',*-1
  1828 				CODE: $8000..$8AFE
  1829
  1830 					org $A000
  1831
  1832 A000			DATAORIGIN
  1833
  1834 A000-A33D> 28 00 18 00 + .by  $28 $00 $18 $00 $0C $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1835 A018 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1836 A030 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1837 A048 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1838 A060 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1839 A078 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1840 A090 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1841 A0A8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1842 A0C0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1843 A0D8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1844 A0F0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1845 A108 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1846 A120 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1847 A138 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1848 A150 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1849 A168 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1850 A180 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1851 A198 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1852 A1B0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1853 A1C8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1854 A1E0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1855 A1F8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1856 A210 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1857 A228 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1858 A240 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1859 A258 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1860 A270 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1861 A288 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1862 A2A0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1863 A2B8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1864 A2D0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1865 A2E8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1866 A300 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1867 A318 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $B0 $00 $00 $00 $00
  1868 A330 9A 10 00 00 4C 1D + .by  $9A $10 $00 $00 $4C $1D $7C $15  $AC $0D $C4 $09 $F4 $01
  1869
  1870 = 033E			VARINITSIZE	= *-DATAORIGIN
  1871 = 034B			VARDATASIZE	= 843
  1872
  1873 = A34B			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  1874
  1875 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  1875 				DATA: $A000..$A34B
  1876
  1877 02E0-02E1> 8D 82			run START
  1878
  1879 				; -----------------------------------------------------------
  1880
  1881 				.macro	STATICDATA
  1882 				.by  $00 $00 $27 $80 $80 $80 $80 $80  $80 $80 $80 $80 $80 $80 $80 $80  $80 $80 $AD $A9 $AE $A4 $80 $A6
  1883 				.by  $A9 $A5 $AC $A4 $80 $80 $80 $80  $80 $80 $80 $80 $80 $80 $80 $80  $80 $80 $00 $28 $00 $00 $00 $00
  1884 				.by  $00 $00 $00 $00 $00 $00 $00 $21  $34 $21 $32 $29 $00 $18 $0D $22  $29 $34 $00 $36 $25 $32 $33 $29
  1885 				.by  $2F $2E $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $28 $00 $30  $32 $2F $27 $32 $21 $2D $2D $29
  1886 				.by  $2E $27 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $30  $25 $34 $25 $32 $00 $2A $0E $00
  1887 				.by  $2D $25 $39 $25 $32 $00 $00 $28  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $08 $39
  1888 				.by  $2F $35 $32 $00 $2E $21 $2D $25  $00 $23 $2F $35 $2C $24 $00 $22  $25 $00 $28 $25 $32 $25 $09 $00
  1889 				.by  $00 $28 $00 $27 $32 $21 $30 $28  $29 $23 $33 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1890 				.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $28 $00 $33 $2F $35
  1891 				.by  $2E $24 $00 $21 $2E $24 $00 $2D  $35 $33 $29 $23 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  1892 				.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $08 $33 $23  $2F $32 $25 $00 $1A $00 $00 $13
  1893 				.by  $34 $2F $24 $21 $39 $33 $00 $28  $29 $27 $28 $00 $33 $23 $2F $32  $25 $33 $0E $00 $02 $00 $1A $00
  1894 				.by  $15 $30 $32 $25 $33 $33 $00 $33  $34 $21 $32 $34 $00 $34 $2F $00  $22 $25 $27 $29 $2E $0E $00 $6C
  1895 				.by  $6A $3B $FF $FF $6B $2B $2A $6F  $FF $70 $75 $9B $69 $2D $3D $76  $FF $63 $FF $FF $62 $78 $7A $34
  1896 				.by  $FF $33 $36 $1B $35 $32 $31 $2C  $20 $2E $6E $FF $6D $2F $81 $72  $FF $65 $79 $7F $74 $77 $71 $39
  1897 				.by  $FF $30 $37 $7E $38 $3E $FF $66  $68 $64 $FF $82 $67 $73 $61 $4C  $4A $3A $FF $FF $4B $5C $5E $4F
  1898 				.by  $FF $50 $55 $FF $49 $5F $7C $56  $FF $43 $FF $FF $42 $58 $5A $24  $FF $23 $26 $FF $25 $22 $21 $5B
  1899 				.by  $3B $5D $4E $FF $4D $3F $FF $52  $FF $45 $59 $FF $54 $57 $51 $28  $FF $29 $27 $FF $40 $FF $FF $46
  1900 				.by  $48 $44 $FF $FF $47 $53 $41 $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  1901 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  1902 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  1903 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  1904 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  1905 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $70  $70 $44 $00 $40 $04 $04 $04 $04
  1906 				.by  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $00
  1907 				.by  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $41  $37 $82 $70 $50 $43 $00 $40 $03
  1908 				.by  $03 $10 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04
  1909 				.by  $04 $04 $41 $6A $82
  1910 				.endm
  1911
  1912 					end
