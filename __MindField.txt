mads 2.0.8 build 1 (2 Nov 17)
Source: Mind Field.a65
     1 = 0010			STACKWIDTH	= 16
     2 = 8000			CODEORIGIN	= $8000
     3
     4 = 0001			TRUE		= 1
     5 = 0000			FALSE		= 0
     6
     7 					org $C0
     8
     9 					.print 'ZPFREE: $0000..',*-1
     9 				ZPFREE: $0000..$00BF
    10
    11 = 00C0			fxptr	.ds 2
    12
    13 = 00C2			eax	.ds 4						;8 bytes (aex + edx) -> divREAL
    14 = 00C6			edx	.ds 4
    15 = 00CA			ecx	.ds 4
    16 = 00CE			bp	.ds 2
    17 = 00D0			bp2	.ds 2
    18
    19 				ztmp
    20 = 00D2			ztmp8	.ds 1
    21 = 00D3			ztmp9	.ds 1
    22 = 00D4			ztmp10	.ds 1
    23 = 00D5			ztmp11	.ds 1
    24
    25 = 00D6			TMP	.ds 2
    26
    27 					org $0080
    28
    29 = 0080			STACKORIGIN	.ds STACKWIDTH*4
    30
    31 					.print 'ZPFREE: ',*,'..',$ff
    31 				ZPFREE: $00C0..$00FF
    32
    33 = 00C2			ax	= eax
    34 = 00C2			al	= eax
    35 = 00C3			ah	= eax+1
    36
    37 = 00CA			cx	= ecx
    38 = 00CA			cl	= ecx
    39 = 00CB			ch	= ecx+1
    40
    41 = 00C6			dx	= edx
    42 = 00C6			dl	= edx
    43 = 00C7			dh	= edx+1
    44
    45 					org eax
    46
    47 = 00C2			FP1MAN0	.ds 1
    48 = 00C3			FP1MAN1	.ds 1
    49 = 00C4			FP1MAN2	.ds 1
    50 = 00C5			FP1MAN3	.ds 1
    51
    52 					org ztmp8
    53
    54 = 00D2			FP1SGN	.ds 1
    55 = 00D3			FP1EXP	.ds 1
    56
    57 					org edx
    58
    59 = 00C6			FP2MAN0	.ds 1
    60 = 00C7			FP2MAN1	.ds 1
    61 = 00C8			FP2MAN2	.ds 1
    62 = 00C9			FP2MAN3	.ds 1
    63
    64 					org ztmp10
    65
    66 = 00D4			FP2SGN	.ds 1
    67 = 00D5			FP2EXP	.ds 1
    68
    69 					org ecx
    70
    71 = 00CA			FPMAN0	.ds 1
    72 = 00CB			FPMAN1	.ds 1
    73 = 00CC			FPMAN2	.ds 1
    74 = 00CD			FPMAN3	.ds 1
    75
    76 					org bp2
    77
    78 = 00D0			FPSGN	.ds 1
    79 = 00D1			FPEXP	.ds 1
    80
    81 				.local	RESOURCE
    82 					icl 'res6502.asm'
Source: res6502.asm
     1
  1103 					opt l+
    83
    84 8000				RCDATA 'MINDFIELD.FNT' CHARSET_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0400			len = .filesize('MINDFIELD.FNT')
    17 					org main.CHARSET_ADDRESS
    19 FFFF> A400-A7FF> 00 00 + 	ins 'MINDFIELD.FNT'
Source: Mind Field.a65
    85 				.endl
    86
    87 				; -----------------------------------------------------------
    88
    89 A800				org CODEORIGIN
    90
    91 8000				STATICDATA
Macro: STATICDATA [Source: Mind Field.a65]
     1 8000-8C11> 00 00 27 80 + .by  $00 $00 $27 $80 $80 $80 $80 $80  $80 $80 $80 $80 $80 $80 $80 $80  $80 $80 $AD $A9 $AE $A4 $80 $A6
     2 8018 A9 A5 AC A4 80 80 + .by  $A9 $A5 $AC $A4 $80 $80 $80 $80  $80 $80 $80 $80 $80 $80 $80 $80  $80 $80 $00 $28 $00 $00 $00 $00
     3 8030 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $21  $34 $21 $32 $29 $00 $18 $0D $22  $29 $34 $00 $36 $25 $32 $33 $29
     4 8048 2F 2E 00 00 00 00 + .by  $2F $2E $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $28 $00 $30  $32 $2F $27 $32 $21 $2D $2D $29
     5 8060 2E 27 00 00 00 00 + .by  $2E $27 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $30  $25 $34 $25 $32 $00 $2A $0E $00
     6 8078 2D 25 39 25 32 00 + .by  $2D $25 $39 $25 $32 $00 $00 $28  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $08 $39
     7 8090 2F 35 32 00 2E 21 + .by  $2F $35 $32 $00 $2E $21 $2D $25  $00 $23 $2F $35 $2C $24 $00 $22  $25 $00 $28 $25 $32 $25 $09 $00
     8 80A8 00 28 00 27 32 21 + .by  $00 $28 $00 $27 $32 $21 $30 $28  $29 $23 $33 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
     9 80C0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $28 $00 $33 $2F $35
    10 80D8 2E 24 00 21 2E 24 + .by  $2E $24 $00 $21 $2E $24 $00 $2D  $35 $33 $29 $23 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
    11 80F0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $08 $33 $23  $2F $32 $25 $00 $1A $00 $00 $13
    12 8108 34 2F 24 21 39 33 + .by  $34 $2F $24 $21 $39 $33 $00 $28  $29 $27 $28 $00 $33 $23 $2F $32  $25 $33 $0E $00 $02 $00 $1A $00
    13 8120 15 30 32 25 33 33 + .by  $15 $30 $32 $25 $33 $33 $00 $33  $34 $21 $32 $34 $00 $34 $2F $00  $22 $25 $27 $29 $2E $0E $00 $06
    14 8138 33 23 2F 32 25 1A + .by  $33 $23 $2F $32 $25 $1A $00 $06  $2C $29 $36 $25 $33 $1A $00 $6C  $6A $3B $FF $FF $6B $2B $2A $6F
    15 8150 FF 70 75 9B 69 2D + .by  $FF $70 $75 $9B $69 $2D $3D $76  $FF $63 $FF $FF $62 $78 $7A $34  $FF $33 $36 $1B $35 $32 $31 $2C
    16 8168 20 2E 6E FF 6D 2F + .by  $20 $2E $6E $FF $6D $2F $81 $72  $FF $65 $79 $7F $74 $77 $71 $39  $FF $30 $37 $7E $38 $3E $FF $66
    17 8180 68 64 FF 82 67 73 + .by  $68 $64 $FF $82 $67 $73 $61 $4C  $4A $3A $FF $FF $4B $5C $5E $4F  $FF $50 $55 $FF $49 $5F $7C $56
    18 8198 FF 43 FF FF 42 58 + .by  $FF $43 $FF $FF $42 $58 $5A $24  $FF $23 $26 $FF $25 $22 $21 $5B  $3B $5D $4E $FF $4D $3F $FF $52
    19 81B0 FF 45 59 FF 54 57 + .by  $FF $45 $59 $FF $54 $57 $51 $28  $FF $29 $27 $FF $40 $FF $FF $46  $48 $44 $FF $FF $47 $53 $41 $FF
    20 81C8 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    21 81E0 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    22 81F8 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    23 8210 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    24 8228 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    25 8240 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $70  $70 $44 $00 $10 $04 $04 $04 $04  $04 $00 $04 $00 $04 $00 $04 $00
    26 8258 04 00 04 00 04 00 + .by  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $00
    27 8270 04 00 04 00 04 00 + .by  $04 $00 $04 $00 $04 $00 $04 $41  $47 $82 $70 $70 $44 $00 $10 $10  $04 $04 $04 $04 $04 $04 $04 $04
    28 8288 04 04 04 04 04 04 + .by  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $41 $7A $82
Source: Mind Field.a65
    92
    93 829D			START
    94 829D BA				tsx
    95 829E 8E F9 89			stx MAIN.@halt+1
    96
    97 					.ifdef fmulinit
    98 					fmulinit
    99 					eif
   100
   101 					ift DATAORIGIN+VARINITSIZE > $BFFF
   102 					ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
   103 					els
   104 					@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
   104 				 MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1\ MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3\ MVA #0 @FILL.PTR2\ JSR @FILL
   104 82A1 A9 47 85 C6 A9 A3 +  MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1
   104 82A9 A9 0D 85 CA A9 00 +  MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3
   104 82B1 A9 00 85 C2		 MVA #0 @FILL.PTR2
   104 82B5 20 C7 8B		 JSR @FILL
   105 					eif
   106
   107 82B8 A2 0F			ldx #$0f
   108 82BA BD 40 03 9D FC 89 + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   109
   110 82C3 A2 00 86 CE			mvx #$00 bp					; lo BP = 0, X = 0 !!!
   111
   112 82C7				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: Mind Field.a65]
Source: Mind Field.a65
   113
   114 82C7			.local	MAIN						; PROCEDURE
   115
   116 					ift l_014E-*>3
   117 82C7 4C 75 89			jmp l_014E
   118 					eif
   119
   120 				; -----------------------------------------------------------
   121
   122 82CA			.local	SYSTEM						; UNIT
   123
   124 82CA			.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER
   125
   126 				; -----------------------------------------------------------
   127
   128 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   129 				; as Pointer
   130 82CA B5 80 85 CA			mva :STACKORIGIN,x VALUE
   131 82CE CA				dex						; sub bx, 1
   132
   133 				; -----------------------------------------------------------
   134
   135 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   136 				; as Pointer
   137 82CF B5 80 85 C6			mva :STACKORIGIN,x A
   138 82D3 B5 90 85 C7			mva :STACKORIGIN+STACKWIDTH,x A+1
   139 82D7 CA				dex						; sub bx, 1
   140
   141
   142 				; ---------------------  ASM Block 021  ---------------------
   143
   144 82D8 A0 00			ldy #0
   145 82DA A5 CA 91 C6			mva value (edx),y
   146
   147
   148 				; -----------------------------------------------------------
   149
   150 = 00C6			A	= edx
   151 = 00CA			VALUE	= ecx
   152
   153 82DE			@exit
   154 					.ifdef @new
   155 					@FreeMem #@VarData #@VarDataSize
   156 					eif
   157 82DE 60				rts						; ret
   158 				.endl
   159
   160 82DF			.local	FILLCHAR_0175					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   161
   162 				; -----------------------------------------------------------
   163
   164 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   165 				; as Pointer
   166 82DF B5 80 85 C2			mva :STACKORIGIN,x VALUE
   167 82E3 CA				dex						; sub bx, 1
   168
   169 				; -----------------------------------------------------------
   170
   171 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   172 				; as Pointer
   173 82E4 B5 80 85 CA			mva :STACKORIGIN,x COUNT
   174 82E8 B5 90 85 CB			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   175 82EC CA				dex						; sub bx, 1
   176
   177 				; -----------------------------------------------------------
   178
   179 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   180 				; as Pointer
   181 82ED B5 80 85 C6			mva :STACKORIGIN,x A
   182 82F1 B5 90 85 C7			mva :STACKORIGIN+STACKWIDTH,x A+1
   183 82F5 CA				dex						; sub bx, 1
   184
   185
   186 				; ---------------------  ASM Block 024  ---------------------
   187
   188 82F6 20 C7 8B			jsr @fill
   189
   190
   191 				; -----------------------------------------------------------
   192
   193 = 00C6			A	= edx
   194 = 00CA			COUNT	= ecx
   195 = 00C2			VALUE	= eax
   196
   197 82F9			@exit
   198 					.ifdef @new
   199 					@FreeMem #@VarData #@VarDataSize
   200 					eif
   201 82F9 60				rts						; ret
   202 				.endl
   203
   204 82FA			.local	MOVE_0188					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   205
   206 				; -----------------------------------------------------------
   207
   208 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   209 				; as Pointer
   210 82FA B5 80 85 C2			mva :STACKORIGIN,x COUNT
   211 82FE B5 90 85 C3			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   212 8302 CA				dex						; sub bx, 1
   213
   214 				; -----------------------------------------------------------
   215
   216 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   217 				; as Pointer
   218 8303 B5 80 85 CA			mva :STACKORIGIN,x DEST
   219 8307 B5 90 85 CB			mva :STACKORIGIN+STACKWIDTH,x DEST+1
   220 830B CA				dex						; sub bx, 1
   221
   222 				; -----------------------------------------------------------
   223
   224 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   225 				; as Pointer
   226 830C B5 80 85 C6			mva :STACKORIGIN,x SOURCE
   227 8310 B5 90 85 C7			mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
   228 8314 CA				dex						; sub bx, 1
   229
   230
   231 				; ---------------------  ASM Block 033  ---------------------
   232
   233 8315 20 73 8B			jsr @move
   234
   235
   236 				; -----------------------------------------------------------
   237
   238 = 00C6			SOURCE	= edx
   239 = 00CA			DEST	= ecx
   240 = 00C2			COUNT	= eax
   241
   242 8318			@exit
   243 					.ifdef @new
   244 					@FreeMem #@VarData #@VarDataSize
   245 					eif
   246 8318 60				rts						; ret
   247 				.endl
   248
   249 				; -----------------------------------------------------------
   250
   251 = 0648			M_PI_2	= $0648
   252 = 0192			D_PI_2	= $0192
   253 = 0004			D_PI_180	= $0004
   254 = 0000			MGTIA	= $0000
   255 = 0080			MVBXE	= $0080
   256 = 0010			WINDOW	= $0010
   257 = 0020			NARROW	= $0020
   258 = 0000			VBXE_XDLADR	= $0000
   259 = 0100			VBXE_BCBADR	= $0100
   260 = 1000			VBXE_MAPADR	= $1000
   261 = 5000			VBXE_OVRADR	= $5000
   262 = B000			VBXE_WINDOW	= $B000
   263 = 0000			IDLI	= $0000
   264 = 0001			IVBL	= $0001
   265 = 00FE			CH_DELCHR	= $00FE
   266 = 009B			CH_ENTER	= $009B
   267 = 001B			CH_ESC	= $001B
   268 = 001C			CH_CURS_UP	= $001C
   269 = 001D			CH_CURS_DOWN	= $001D
   270 = 001E			CH_CURS_LEFT	= $001E
   271 = 001F			CH_CURS_RIGHT	= $001F
   272 = 007F			CH_TAB	= $007F
   273 = 009B			CH_EOL	= $009B
   274 = 007D			CH_CLR	= $007D
   275 = 00FD			CH_BELL	= $00FD
   276 = 007E			CH_DEL	= $007E
   277 = 009C			CH_DELLINE	= $009C
   278 = 009D			CH_INSLINE	= $009D
   279 = 0000			COLOR_BLACK	= $0000
   280 = 000E			COLOR_WHITE	= $000E
   281 = 0032			COLOR_RED	= $0032
   282 = 0096			COLOR_CYAN	= $0096
   283 = 0068			COLOR_VIOLET	= $0068
   284 = 00C4			COLOR_GREEN	= $00C4
   285 = 0074			COLOR_BLUE	= $0074
   286 = 00EE			COLOR_YELLOW	= $00EE
   287 = 004A			COLOR_ORANGE	= $004A
   288 = 00E4			COLOR_BROWN	= $00E4
   289 = 003C			COLOR_LIGHTRED	= $003C
   290 = 0004			COLOR_GRAY1	= $0004
   291 = 0006			COLOR_GRAY2	= $0006
   292 = 000A			COLOR_GRAY3	= $000A
   293 = 00CC			COLOR_LIGHTGREEN	= $00CC
   294 = 007C			COLOR_LIGHTBLUE	= $007C
   295 = 0004			FMOPENREAD	= $0004
   296 = 0008			FMOPENWRITE	= $0008
   297 = 0009			FMOPENAPPEND	= $0009
   298 = 000C			FMOPENREADWRITE	= $000C
   299 = A000			SCREENWIDTH	= DATAORIGIN+$0000
   300 = A002			SCREENHEIGHT	= DATAORIGIN+$0002
   301 = A004			FILEMODE	= DATAORIGIN+$0004
   302 = A005			SCREENMODE	= DATAORIGIN+$0005
   303 = A006			IORESULT	= DATAORIGIN+$0006
   304 = A007			EOLN	= DATAORIGIN+$0007
   305 = A008			RNDSEED	= DATAORIGIN+$0008
   306
   307 				.endl							; UNIT SYSTEM
   308
   309 				; -----------------------------------------------------------
   310
   311 8319			.local	ATARI						; UNIT
   312
   313 				; -----------------------------------------------------------
   314
   315 = 0012			RTCLOK	= $0012
   316 = 004D			ATRACT	= $004D
   317 = 0052			LMARGIN	= $0052
   318 = 0053			RMARGIN	= $0053
   319 = 0054			ROWCRS	= $0054
   320 = 0055			COLCRS	= $0055
   321 = 0057			DINDEX	= $0057
   322 = 0058			SAVMSC	= $0058
   323 = 0200			VDSLST	= $0200
   324 = 0202			VPRCED	= $0202
   325 = 0204			VINTER	= $0204
   326 = 0206			VBREAK	= $0206
   327 = 0208			VKEYBD	= $0208
   328 = 020A			VSERIN	= $020A
   329 = 020C			VSEROR	= $020C
   330 = 020E			VSEROC	= $020E
   331 = 0210			VTIMR1	= $0210
   332 = 0212			VTIMR2	= $0212
   333 = 0214			VTIMR3	= $0214
   334 = 0216			VIMIRQ	= $0216
   335 = 0218			CDTMV1	= $0218
   336 = 021A			CDTMV2	= $021A
   337 = 021C			CDTMV3	= $021C
   338 = 022E			CDTMV4	= $022E
   339 = 0220			CDTMV5	= $0220
   340 = 0222			VVBLKI	= $0222
   341 = 0224			VVBLKD	= $0224
   342 = 0226			CDTMA1	= $0226
   343 = 0228			CDTMA2	= $0228
   344 = 022F			SDNCTK	= $022F
   345 = 0230			SDLSTW	= $0230
   346 = 0230			SDLSTL	= $0230
   347 = 0231			SDLSTH	= $0231
   348 = 0290			TXTROW	= $0290
   349 = 0291			TXTCOL	= $0291
   350 = 0293			TINDEX	= $0293
   351 = 0294			TXTMSC	= $0294
   352 = 022F			SDMCTL	= $022F
   353 = 026F			GPRIOR	= $026F
   354 = 02F0			CRSINH	= $02F0
   355 = 02F3			CHACT	= $02F3
   356 = 02F4			CHBAS	= $02F4
   357 = 02FC			CH	= $02FC
   358 = 02C0			PCOLR0	= $02C0
   359 = 02C1			PCOLR1	= $02C1
   360 = 02C2			PCOLR2	= $02C2
   361 = 02C3			PCOLR3	= $02C3
   362 = 02C4			COLOR0	= $02C4
   363 = 02C5			COLOR1	= $02C5
   364 = 02C6			COLOR2	= $02C6
   365 = 02C7			COLOR3	= $02C7
   366 = 02C8			COLOR4	= $02C8
   367 = D000			HPOSP0	= $D000
   368 = D001			HPOSP1	= $D001
   369 = D002			HPOSP2	= $D002
   370 = D003			HPOSP3	= $D003
   371 = D004			HPOSM0	= $D004
   372 = D005			HPOSM1	= $D005
   373 = D006			HPOSM2	= $D006
   374 = D007			HPOSM3	= $D007
   375 = D008			SIZEP0	= $D008
   376 = D009			SIZEP1	= $D009
   377 = D00A			SIZEP2	= $D00A
   378 = D00B			SIZEP3	= $D00B
   379 = D00C			SIZEM	= $D00C
   380 = D00D			GRAFP0	= $D00D
   381 = D00E			GRAFP1	= $D00E
   382 = D00F			GRAFP2	= $D00F
   383 = D010			GRAFP3	= $D010
   384 = D011			GRAFM	= $D011
   385 = D014			PAL	= $D014
   386 = D012			COLPM0	= $D012
   387 = D013			COLPM1	= $D013
   388 = D014			COLPM2	= $D014
   389 = D015			COLPM3	= $D015
   390 = D016			COLPF0	= $D016
   391 = D017			COLPF1	= $D017
   392 = D018			COLPF2	= $D018
   393 = D019			COLPF3	= $D019
   394 = D01A			COLBK	= $D01A
   395 = D01B			PRIOR	= $D01B
   396 = D01D			GRACTL	= $D01D
   397 = D01E			HITCLR	= $D01E
   398 = D01F			CONSOL	= $D01F
   399 = D200			AUDF1	= $D200
   400 = D201			AUDC1	= $D201
   401 = D202			AUDF2	= $D202
   402 = D203			AUDC2	= $D203
   403 = D204			AUDF3	= $D204
   404 = D205			AUDC3	= $D205
   405 = D206			AUDF4	= $D206
   406 = D207			AUDC4	= $D207
   407 = D208			AUDCTL	= $D208
   408 = D209			STIMER	= $D209
   409 = D20A			SKRES	= $D20A
   410 = D20B			POTGO	= $D20B
   411 = D20D			SEROUT	= $D20D
   412 = D20E			IRQEN	= $D20E
   413 = D20F			SKCTL	= $D20F
   414 = D20F			SKSTAT	= $D20F
   415 = D200			POT0	= $D200
   416 = D201			POT1	= $D201
   417 = D202			POT2	= $D202
   418 = D203			POT3	= $D203
   419 = D204			POT4	= $D204
   420 = D205			POT5	= $D205
   421 = D206			POT6	= $D206
   422 = D207			POT7	= $D207
   423 = D208			ALLPOT	= $D208
   424 = D208			POTST	= $D208
   425 = D209			KBCODE	= $D209
   426 = D20A			RANDOM	= $D20A
   427 = D20D			SERIN	= $D20D
   428 = D20E			IRQST	= $D20E
   429 = D300			PORTA	= $D300
   430 = D301			PORTB	= $D301
   431 = D302			PCCTL	= $D302
   432 = D303			PBCTL	= $D303
   433 = D400			DMACTL	= $D400
   434 = D401			CHACTL	= $D401
   435 = D402			DLISTW	= $D402
   436 = D402			DLISTL	= $D402
   437 = D403			DLISTH	= $D403
   438 = D404			HSCROL	= $D404
   439 = D405			VSCROL	= $D405
   440 = D407			PMBASE	= $D407
   441 = D409			CHBASE	= $D409
   442 = D40A			WSYNC	= $D40A
   443 = D40B			VCOUNT	= $D40B
   444 = D40C			PENH	= $D40C
   445 = D40D			PENV	= $D40D
   446 = D40E			NMIEN	= $D40E
   447 = D40F			NMIRES	= $D40F
   448 = D40F			NMIST	= $D40F
   449
   450 				.endl							; UNIT ATARI
   451
   452 				; -----------------------------------------------------------
   453
   454 8319			.local	B_SYSTEM					; UNIT
   455
   456 8319			.local	SETCHARSET					; PROCEDURE
   457
   458 				; -----------------------------------------------------------
   459
   460 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   461 				; as Pointer
   462 8319 B5 80 8D 0B A0		mva :STACKORIGIN,x MSB
   463 831E CA				dex						; sub bx, 1
   464
   465 					ift l_01AE-*>3
   466 					jmp l_01AE
   467 					eif
   468
   469 				; IfThenEpilog
   470 831F			l_01AE
   471
   472 				; optimize OK (B_SYSTEM), line = 218
   473
   474 831F AD 0B A0 8D 09 D4		mva MSB ATARI.CHBASE
   475
   476 				; -----------------------------------------------------------
   477
   478 = A00B			MSB	= DATAORIGIN+$000B
   479
   480 = A00B			@VarData	= MSB
   481 = 0001			@VarDataSize	= 1
   482
   483
   484 8325			@exit
   485 					.ifdef @new
   486 					@FreeMem #@VarData #@VarDataSize
   487 					eif
   488 8325 60				rts						; ret
   489 				.endl
   490
   491 				; -----------------------------------------------------------
   492
   493 = A00A			__NMIEN	= DATAORIGIN+$000A
   494 = 0080			PORTB_SELFTEST_OFF	= $0080
   495 = 0002			PORTB_BASIC_OFF	= $0002
   496 = 0001			PORTB_SYSTEM_ON	= $0001
   497
   498 				.endl							; UNIT B_SYSTEM
   499
   500 				; -----------------------------------------------------------
   501
   502 8326			.local	SYSUTILS					; UNIT
   503
   504 8326			.local	INTTOSTR					; FUNCTION | ASSEMBLER
   505
   506 				; -----------------------------------------------------------
   507
   508 				; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
   509 				; as Pointer
   510 8326 B5 80 8D 0C A0		mva :STACKORIGIN,x A
   511 832B B5 90 8D 0D A0		mva :STACKORIGIN+STACKWIDTH,x A+1
   512 8330 B5 A0 8D 0E A0		mva :STACKORIGIN+STACKWIDTH*2,x A+2
   513 8335 B5 B0 8D 0F A0		mva :STACKORIGIN+STACKWIDTH*3,x A+3
   514 833A CA				dex						; sub bx, 1
   515
   516
   517 				; ---------------------  ASM Block 060  ---------------------
   518
   519 833B 8A 48			txa:pha
   520
   521 833D E8				inx
   522
   523 					@ValueToStr #@printINT
   523 				 LDY> @PRINTINT\ LDA< @PRINTINT\ JSR @VALUETOSTR
   523 833E A0 8A		 LDY> @PRINTINT
   523 8340 A9 97		 LDA< @PRINTINT
   523 8342 20 22 8B		 JSR @VALUETOSTR
   524
   525 8345 A9 00 8D 10 A0 A9 + 	mwa #@buf Result
   526
   527 834F 68 AA			pla:tax
   528
   529
   530 8351			@exit
   531
   532 				; -----------------------------------------------------------
   533
   534 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   535 				; as Pointer
   536
   537 8351 E8				inx						; add bx, 1
   538 8352 AD 10 A0 95 80		mva RESULT :STACKORIGIN,x
   539 8357 AD 11 A0 95 90		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   540
   541 					.ifdef @new
   542 					@FreeMem #@VarData #@VarDataSize
   543 					eif
   544
   545 				; -----------------------------------------------------------
   546
   547 = A00C			A	= DATAORIGIN+$000C
   548 = A010			RESULT	= DATAORIGIN+$0010
   549
   550 = A00C			@VarData	= A
   551 = 0006			@VarDataSize	= 6
   552
   553 835C 60				rts						; ret
   554 				.endl
   555
   556 				; -----------------------------------------------------------
   557
   558 = 0001			FAREADONLY	= $0001
   559 = 0002			FAHIDDEN	= $0002
   560 = 0004			FASYSFILE	= $0004
   561 = 0008			FAVOLUMEID	= $0008
   562 = 0010			FADIRECTORY	= $0010
   563 = 0020			FAARCHIVE	= $0020
   564 = 003F			FAANYFILE	= $003F
   565
   566 				.endl							; UNIT SYSUTILS
   567
   568 				; -----------------------------------------------------------
   569
   570 835D			.local	B_CRT						; UNIT
   571
   572 835D			.local	ATASCII2ANTIC_01CF				; FUNCTION | OVERLOAD
   573
   574 				; -----------------------------------------------------------
   575
   576 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   577 				; as Pointer
   578 835D B5 80 8D 1B A0		mva :STACKORIGIN,x C
   579 8362 CA				dex						; sub bx, 1
   580
   581 					ift l_01D8-*>3
   582 					jmp l_01D8
   583 					eif
   584
   585 				; IfThenEpilog
   586 8363			l_01D8
   587
   588 				; ---------------------  ASM Block 064  ---------------------
   589
   590
   591 8363 AD 1B A0		        lda c
   592 8366 0A			        asl
   593 8367 08			        php
   594 8368 C9 C0		        cmp #2*$60
   595 836A B0 06		        bcs @+
   596 836C E9 3F		        sbc #2*$20-1
   597 836E B0 02		        bcs @+
   598 8370 69 C0		        adc #2*$60
   599 8372 28			@       plp
   600 8373 6A			        ror
   601 8374 8D 1C A0		        sta result;
   602 				    
   603
   604 8377			@exit
   605
   606 				; -----------------------------------------------------------
   607
   608 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   609 				; as Pointer
   610
   611 8377 E8				inx						; add bx, 1
   612 8378 AD 1C A0 95 80		mva RESULT :STACKORIGIN,x
   613
   614 					.ifdef @new
   615 					@FreeMem #@VarData #@VarDataSize
   616 					eif
   617
   618 				; -----------------------------------------------------------
   619
   620 = A01B			C	= DATAORIGIN+$001B
   621 = A01C			RESULT	= DATAORIGIN+$001C
   622
   623 = A01B			@VarData	= C
   624 = 0002			@VarDataSize	= 2
   625
   626 837D 60				rts						; ret
   627 				.endl
   628
   629 837E			.local	ATASCII2ANTIC_01DC				; FUNCTION | OVERLOAD
   630
   631 				; -----------------------------------------------------------
   632
   633 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   634 				; as Pointer
   635 837E B5 80 8D FD 83		mva :STACKORIGIN,x S
   636 8383 B5 90 8D FE 83		mva :STACKORIGIN+STACKWIDTH,x S+1
   637 8388 CA				dex						; sub bx, 1
   638 					@move S #adr.S #256
   638 				 MWA S @MOVE.PTR1\ MWA #ADR.S @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
   638 8389 AD FD 83 85 C6 AD +  MWA S @MOVE.PTR1
   638 8393 A9 1D 85 CA A9 A0 +  MWA #ADR.S @MOVE.PTR2
   638 839B A9 00 85 C2 A9 01 +  MWA #256 @MOVE.PTR3
   638 83A3 20 73 8B		 JSR @MOVE
   639 83A6 A9 1D 8D FD 83 A9 + 	mwa #adr.S S
   640
   641 					ift l_01E5-*>3
   642 					jmp l_01E5
   643 					eif
   644
   645 				; IfThenEpilog
   646 83B0			l_01E5
   647
   648 				; optimize OK (B_CRT), line = 468
   649
   650 83B0 AD 1D A0			lda adr.S+$00
   651 83B3 8D 1D A1			sta adr.RESULT+$00
   652 				; For
   653
   654 				; optimize OK (B_CRT), line = 469
   655
   656 83B6 A9 01 8D 1D A2		mva #$01 I
   657
   658 				; optimize OK (B_CRT), line = 469
   659
   660 83BB AD 1D A0			lda adr.S+$00
   661 83BE 8D 1E A2			sta @FORTMP_505
   662 				; To
   663 83C1			l_01FF
   664
   665 				; ForToDoCondition
   666
   667 				; optimize OK (B_CRT), line = 469
   668
   669 83C1 AD 1D A2			lda I
   670 83C4 CD 1E A2			cmp @FORTMP_505
   671 83C7 90 05			bcc *+7
   672 83C9 F0 03			beq *+5
   673
   674 				; ForToDoProlog
   675 83CB 4C F1 83			jmp l_020D
   676
   677 				; optimize FAIL ('ATASCII2ANTIC_01CF', B_CRT), line = 470
   678 83CE E8				inx
   679 83CF AD 1D A2 95 80		mva I :STACKORIGIN,x
   680 83D4 E8				inx
   681 83D5 AC 1D A2			ldy I 
   682 83D8 B9 1D A0 95 80		mva adr.S,y :STACKORIGIN,x
   683 83DD 20 5D 83			jsr ATASCII2ANTIC_01CF
   684 83E0 B4 7F			ldy :STACKORIGIN-1,x
   685 83E2 B5 80 99 1D A1		mva :STACKORIGIN,x adr.RESULT,y
   686 83E7 CA				dex
   687 83E8 CA				dex
   688
   689 				; ForToDoEpilog
   690 83E9			c_01FF
   691 83E9 EE 1D A2			inc I						; inc ptr byte [CounterAddress]
   692
   693 83EC F0 03			seq
   694
   695 				; WhileDoEpilog
   696 83EE 4C C1 83			jmp l_01FF
   697 83F1			l_020D
   698 83F1			b_01FF
   699
   700 83F1			@exit
   701
   702 				; -----------------------------------------------------------
   703
   704 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   705 				; as Pointer
   706
   707 83F1 E8				inx						; add bx, 1
   708 83F2 AD FF 83 95 80		mva RESULT :STACKORIGIN,x
   709 83F7 AD 00 84 95 90		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   710
   711 					.ifdef @new
   712 					@FreeMem #@VarData #@VarDataSize
   713 					eif
   714
   715 				; -----------------------------------------------------------
   716
   717 = A01D			adr.S	= DATAORIGIN+$001D
   718 83FC			.var S	= adr.S .word
   719 = A11D			adr.RESULT	= DATAORIGIN+$011D
   720 83FC			.var RESULT	= adr.RESULT .word
   721 = A21D			I	= DATAORIGIN+$021D
   722 = A21E			@FORTMP_505	= DATAORIGIN+$021E
   723
   724 = 83FD			@VarData	= S
   725 = 0202			@VarDataSize	= 514
   726
   727 83FC 60				rts						; ret
   728 = 83FD 1D A0		S
   728 = 83FF 1D A1		RESULT
   728 				.endl
   729
   730 8401			.local	CRT_INIT_0223					; PROCEDURE | OVERLOAD
   731
   732 				; -----------------------------------------------------------
   733
   734 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   735 				; as Pointer
   736 8401 B5 80 8D 22 A2		mva :STACKORIGIN,x HEIGHT
   737 8406 CA				dex						; sub bx, 1
   738
   739 				; -----------------------------------------------------------
   740
   741 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   742 				; as Pointer
   743 8407 B5 80 8D 21 A2		mva :STACKORIGIN,x WIDTH
   744 840C CA				dex						; sub bx, 1
   745
   746 				; -----------------------------------------------------------
   747
   748 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   749 				; as Pointer
   750 840D B5 80 8D 1F A2		mva :STACKORIGIN,x VRAM_ADDRESS
   751 8412 B5 90 8D 20 A2		mva :STACKORIGIN+STACKWIDTH,x VRAM_ADDRESS+1
   752 8417 CA				dex						; sub bx, 1
   753
   754 					ift l_0238-*>3
   755 					jmp l_0238
   756 					eif
   757
   758 				; IfThenEpilog
   759 8418			l_0238
   760
   761 				; optimize OK (B_CRT), line = 483
   762
   763 8418 AD 1F A2 8D 12 A0		mva VRAM_ADDRESS CRT_VRAM
   764 841E AD 20 A2 8D 13 A0		mva VRAM_ADDRESS+1 CRT_VRAM+1
   765
   766 				; optimize OK (B_CRT), line = 484
   767
   768 8424 AD 21 A2 8D 16 A0		mva WIDTH CRT_SCREENWIDTH
   769
   770 				; optimize OK (B_CRT), line = 485
   771
   772 842A AD 22 A2 8D 17 A0		mva HEIGHT CRT_SCREENHEIGHT
   773
   774 				; optimize OK (B_CRT), line = 486
   775
   776 8430 AD 22 A2			lda HEIGHT
   777 8433 85 CA			sta :ecx
   778 8435 AD 21 A2			lda WIDTH
   779 8438 85 C2			sta :eax
   780 					.ifdef fmulinit
   781 					fmulu_8
   782 					els
   783 843A 20 5E 8A			imulCL
   784 					eif
   785 843D A5 C2			lda :eax
   786 843F 8D 14 A0			sta CRT_SIZE
   787 8442 A5 C3			lda :eax+1
   788 8444 8D 15 A0			sta CRT_SIZE+1
   789
   790 				; optimize OK (B_CRT), line = 487
   791
   792 8447 AD 12 A0 8D 18 A0		mva CRT_VRAM CRT_CURSOR
   793 844D AD 13 A0 8D 19 A0		mva CRT_VRAM+1 CRT_CURSOR+1
   794
   795 				; optimize OK (B_CRT), line = 488
   796
   797 8453 A9 00 8D 1A A0		mva #$00 CRT_LEFTMARGIN
   798
   799 				; -----------------------------------------------------------
   800
   801 = A21F			VRAM_ADDRESS	= DATAORIGIN+$021F
   802 = A221			WIDTH	= DATAORIGIN+$0221
   803 = A222			HEIGHT	= DATAORIGIN+$0222
   804
   805 = A21F			@VarData	= VRAM_ADDRESS
   806 = 0004			@VarDataSize	= 4
   807
   808
   809 8458			@exit
   810 					.ifdef @new
   811 					@FreeMem #@VarData #@VarDataSize
   812 					eif
   813 8458 60				rts						; ret
   814 				.endl
   815
   816 8459			.local	CRT_CLEAR_0271					; PROCEDURE | OVERLOAD
   817
   818 					ift l_0274-*>3
   819 					jmp l_0274
   820 					eif
   821
   822 				; IfThenEpilog
   823 8459			l_0274
   824
   825 				; optimize OK (B_CRT), line = 504
   826
   827 8459 AD 12 A0			lda CRT_VRAM
   828 845C 85 C6			sta :edx
   829 845E AD 13 A0			lda CRT_VRAM+1
   830 8461 85 C7			sta :edx+1
   831 8463 AD 14 A0			lda CRT_SIZE
   832 8466 85 CA			sta :ecx
   833 8468 AD 15 A0			lda CRT_SIZE+1
   834 846B 85 CB			sta :ecx+1
   835 846D A9 00			lda #$00
   836 846F 85 C2			sta :eax
   837 8471 20 C7 8B			jsr @fill
   838
   839 				; optimize OK (B_CRT), line = 505
   840
   841 8474 AD 12 A0 8D 18 A0		mva CRT_VRAM CRT_CURSOR
   842 847A AD 13 A0 8D 19 A0		mva CRT_VRAM+1 CRT_CURSOR+1
   843
   844 8480			@exit
   845 					.ifdef @new
   846 					@FreeMem #@VarData #@VarDataSize
   847 					eif
   848 8480 60				rts						; ret
   849 				.endl
   850
   851 8481			.local	CRT_GOTOXY					; PROCEDURE
   852
   853 				; -----------------------------------------------------------
   854
   855 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   856 				; as Pointer
   857 8481 B5 80 8D 24 A2		mva :STACKORIGIN,x Y
   858 8486 CA				dex						; sub bx, 1
   859
   860 				; -----------------------------------------------------------
   861
   862 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   863 				; as Pointer
   864 8487 B5 80 8D 23 A2		mva :STACKORIGIN,x X
   865 848C CA				dex						; sub bx, 1
   866
   867 					ift l_0292-*>3
   868 					jmp l_0292
   869 					eif
   870
   871 				; IfThenEpilog
   872 848D			l_0292
   873
   874 				; optimize OK (B_CRT), line = 516
   875
   876 848D AD 16 A0			lda CRT_SCREENWIDTH
   877 8490 85 CA			sta :ecx
   878 8492 AD 24 A2			lda Y
   879 8495 85 C2			sta :eax
   880 					.ifdef fmulinit
   881 					fmulu_8
   882 					els
   883 8497 20 5E 8A			imulCL
   884 					eif
   885 849A A5 C2			lda :eax
   886 849C 18 6D 23 A2			add X
   887 84A0 85 89			sta :STACKORIGIN+9
   888 84A2 A5 C3			lda :eax+1
   889 84A4 69 00			adc #$00
   890 84A6 85 99			sta :STACKORIGIN+STACKWIDTH+9
   891 84A8 A5 89			lda :STACKORIGIN+9
   892 84AA 18 6D 12 A0			add CRT_VRAM
   893 84AE 8D 18 A0			sta CRT_CURSOR
   894 84B1 A5 99			lda :STACKORIGIN+STACKWIDTH+9
   895 84B3 6D 13 A0			adc CRT_VRAM+1
   896 84B6 8D 19 A0			sta CRT_CURSOR+1
   897
   898 				; -----------------------------------------------------------
   899
   900 = A223			X	= DATAORIGIN+$0223
   901 = A224			Y	= DATAORIGIN+$0224
   902
   903 = A223			@VarData	= X
   904 = 0002			@VarDataSize	= 2
   905
   906
   907 84B9			@exit
   908 					.ifdef @new
   909 					@FreeMem #@VarData #@VarDataSize
   910 					eif
   911 84B9 60				rts						; ret
   912 				.endl
   913
   914 84BA			.local	CRT_WRITE_02AD					; PROCEDURE | OVERLOAD
   915
   916 				; -----------------------------------------------------------
   917
   918 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   919 				; as Pointer
   920 84BA B5 80 8D 24 85		mva :STACKORIGIN,x S
   921 84BF B5 90 8D 25 85		mva :STACKORIGIN+STACKWIDTH,x S+1
   922 84C4 CA				dex						; sub bx, 1
   923 					@move S #adr.S #256
   923 				 MWA S @MOVE.PTR1\ MWA #ADR.S @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
   923 84C5 AD 24 85 85 C6 AD +  MWA S @MOVE.PTR1
   923 84CF A9 25 85 CA A9 A2 +  MWA #ADR.S @MOVE.PTR2
   923 84D7 A9 00 85 C2 A9 01 +  MWA #256 @MOVE.PTR3
   923 84DF 20 73 8B		 JSR @MOVE
   924 84E2 A9 25 8D 24 85 A9 + 	mwa #adr.S S
   925
   926 					ift l_02B6-*>3
   927 					jmp l_02B6
   928 					eif
   929
   930 				; IfThenEpilog
   931 84EC			l_02B6
   932
   933 				; optimize OK (B_CRT), line = 531
   934
   935 84EC AD 24 85			lda S
   936 84EF 18 69 01			add #$01
   937 84F2 85 C6			sta :edx
   938 84F4 AD 25 85			lda S+1
   939 84F7 69 00			adc #$00
   940 84F9 85 C7			sta :edx+1
   941 84FB AD 25 A2			lda adr.S+$00
   942 84FE 85 C2			sta :eax
   943 8500 AD 18 A0			lda CRT_CURSOR
   944 8503 85 CA			sta :ecx
   945 8505 AD 19 A0			lda CRT_CURSOR+1
   946 8508 85 CB			sta :ecx+1
   947 850A A9 00			lda #$00
   948 850C 85 C3			sta :eax+1
   949 850E 20 73 8B			jsr @move
   950
   951 				; optimize OK (B_CRT), line = 532
   952
   953 8511 AD 18 A0			lda CRT_CURSOR
   954 8514 18 6D 25 A2			add adr.S+$00
   955 8518 8D 18 A0			sta CRT_CURSOR
   956 851B AD 19 A0			lda CRT_CURSOR+1
   957 851E 69 00			adc #$00
   958 8520 8D 19 A0			sta CRT_CURSOR+1
   959
   960 				; -----------------------------------------------------------
   961
   962 = A225			adr.S	= DATAORIGIN+$0225
   963 8523			.var S	= adr.S .word
   964
   965 = 8524			@VarData	= S
   966 = 0100			@VarDataSize	= 256
   967
   968
   969 8523			@exit
   970 					.ifdef @new
   971 					@FreeMem #@VarData #@VarDataSize
   972 					eif
   973 8523 60				rts						; ret
   974 = 8524 25 A2		S
   974 				.endl
   975
   976 8526			.local	CRT_WRITE_02C3					; PROCEDURE | OVERLOAD
   977
   978 				; -----------------------------------------------------------
   979
   980 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   981 				; as Pointer
   982 8526 B5 80 8D 25 A3		mva :STACKORIGIN,x C
   983 852B CA				dex						; sub bx, 1
   984
   985 					ift l_02CC-*>3
   986 					jmp l_02CC
   987 					eif
   988
   989 				; IfThenEpilog
   990 852C			l_02CC
   991
   992 				; optimize OK (B_CRT), line = 537
   993
   994 852C AD 19 A0			lda CRT_CURSOR+1
   995 852F 85 CF			sta :bp+1
   996 8531 AC 18 A0			ldy CRT_CURSOR
   997 8534 AD 25 A3			lda C
   998 8537 91 CE			sta (:bp),y
   999
  1000 				; optimize FAIL (0, B_CRT), line = 538
  1001 8539 EE 18 A0 D0 03 EE + 	inw CRT_CURSOR
  1002
  1003 				; -----------------------------------------------------------
  1004
  1005 = A325			C	= DATAORIGIN+$0325
  1006
  1007 = A325			@VarData	= C
  1008 = 0001			@VarDataSize	= 1
  1009
  1010
  1011 8541			@exit
  1012 					.ifdef @new
  1013 					@FreeMem #@VarData #@VarDataSize
  1014 					eif
  1015 8541 60				rts						; ret
  1016 				.endl
  1017
  1018 8542			.local	CRT_WRITE_02D7					; PROCEDURE | OVERLOAD
  1019
  1020 				; -----------------------------------------------------------
  1021
  1022 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1023 				; as Pointer
  1024 8542 B5 80 8D 26 A3		mva :STACKORIGIN,x NUM
  1025 8547 CA				dex						; sub bx, 1
  1026
  1027 					ift l_02E0-*>3
  1028 					jmp l_02E0
  1029 					eif
  1030
  1031 				; IfThenEpilog
  1032 8548			l_02E0
  1033
  1034 				; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 543
  1035 8548 E8				inx
  1036 8549 AD 26 A3 95 80		mva NUM :STACKORIGIN,x
  1037 854E 20 3B 8A			jsr @expandToCARD.BYTE
  1038 8551 20 26 83			jsr SYSUTILS.INTTOSTR
  1039 8554 20 7E 83			jsr ATASCII2ANTIC_01DC
  1040 8557 20 BA 84			jsr CRT_WRITE_02AD
  1041
  1042 				; -----------------------------------------------------------
  1043
  1044 = A326			NUM	= DATAORIGIN+$0326
  1045
  1046 = A326			@VarData	= NUM
  1047 = 0001			@VarDataSize	= 1
  1048
  1049
  1050 855A			@exit
  1051 					.ifdef @new
  1052 					@FreeMem #@VarData #@VarDataSize
  1053 					eif
  1054 855A 60				rts						; ret
  1055 				.endl
  1056
  1057 855B			.local	CRT_WRITE_02E7					; PROCEDURE | OVERLOAD
  1058
  1059 				; -----------------------------------------------------------
  1060
  1061 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  1062 				; as Pointer
  1063 855B B5 80 8D 27 A3		mva :STACKORIGIN,x NUM
  1064 8560 B5 90 8D 28 A3		mva :STACKORIGIN+STACKWIDTH,x NUM+1
  1065 8565 CA				dex						; sub bx, 1
  1066
  1067 					ift l_02F0-*>3
  1068 					jmp l_02F0
  1069 					eif
  1070
  1071 				; IfThenEpilog
  1072 8566			l_02F0
  1073
  1074 				; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 548
  1075 8566 E8				inx
  1076 8567 AD 27 A3 95 80		mva NUM :STACKORIGIN,x
  1077 856C AD 28 A3 95 90		mva NUM+1 :STACKORIGIN+STACKWIDTH,x
  1078 8571 20 2F 8A			jsr @expandToCARD.WORD
  1079 8574 20 26 83			jsr SYSUTILS.INTTOSTR
  1080 8577 20 7E 83			jsr ATASCII2ANTIC_01DC
  1081 857A 20 BA 84			jsr CRT_WRITE_02AD
  1082
  1083 				; -----------------------------------------------------------
  1084
  1085 = A327			NUM	= DATAORIGIN+$0327
  1086
  1087 = A327			@VarData	= NUM
  1088 = 0002			@VarDataSize	= 2
  1089
  1090
  1091 857D			@exit
  1092 					.ifdef @new
  1093 					@FreeMem #@VarData #@VarDataSize
  1094 					eif
  1095 857D 60				rts						; ret
  1096 				.endl
  1097
  1098 857E			.local	CRT_KEYPRESSED					; FUNCTION
  1099
  1100 					ift l_02F9-*>3
  1101 					jmp l_02F9
  1102 					eif
  1103
  1104 				; IfThenEpilog
  1105 857E			l_02F9
  1106
  1107 				; optimize OK (B_CRT), line = 592
  1108
  1109 857E A9 00 8D 29 A3		mva #$00 RESULT
  1110
  1111 				; optimize OK (B_CRT), line = 593
  1112
  1113 8583 AD 0F D2			lda ATARI.SKSTAT
  1114 8586 A0 01			ldy #1
  1115 8588 29 04			and #$04
  1116 858A F0 01			beq @+
  1117 858C 88				dey
  1118 858D			@
  1119 					.ifdef IFTMP_28
  1120 					sty IFTMP_28
  1121 					eif
  1122 858D 98				tya
  1123 858E D0 03			bne *+5
  1124 8590 4C 98 85			jmp l_0316
  1125
  1126 				; optimize OK (B_CRT), line = 593
  1127
  1128 8593 A9 01 8D 29 A3		mva #$01 RESULT
  1129
  1130 				; IfThenEpilog
  1131 8598			l_0316
  1132
  1133 8598			@exit
  1134
  1135 				; -----------------------------------------------------------
  1136
  1137 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1138 				; as Pointer
  1139
  1140 8598 E8				inx						; add bx, 1
  1141 8599 AD 29 A3 95 80		mva RESULT :STACKORIGIN,x
  1142
  1143 					.ifdef @new
  1144 					@FreeMem #@VarData #@VarDataSize
  1145 					eif
  1146
  1147 				; -----------------------------------------------------------
  1148
  1149 = A329			RESULT	= DATAORIGIN+$0329
  1150
  1151 = A329			@VarData	= RESULT
  1152 = 0001			@VarDataSize	= 1
  1153
  1154 859E 60				rts						; ret
  1155 				.endl
  1156
  1157 859F			.local	CRT_STARTPRESSED				; FUNCTION
  1158
  1159 					ift l_0330-*>3
  1160 					jmp l_0330
  1161 					eif
  1162
  1163 				; IfThenEpilog
  1164 859F			l_0330
  1165
  1166 				; optimize OK (B_CRT), line = 749
  1167
  1168 859F AD 1F D0			lda ATARI.CONSOL
  1169 85A2 A0 01			ldy #1
  1170 85A4 29 01			and #$01
  1171 85A6 F0 01			beq @+
  1172 85A8 88				dey
  1173 85A9			@
  1174 85A9 8C 2A A3			sty RESULT
  1175
  1176 85AC			@exit
  1177
  1178 				; -----------------------------------------------------------
  1179
  1180 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1181 				; as Pointer
  1182
  1183 85AC E8				inx						; add bx, 1
  1184 85AD AD 2A A3 95 80		mva RESULT :STACKORIGIN,x
  1185
  1186 					.ifdef @new
  1187 					@FreeMem #@VarData #@VarDataSize
  1188 					eif
  1189
  1190 				; -----------------------------------------------------------
  1191
  1192 = A32A			RESULT	= DATAORIGIN+$032A
  1193
  1194 = A32A			@VarData	= RESULT
  1195 = 0001			@VarDataSize	= 1
  1196
  1197 85B2 60				rts						; ret
  1198 				.endl
  1199
  1200 				; -----------------------------------------------------------
  1201
  1202 = 0028			DEFAULT_SCREENWIDTH	= $0028
  1203 = 0018			DEFAULT_SCREENHEIGHT	= $0018
  1204 = 009B			CHAR_RETURN	= $009B
  1205 = 001B			CHAR_ESCAPE	= $001B
  1206 = 007E			CHAR_BACKSPACE	= $007E
  1207 = 007F			CHAR_TAB	= $007F
  1208 = 0081			CHAR_INVERSE	= $0081
  1209 = 0082			CHAR_CAPS	= $0082
  1210 = 00DB			ICHAR_RETURN	= $00DB
  1211 = 005B			ICHAR_ESCAPE	= $005B
  1212 = 007E			ICHAR_BACKSPACE	= $007E
  1213 = 007F			ICHAR_TAB	= $007F
  1214 = 00C1			ICHAR_INVERSE	= $00C1
  1215 = 00C2			ICHAR_CAPS	= $00C2
  1216 = 8147			adr.CRT_KEYCODE	= CODEORIGIN+$0147
  1217 85B3			.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
  1218 = A012			CRT_VRAM	= DATAORIGIN+$0012
  1219 = A014			CRT_SIZE	= DATAORIGIN+$0014
  1220 = A016			CRT_SCREENWIDTH	= DATAORIGIN+$0016
  1221 = A017			CRT_SCREENHEIGHT	= DATAORIGIN+$0017
  1222 = A018			CRT_CURSOR	= DATAORIGIN+$0018
  1223 = A01A			CRT_LEFTMARGIN	= DATAORIGIN+$001A
  1224 = D209			KBCODE	= $D209
  1225 = D01F			CONSOL	= $D01F
  1226
  1227 = 85B3 47 81		CRT_KEYCODE
  1227 				.endl							; UNIT B_CRT
  1228
  1229 85B5			.local	SHOWTITLESCREEN					; PROCEDURE
  1230
  1231 					ift l_034A-*>3
  1232 					jmp l_034A
  1233 					eif
  1234
  1235 				; IfThenEpilog
  1236 85B5			l_034A
  1237
  1238 				; optimize OK (Mind Field.pas), line = 121
  1239
  1240 85B5 A9 00			lda #$00
  1241 85B7 8D 51 A3			sta TOPMEM
  1242 85BA AD 53 A3			lda CHBASE1
  1243 85BD 8D 52 A3			sta TOPMEM+1
  1244
  1245 				; ---------------------  ASM Block 066  ---------------------
  1246
  1247
  1248 				;	  ICL "Atari 8-bit Equates.asm"
  1249 						
  1250 85C0 A9 00		    lda #0
  1251 85C2 85 52		    sta 82
  1252 85C4 8D C6 02		    sta 710
  1253 85C7 A9 0C		    lda #12
  1254 85C9 8D C5 02		    sta 709
  1255 				    ; lda chbase1
  1256 				    ; sta 756
  1257 85CC A9 00		    LDA #0
  1258 85CE 8D 0E D4		    STA NMIEN
  1259 85D1 8D 00 D4		    STA DMACTL
  1260 85D4 8D 1B D0		    STA PRIOR
  1261 85D7 8D 1E D0		    STA HITCLR
  1262
  1263 				;    LDX #>RamSizeCode+1
  1264 85DA A0 00		    LDY #$00
  1265 85DC 84 EA		    STY NDX0
  1266 85DE 84 EC		    STY NDX2
  1267 85E0 A9 38		    LDA #$38
  1268 85E2 85 EB		    STA NDX1
  1269 85E4 A9 A8		    LDA #$A8
  1270 85E6 85 ED		    STA NDX3
  1271 				    
  1272
  1273 				; optimize FAIL ('B_CRT.CRT_INIT_0223', Mind Field.pas), line = 148
  1274 85E8 E8				inx
  1275 85E9 A9 00 95 80			mva #$00 :STACKORIGIN,x
  1276 85ED A9 10 95 90			mva #$10 :STACKORIGIN+STACKWIDTH,x
  1277 85F1 E8				inx
  1278 85F2 A9 28 95 80			mva #$28 :STACKORIGIN,x
  1279 85F6 E8				inx
  1280 85F7 A9 19 95 80			mva #$19 :STACKORIGIN,x
  1281 85FB 20 01 84			jsr B_CRT.CRT_INIT_0223
  1282
  1283 				; optimize FAIL ('B_CRT.CRT_CLEAR_0271', Mind Field.pas), line = 149
  1284 85FE 20 59 84			jsr B_CRT.CRT_CLEAR_0271
  1285
  1286 				; optimize OK (Mind Field.pas), line = 150
  1287
  1288 8601 A9 47 8D 02 D4		mva #$47 ATARI.DLISTW
  1289 8606 A9 82 8D 03 D4		mva #$82 ATARI.DLISTW+1
  1290
  1291 				; optimize OK (Mind Field.pas), line = 151
  1292
  1293 860B A9 47 8D 30 02		mva #$47 ATARI.SDLSTW
  1294 8610 A9 82 8D 31 02		mva #$82 ATARI.SDLSTW+1
  1295
  1296 				; optimize OK (Mind Field.pas), line = 152
  1297
  1298 8615 A9 00 85 58			mva #$00 ATARI.SAVMSC
  1299 8619 A9 10 85 59			mva #$10 ATARI.SAVMSC+1
  1300
  1301 				; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 153
  1302 861D E8				inx
  1303 861E A9 A4 95 80			mva #$A4 :STACKORIGIN,x
  1304 8622 20 19 83			jsr B_SYSTEM.SETCHARSET
  1305
  1306 				; optimize OK (Mind Field.pas), line = 154
  1307
  1308 8625 A9 A4 8D F4 02		mva #$A4 ATARI.CHBAS
  1309
  1310 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 155
  1311 862A E8				inx
  1312 862B A9 00 95 80			mva #$00 :STACKORIGIN,x
  1313 862F E8				inx
  1314 8630 95 80			sta :STACKORIGIN,x
  1315 8632 20 81 84			jsr B_CRT.CRT_GOTOXY
  1316
  1317 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 157
  1318 8635 E8				inx
  1319 8636 A9 02 95 80			mva #$02 :STACKORIGIN,x
  1320 863A A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1321 863E 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1322
  1323 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 158
  1324 8641 E8				inx
  1325 8642 A9 00 95 80			mva #$00 :STACKORIGIN,x
  1326 8646 E8				inx
  1327 8647 A9 06 95 80			mva #$06 :STACKORIGIN,x
  1328 864B 20 81 84			jsr B_CRT.CRT_GOTOXY
  1329
  1330 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 159
  1331 864E E8				inx
  1332 864F A9 2B 95 80			mva #$2B :STACKORIGIN,x
  1333 8653 A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1334 8657 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1335
  1336 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 160
  1337 865A E8				inx
  1338 865B A9 55 95 80			mva #$55 :STACKORIGIN,x
  1339 865F A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1340 8663 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1341
  1342 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 161
  1343 8666 E8				inx
  1344 8667 A9 7F 95 80			mva #$7F :STACKORIGIN,x
  1345 866B A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1346 866F 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1347
  1348 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 162
  1349 8672 E8				inx
  1350 8673 A9 A9 95 80			mva #$A9 :STACKORIGIN,x
  1351 8677 A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1352 867B 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1353
  1354 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 163
  1355 867E E8				inx
  1356 867F A9 D3 95 80			mva #$D3 :STACKORIGIN,x
  1357 8683 A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1358 8687 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1359
  1360 				; optimize OK (Mind Field.pas), line = 164
  1361
  1362 868A A9 00 85 E5			mva #$00 TMP5
  1363
  1364 				; optimize OK (Mind Field.pas), line = 166
  1365
  1366 868E A9 06 8D 35 A3		mva #$06 K
  1367
  1368 				; optimize OK (Mind Field.pas), line = 167
  1369
  1370 8693 A9 05 8D 33 A3		mva #$05 I
  1371
  1372 				; optimize OK (Mind Field.pas), line = 168
  1373
  1374 8698 A9 3E 8D 00 D4		mva #$3E ATARI.DMACTL
  1375
  1376 				; optimize OK (Mind Field.pas), line = 169
  1377
  1378 869D A9 40 8D 0E D4		mva #$40 ATARI.NMIEN
  1379
  1380 				; optimize OK (Mind Field.pas), line = 172
  1381
  1382 86A2 A9 8E 8D C4 02		mva #$8E ATARI.COLOR0
  1383
  1384 				; optimize OK (Mind Field.pas), line = 173
  1385
  1386 86A7 A9 0A 8D C5 02		mva #$0A ATARI.COLOR1
  1387
  1388 				; optimize OK (Mind Field.pas), line = 174
  1389
  1390 86AC A9 BA 8D C6 02		mva #$BA ATARI.COLOR2
  1391
  1392 				; optimize OK (Mind Field.pas), line = 175
  1393
  1394 86B1 A9 36 8D C7 02		mva #$36 ATARI.COLOR3
  1395
  1396 				; optimize OK (Mind Field.pas), line = 176
  1397
  1398 86B6 A9 22 8D C8 02		mva #$22 ATARI.COLOR4
  1399
  1400 				; --- RepeatUntilProlog
  1401 86BB			l_03D3
  1402
  1403 				; optimize OK (Mind Field.pas), line = 178
  1404
  1405 86BB AD 33 A3			lda I
  1406 86BE 0A				asl @
  1407 86BF A8				tay
  1408 86C0 B9 3B A3			lda adr.HISCORE,y
  1409 86C3 85 8A			sta :STACKORIGIN+10
  1410 86C5 B9 3C A3			lda adr.HISCORE+1,y
  1411 86C8 85 9A			sta :STACKORIGIN+STACKWIDTH+10
  1412 86CA A0 01			ldy #1
  1413 86CC AD 39 A3			lda SCORE+1
  1414 86CF C5 9A			cmp :STACKORIGIN+STACKWIDTH+10
  1415 86D1 D0 05			bne @+
  1416 86D3 AD 38 A3			lda SCORE
  1417 86D6 C5 8A			cmp :STACKORIGIN+10
  1418 86D8			@
  1419 86D8 F0 02			seq
  1420 86DA B0 01			bcs @+
  1421 86DC 88				dey
  1422 86DD			@
  1423 					.ifdef IFTMP_32
  1424 					sty IFTMP_32
  1425 					eif
  1426 86DD 98				tya
  1427 86DE D0 03			bne *+5
  1428 86E0 4C E9 86			jmp l_03E8
  1429
  1430 				; optimize OK (Mind Field.pas), line = 180
  1431
  1432 86E3 AD 33 A3 8D 35 A3		mva I K
  1433
  1434 				; IfThenEpilog
  1435 86E9			l_03E8
  1436
  1437 				; optimize OK (Mind Field.pas), line = 182
  1438
  1439 86E9 CE 33 A3			dec I
  1440
  1441 				; optimize OK (Mind Field.pas), line = 183
  1442
  1443 86EC A0 01			ldy #1
  1444 86EE AD 33 A3			lda I
  1445 86F1 F0 01			beq @+
  1446 86F3 88				dey
  1447 86F4			@
  1448 86F4 98				tya
  1449 86F5 D0 03			bne *+5
  1450 86F7			c_03D3
  1451 86F7 4C BB 86			jmp l_03D3
  1452 86FA			b_03D3
  1453
  1454 				; optimize OK (Mind Field.pas), line = 184
  1455
  1456 86FA A0 01			ldy #1
  1457 86FC AD 35 A3			lda K
  1458 86FF C9 05			cmp #$05
  1459 8701 90 01			bcc @+
  1460 8703 88				dey
  1461 8704			@
  1462 					.ifdef IFTMP_33
  1463 					sty IFTMP_33
  1464 					eif
  1465 8704 98				tya
  1466 8705 D0 03			bne *+5
  1467 8707 4C 58 87			jmp l_0420
  1468
  1469 				; optimize OK (Mind Field.pas), line = 186
  1470
  1471 870A A9 05 8D 33 A3		mva #$05 I
  1472
  1473 				; --- RepeatUntilProlog
  1474 870F			l_0429
  1475
  1476 				; optimize OK (Mind Field.pas), line = 188
  1477
  1478 870F AD 33 A3			lda I
  1479 8712 0A				asl @
  1480 8713 85 89			sta :STACKORIGIN+9
  1481 8715 AD 33 A3			lda I
  1482 8718 38 E9 01			sub #$01
  1483 871B 0A				asl @
  1484 871C A8				tay
  1485 871D B9 3B A3			lda adr.HISCORE,y
  1486 8720 85 8A			sta :STACKORIGIN+10
  1487 8722 B9 3C A3			lda adr.HISCORE+1,y
  1488 8725 85 9A			sta :STACKORIGIN+STACKWIDTH+10
  1489 8727 A4 89			ldy :STACKORIGIN+9
  1490 8729 A5 8A			lda :STACKORIGIN+10
  1491 872B 99 3B A3			sta adr.HISCORE,y
  1492 872E A5 9A			lda :STACKORIGIN+STACKWIDTH+10
  1493 8730 99 3C A3			sta adr.HISCORE+1,y
  1494
  1495 				; optimize OK (Mind Field.pas), line = 189
  1496
  1497 8733 CE 33 A3			dec I
  1498
  1499 				; optimize OK (Mind Field.pas), line = 190
  1500
  1501 8736 A0 01			ldy #1
  1502 8738 AD 33 A3			lda I
  1503 873B CD 35 A3			cmp K
  1504 873E F0 01			beq @+
  1505 8740 88				dey
  1506 8741			@
  1507 8741 98				tya
  1508 8742 D0 03			bne *+5
  1509 8744			c_0429
  1510 8744 4C 0F 87			jmp l_0429
  1511 8747			b_0429
  1512
  1513 				; optimize OK (Mind Field.pas), line = 191
  1514
  1515 8747 AD 35 A3			lda K
  1516 874A 0A				asl @
  1517 874B A8				tay
  1518 874C AD 38 A3			lda SCORE
  1519 874F 99 3B A3			sta adr.HISCORE,y
  1520 8752 AD 39 A3			lda SCORE+1
  1521 8755 99 3C A3			sta adr.HISCORE+1,y
  1522
  1523 				; IfThenEpilog
  1524 8758			l_0420
  1525
  1526 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 193
  1527 8758 E8				inx
  1528 8759 A9 0A 95 80			mva #$0A :STACKORIGIN,x
  1529 875D E8				inx
  1530 875E A9 0D 95 80			mva #$0D :STACKORIGIN,x
  1531 8762 20 81 84			jsr B_CRT.CRT_GOTOXY
  1532
  1533 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 194
  1534 8765 E8				inx
  1535 8766 A9 FD 95 80			mva #$FD :STACKORIGIN,x
  1536 876A A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1537 876E 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1538
  1539 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 195
  1540 8771 E8				inx
  1541 8772 A9 12 95 80			mva #$12 :STACKORIGIN,x
  1542 8776 E8				inx
  1543 8777 A9 0D 95 80			mva #$0D :STACKORIGIN,x
  1544 877B 20 81 84			jsr B_CRT.CRT_GOTOXY
  1545
  1546 				; optimize FAIL ('B_CRT.CRT_WRITE_02E7', Mind Field.pas), line = 196
  1547 877E E8				inx
  1548 877F AD 38 A3 95 80		mva SCORE :STACKORIGIN,x
  1549 8784 AD 39 A3 95 90		mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
  1550 8789 20 5B 85			jsr B_CRT.CRT_WRITE_02E7
  1551
  1552 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 197
  1553 878C E8				inx
  1554 878D A9 08 95 80			mva #$08 :STACKORIGIN,x
  1555 8791 E8				inx
  1556 8792 A9 0F 95 80			mva #$0F :STACKORIGIN,x
  1557 8796 20 81 84			jsr B_CRT.CRT_GOTOXY
  1558
  1559 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 198
  1560 8799 E8				inx
  1561 879A A9 07 95 80			mva #$07 :STACKORIGIN,x
  1562 879E A9 81 95 90			mva #$81 :STACKORIGIN+STACKWIDTH,x
  1563 87A2 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1564 				; For
  1565
  1566 				; optimize OK (Mind Field.pas), line = 199
  1567
  1568 87A5 A9 01 8D 33 A3		mva #$01 I
  1569
  1570 				; optimize OK (Mind Field.pas), line = 199
  1571
  1572 				; To
  1573 87AA			l_047D
  1574
  1575 				; ForToDoCondition
  1576
  1577 				; optimize OK (Mind Field.pas), line = 199
  1578
  1579 87AA AD 33 A3			lda I
  1580 87AD C9 05			cmp #$05
  1581 87AF 90 05			bcc *+7
  1582 87B1 F0 03			beq *+5
  1583
  1584 				; ForToDoProlog
  1585 87B3 4C 4E 88			jmp l_048B
  1586
  1587 				; optimize OK (Mind Field.pas), line = 201
  1588
  1589 87B6 A0 01			ldy #1
  1590 87B8 AD 35 A3			lda K
  1591 87BB CD 33 A3			cmp I
  1592 87BE F0 01			beq @+
  1593 87C0 88				dey
  1594 87C1			@
  1595 					.ifdef IFTMP_34
  1596 					sty IFTMP_34
  1597 					eif
  1598 87C1 98				tya
  1599 87C2 D0 03			bne *+5
  1600 87C4 4C E6 87			jmp l_049F
  1601
  1602 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 203
  1603 87C7 E8				inx
  1604 87C8 A9 0C 95 80			mva #$0C :STACKORIGIN,x
  1605 87CC E8				inx
  1606 87CD A9 10 95 80			mva #$10 :STACKORIGIN,x
  1607 87D1 E8				inx
  1608 87D2 AD 33 A3 95 80		mva I :STACKORIGIN,x
  1609 87D7 20 12 8A			jsr addAL_CL
  1610 87DA CA				dex
  1611 87DB 20 81 84			jsr B_CRT.CRT_GOTOXY
  1612
  1613 				; optimize FAIL ('B_CRT.CRT_WRITE_02C3', Mind Field.pas), line = 204
  1614 87DE E8				inx
  1615 87DF A9 0A 95 80			mva #$0A :STACKORIGIN,x
  1616 87E3 20 26 85			jsr B_CRT.CRT_WRITE_02C3
  1617
  1618 				; IfThenEpilog
  1619 87E6			l_049F
  1620
  1621 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 206
  1622 87E6 E8				inx
  1623 87E7 A9 0E 95 80			mva #$0E :STACKORIGIN,x
  1624 87EB E8				inx
  1625 87EC A9 10 95 80			mva #$10 :STACKORIGIN,x
  1626 87F0 E8				inx
  1627 87F1 AD 33 A3 95 80		mva I :STACKORIGIN,x
  1628 87F6 20 12 8A			jsr addAL_CL
  1629 87F9 CA				dex
  1630 87FA 20 81 84			jsr B_CRT.CRT_GOTOXY
  1631
  1632 				; optimize FAIL ('B_CRT.CRT_WRITE_02D7', Mind Field.pas), line = 207
  1633 87FD E8				inx
  1634 87FE AD 33 A3 95 80		mva I :STACKORIGIN,x
  1635 8803 20 42 85			jsr B_CRT.CRT_WRITE_02D7
  1636
  1637 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 208
  1638 8806 E8				inx
  1639 8807 A9 1C 95 80			mva #$1C :STACKORIGIN,x
  1640 880B A9 81 95 90			mva #$81 :STACKORIGIN+STACKWIDTH,x
  1641 880F 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1642
  1643 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 209
  1644 8812 E8				inx
  1645 8813 A9 12 95 80			mva #$12 :STACKORIGIN,x
  1646 8817 E8				inx
  1647 8818 A9 10 95 80			mva #$10 :STACKORIGIN,x
  1648 881C E8				inx
  1649 881D AD 33 A3 95 80		mva I :STACKORIGIN,x
  1650 8822 20 12 8A			jsr addAL_CL
  1651 8825 CA				dex
  1652 8826 20 81 84			jsr B_CRT.CRT_GOTOXY
  1653
  1654 				; optimize FAIL ('B_CRT.CRT_WRITE_02E7', Mind Field.pas), line = 210
  1655 8829 E8				inx
  1656 882A AD 33 A3 95 80		mva I :STACKORIGIN,x
  1657 882F A9 00 95 90			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1658 8833				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 8833 16 80			asl :STACKORIGIN-0,x
     2 8835 36 90			rol :STACKORIGIN-0+STACKWIDTH,x
Source: Mind Field.a65
  1659 8837 B4 80			ldy :STACKORIGIN,x
  1660 8839 B9 3B A3 95 80		mva adr.HISCORE,y :STACKORIGIN,x
  1661 883E B9 3C A3 95 90		mva adr.HISCORE+1,y :STACKORIGIN+STACKWIDTH,x
  1662 8843 20 5B 85			jsr B_CRT.CRT_WRITE_02E7
  1663
  1664 				; ForToDoEpilog
  1665 8846			c_047D
  1666 8846 EE 33 A3			inc I						; inc ptr byte [CounterAddress]
  1667
  1668 8849 F0 03			seq
  1669
  1670 				; WhileDoEpilog
  1671 884B 4C AA 87			jmp l_047D
  1672 884E			l_048B
  1673 884E			b_047D
  1674
  1675 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 212
  1676 884E E8				inx
  1677 884F A9 07 95 80			mva #$07 :STACKORIGIN,x
  1678 8853 E8				inx
  1679 8854 A9 17 95 80			mva #$17 :STACKORIGIN,x
  1680 8858 20 81 84			jsr B_CRT.CRT_GOTOXY
  1681
  1682 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 213
  1683 885B E8				inx
  1684 885C A9 20 95 80			mva #$20 :STACKORIGIN,x
  1685 8860 A9 81 95 90			mva #$81 :STACKORIGIN+STACKWIDTH,x
  1686 8864 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1687
  1688 				; optimize OK (Mind Field.pas), line = 214
  1689
  1690 8867 A9 00			lda #$00
  1691 8869 85 CF			sta :bp+1
  1692 886B AC 00 D0			ldy ATARI.HPOSP0
  1693 886E A9 7C			lda #$7C
  1694 8870 91 CE			sta (:bp),y
  1695
  1696 				; --- RepeatUntilProlog
  1697 8872			l_04DB
  1698
  1699 				; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 226
  1700 8872 20 9F 85			jsr B_CRT.CRT_STARTPRESSED
  1701 					.ifdef IFTMP_35
  1702 					lda :STACKORIGIN,x
  1703 					sta IFTMP_35
  1704 					eif
  1705 8875 CA				dex
  1706 8876 B5 81			lda :STACKORIGIN+1,x
  1707 8878 D0 03			bne *+5
  1708 887A 4C 81 88			jmp l_04E5
  1709
  1710 				; optimize OK (Mind Field.pas), line = 226
  1711
  1712 887D A9 FF 85 E5			mva #$FF TMP5
  1713
  1714 				; IfThenEpilog
  1715 8881			l_04E5
  1716
  1717 				; optimize OK (Mind Field.pas), line = 230
  1718
  1719 8881 A0 01			ldy #1
  1720 8883 A5 E5			lda TMP5
  1721 8885 C9 FF			cmp #$FF
  1722 8887 F0 01			beq @+
  1723 8889 88				dey
  1724 888A			@
  1725 888A 98				tya
  1726 888B D0 03			bne *+5
  1727 888D			c_04DB
  1728 888D 4C 72 88			jmp l_04DB
  1729 8890			b_04DB
  1730 8890			l_04FD
  1731
  1732 				; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 233
  1733 8890 20 9F 85			jsr B_CRT.CRT_STARTPRESSED
  1734 8893 E8				inx
  1735 8894 A9 00 95 80			mva #$00 :STACKORIGIN,x
  1736 8898 A0 01			ldy #1
  1737 889A B5 7F			lda :STACKORIGIN-1,x
  1738 889C D5 80			cmp :STACKORIGIN,x
  1739 889E F0 01			beq @+
  1740 88A0 88				dey
  1741 88A1			@
  1742 88A1 94 7F			sty :STACKORIGIN-1,x
  1743 88A3 CA				dex
  1744 88A4 CA				dex
  1745 88A5 B5 81			lda :STACKORIGIN+1,x
  1746 88A7 D0 03			bne *+5
  1747 88A9			c_04FD
  1748 88A9 4C 90 88			jmp l_04FD
  1749 88AC			b_04FD
  1750
  1751 				; ---------------------  ASM Block 067  ---------------------
  1752
  1753
  1754 88AC			Title_VBI
  1755 				      
  1756 				//    ORG 32768
  1757 				//    ICL "inflate_2017_ver4.asm"
  1758 				//    ORG 46080
  1759 				//    INS "roman10.fnt" 
  1760
  1761
  1762 				; -----------------------------------------------------------
  1763
  1764 = 0005			@FORTMP_1143	= $0005
  1765
  1766 88AC			@exit
  1767 					.ifdef @new
  1768 					@FreeMem #@VarData #@VarDataSize
  1769 					eif
  1770 88AC 60				rts						; ret
  1771 				.endl
  1772
  1773 88AD			.local	INITIALIZE_LEVEL				; PROCEDURE
  1774
  1775 					ift l_050C-*>3
  1776 					jmp l_050C
  1777 					eif
  1778
  1779 				; IfThenEpilog
  1780 88AD			l_050C
  1781 				; For
  1782
  1783 				; optimize OK (Mind Field.pas), line = 249
  1784
  1785 88AD A9 00 8D 33 A3		mva #$00 I
  1786
  1787 				; optimize OK (Mind Field.pas), line = 249
  1788
  1789 				; To
  1790 88B2			l_051B
  1791
  1792 				; ForToDoCondition
  1793
  1794 				; optimize OK (Mind Field.pas), line = 249
  1795
  1796 88B2 AD 33 A3			lda I
  1797 88B5 C9 FF			cmp #$FF
  1798 88B7 90 05			bcc *+7
  1799 88B9 F0 03			beq *+5
  1800
  1801 				; ForToDoProlog
  1802 88BB 4C E2 88			jmp l_0529
  1803
  1804 				; ---------------------  ASM Block 068  ---------------------
  1805
  1806
  1807 88BE AD 0A D2			LDA RANDOM
  1808 88C1 18				CLC
  1809 88C2 69 28			ADC #<game_screen
  1810 88C4 85 EA			STA NDX0
  1811 88C6 AD 0A D2			LDA RANDOM
  1812 88C9 29 03			AND #3
  1813 88CB 69 10			ADC #>game_screen
  1814 88CD 85 EB			STA NDX1
  1815 88CF AD 0A D2			LDA RANDOM
  1816 88D2 29 03			AND #3
  1817 88D4 09 44			ORA #68
  1818 88D6 A0 00			LDY #0
  1819 88D8 91 EA			STA (NDX0),Y
  1820
  1821
  1822 				; ForToDoEpilog
  1823 88DA			c_051B
  1824 88DA EE 33 A3			inc I						; inc ptr byte [CounterAddress]
  1825
  1826 88DD F0 03			seq
  1827
  1828 				; WhileDoEpilog
  1829 88DF 4C B2 88			jmp l_051B
  1830 88E2			l_0529
  1831 88E2			b_051B
  1832 				; For
  1833
  1834 				; optimize OK (Mind Field.pas), line = 269
  1835
  1836 88E2 A9 00 8D 33 A3		mva #$00 I
  1837
  1838 				; optimize OK (Mind Field.pas), line = 269
  1839
  1840 				; To
  1841 88E7			l_053D
  1842
  1843 				; ForToDoCondition
  1844
  1845 				; optimize OK (Mind Field.pas), line = 269
  1846
  1847 88E7 AD 33 A3			lda I
  1848 88EA C9 3F			cmp #$3F
  1849 88EC 90 05			bcc *+7
  1850 88EE F0 03			beq *+5
  1851
  1852 				; ForToDoProlog
  1853 88F0 4C 12 89			jmp l_054B
  1854
  1855 				; ---------------------  ASM Block 069  ---------------------
  1856
  1857
  1858 88F3 AD 0A D2			LDA RANDOM
  1859 88F6 18				CLC
  1860 88F7 69 28			ADC #<game_screen
  1861 88F9 85 EA			STA NDX0
  1862 88FB AD 0A D2			LDA RANDOM
  1863 88FE 29 03			AND #3
  1864 8900 69 10			ADC #>game_screen
  1865 8902 85 EB			STA NDX1
  1866 8904 A9 C1			LDA #193
  1867 8906 A0 00			LDY #0
  1868 8908 91 EA			STA (NDX0),Y
  1869
  1870
  1871 				; ForToDoEpilog
  1872 890A			c_053D
  1873 890A EE 33 A3			inc I						; inc ptr byte [CounterAddress]
  1874
  1875 890D F0 03			seq
  1876
  1877 				; WhileDoEpilog
  1878 890F 4C E7 88			jmp l_053D
  1879 8912			l_054B
  1880 8912			b_053D
  1881
  1882 				; -----------------------------------------------------------
  1883
  1884 = 00FF			@FORTMP_1301	= $00FF
  1885 = 003F			@FORTMP_1335	= $003F
  1886
  1887 8912			@exit
  1888 					.ifdef @new
  1889 					@FreeMem #@VarData #@VarDataSize
  1890 					eif
  1891 8912 60				rts						; ret
  1892 				.endl
  1893
  1894 8913			.local	DISPLAY_INFORMATION_LINE			; PROCEDURE
  1895
  1896 					ift l_0554-*>3
  1897 					jmp l_0554
  1898 					eif
  1899
  1900 				; IfThenEpilog
  1901 8913			l_0554
  1902
  1903 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 289
  1904 8913 E8				inx
  1905 8914 A9 00 95 80			mva #$00 :STACKORIGIN,x
  1906 8918 E8				inx
  1907 8919 95 80			sta :STACKORIGIN,x
  1908 891B 20 81 84			jsr B_CRT.CRT_GOTOXY
  1909
  1910 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 290
  1911 891E E8				inx
  1912 891F A9 37 95 80			mva #$37 :STACKORIGIN,x
  1913 8923 A9 81 95 90			mva #$81 :STACKORIGIN+STACKWIDTH,x
  1914 8927 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1915
  1916 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 291
  1917 892A E8				inx
  1918 892B A9 06 95 80			mva #$06 :STACKORIGIN,x
  1919 892F E8				inx
  1920 8930 A9 00 95 80			mva #$00 :STACKORIGIN,x
  1921 8934 20 81 84			jsr B_CRT.CRT_GOTOXY
  1922
  1923 				; optimize FAIL ('B_CRT.CRT_WRITE_02E7', Mind Field.pas), line = 292
  1924 8937 E8				inx
  1925 8938 AD 38 A3 95 80		mva SCORE :STACKORIGIN,x
  1926 893D AD 39 A3 95 90		mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
  1927 8942 20 5B 85			jsr B_CRT.CRT_WRITE_02E7
  1928
  1929 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 294
  1930 8945 E8				inx
  1931 8946 A9 0E 95 80			mva #$0E :STACKORIGIN,x
  1932 894A E8				inx
  1933 894B A9 00 95 80			mva #$00 :STACKORIGIN,x
  1934 894F 20 81 84			jsr B_CRT.CRT_GOTOXY
  1935
  1936 				; optimize FAIL ('B_CRT.CRT_WRITE_02AD', Mind Field.pas), line = 295
  1937 8952 E8				inx
  1938 8953 A9 3F 95 80			mva #$3F :STACKORIGIN,x
  1939 8957 A9 81 95 90			mva #$81 :STACKORIGIN+STACKWIDTH,x
  1940 895B 20 BA 84			jsr B_CRT.CRT_WRITE_02AD
  1941
  1942 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 296
  1943 895E E8				inx
  1944 895F A9 14 95 80			mva #$14 :STACKORIGIN,x
  1945 8963 E8				inx
  1946 8964 A9 00 95 80			mva #$00 :STACKORIGIN,x
  1947 8968 20 81 84			jsr B_CRT.CRT_GOTOXY
  1948
  1949 				; optimize FAIL ('B_CRT.CRT_WRITE_02D7', Mind Field.pas), line = 297
  1950 896B E8				inx
  1951 896C AD 3A A3 95 80		mva LIVES :STACKORIGIN,x
  1952 8971 20 42 85			jsr B_CRT.CRT_WRITE_02D7
  1953
  1954 8974			@exit
  1955 					.ifdef @new
  1956 					@FreeMem #@VarData #@VarDataSize
  1957 					eif
  1958 8974 60				rts						; ret
  1959 				.endl
  1960
  1961 				; IfThenEpilog
  1962 8975			l_014E
  1963
  1964 				; --- RepeatUntilProlog
  1965 8975			l_056D
  1966
  1967 				; optimize FAIL ('SHOWTITLESCREEN', Mind Field.pas), line = 310
  1968 8975 20 B5 85			jsr SHOWTITLESCREEN
  1969
  1970 				; optimize OK (Mind Field.pas), line = 313
  1971
  1972 8978 A9 00 8D 38 A3		mva #$00 SCORE
  1973 897D 8D 39 A3			sta SCORE+1
  1974
  1975 				; optimize OK (Mind Field.pas), line = 314
  1976
  1977 8980 A9 05 8D 3A A3		mva #$05 LIVES
  1978
  1979 				; optimize FAIL ('B_CRT.CRT_INIT_0223', Mind Field.pas), line = 315
  1980 8985 E8				inx
  1981 8986 A9 00 95 80			mva #$00 :STACKORIGIN,x
  1982 898A A9 10 95 90			mva #$10 :STACKORIGIN+STACKWIDTH,x
  1983 898E E8				inx
  1984 898F A9 28 95 80			mva #$28 :STACKORIGIN,x
  1985 8993 E8				inx
  1986 8994 A9 1A 95 80			mva #$1A :STACKORIGIN,x
  1987 8998 20 01 84			jsr B_CRT.CRT_INIT_0223
  1988
  1989 				; optimize FAIL ('B_CRT.CRT_CLEAR_0271', Mind Field.pas), line = 316
  1990 899B 20 59 84			jsr B_CRT.CRT_CLEAR_0271
  1991
  1992 				; optimize FAIL ('DISPLAY_INFORMATION_LINE', Mind Field.pas), line = 317
  1993 899E 20 13 89			jsr DISPLAY_INFORMATION_LINE
  1994
  1995 				; optimize OK (Mind Field.pas), line = 318
  1996
  1997 89A1 A9 7A 8D 02 D4		mva #$7A ATARI.DLISTW
  1998 89A6 A9 82 8D 03 D4		mva #$82 ATARI.DLISTW+1
  1999
  2000 				; optimize OK (Mind Field.pas), line = 319
  2001
  2002 89AB A9 7A 8D 30 02		mva #$7A ATARI.SDLSTW
  2003 89B0 A9 82 8D 31 02		mva #$82 ATARI.SDLSTW+1
  2004
  2005 				; optimize OK (Mind Field.pas), line = 320
  2006
  2007 89B5 A9 00 85 58			mva #$00 ATARI.SAVMSC
  2008 89B9 A9 10 85 59			mva #$10 ATARI.SAVMSC+1
  2009
  2010 				; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 321
  2011 89BD E8				inx
  2012 89BE A9 A4 95 80			mva #$A4 :STACKORIGIN,x
  2013 89C2 20 19 83			jsr B_SYSTEM.SETCHARSET
  2014
  2015 				; optimize OK (Mind Field.pas), line = 322
  2016
  2017 89C5 A9 A4 8D F4 02		mva #$A4 ATARI.CHBAS
  2018
  2019 				; optimize FAIL ('INITIALIZE_LEVEL', Mind Field.pas), line = 323
  2020 89CA 20 AD 88			jsr INITIALIZE_LEVEL
  2021
  2022 				; optimize OK (Mind Field.pas), line = 324
  2023
  2024 89CD A9 8E 8D C4 02		mva #$8E ATARI.COLOR0
  2025
  2026 				; optimize OK (Mind Field.pas), line = 325
  2027
  2028 89D2 A9 D4 8D C5 02		mva #$D4 ATARI.COLOR1
  2029
  2030 				; optimize OK (Mind Field.pas), line = 326
  2031
  2032 89D7 A9 46 8D C6 02		mva #$46 ATARI.COLOR2
  2033
  2034 				; optimize OK (Mind Field.pas), line = 327
  2035
  2036 89DC A9 96 8D C7 02		mva #$96 ATARI.COLOR3
  2037
  2038 				; optimize OK (Mind Field.pas), line = 328
  2039
  2040 89E1 A9 22 8D C8 02		mva #$22 ATARI.COLOR4
  2041
  2042 				; --- RepeatUntilProlog
  2043 89E6			l_05C5
  2044
  2045 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', Mind Field.pas), line = 337
  2046 89E6 20 7E 85			jsr B_CRT.CRT_KEYPRESSED
  2047 89E9 CA				dex
  2048 89EA B5 81			lda :STACKORIGIN+1,x
  2049 89EC D0 03			bne *+5
  2050 89EE			c_05C5
  2051 89EE 4C E6 89			jmp l_05C5
  2052 89F1			b_05C5
  2053
  2054 				; ---------------------  ASM Block 070  ---------------------
  2055
  2056
  2057 = 0400			DISPLIST 	          = $0400
  2058 = 0440			SCRTXT              = $0440
  2059 				;SCREEN              = $8000
  2060 				       
  2061
  2062
  2063 				; optimize OK (Mind Field.pas), line = 346
  2064
  2065 89F1 A9 00			lda #$00
  2066 89F3 D0 03			bne *+5
  2067 89F5			c_056D
  2068 89F5 4C 75 89			jmp l_056D
  2069 89F8			b_056D
  2070
  2071 				; -----------------------------------------------------------
  2072
  2073 = 1000			SCREEN_ADDR	= $1000
  2074 = 1028			GAME_SCREEN	= $1028
  2075 = 1000			PMBANK	= $1000
  2076 = 1800			VARBANK	= $1800
  2077 = A400			CHARSET_ADDRESS	= $A400
  2078 = 00A4			CHARSET_BASE	= $00A4
  2079 = 8247			adr.DISPLAY_LIST_TITLE	= CODEORIGIN+$0247
  2080 89F8			.var DISPLAY_LIST_TITLE	= adr.DISPLAY_LIST_TITLE .word
  2081 = 827A			adr.DISPLAY_LIST_GAME	= CODEORIGIN+$027A
  2082 89F8			.var DISPLAY_LIST_GAME	= adr.DISPLAY_LIST_GAME .word
  2083 = D01B			PRIOR	= $D01B
  2084 = 00E0			TMP0	= $00E0
  2085 = 00E1			TMP1	= $00E1
  2086 = 00E2			TMP2	= $00E2
  2087 = 00E3			TMP3	= $00E3
  2088 = 00E4			TMP4	= $00E4
  2089 = 00E5			TMP5	= $00E5
  2090 = 00E6			TMP6	= $00E6
  2091 = 00E7			TMP7	= $00E7
  2092 = 00E8			TMP8	= $00E8
  2093 = 00E9			TMP9	= $00E9
  2094 = 00EA			NDX0	= $00EA
  2095 = 00EB			NDX1	= $00EB
  2096 = 00EC			NDX2	= $00EC
  2097 = 00ED			NDX3	= $00ED
  2098 = 00EE			HOLDX	= $00EE
  2099 = 00EF			HOLDY	= $00EF
  2100 = 1180			SPRITENUM	= $1180
  2101 = 1190			SETSP0COLOR	= $1190
  2102 = 11A0			SETSP1COLOR	= $11A0
  2103 = 11B0			SETSPWIDTH	= $11B0
  2104 = 11C0			SPRITENHOZ	= $11C0
  2105 = 11E0			SPRITENVRT	= $11E0
  2106 = 11F0			SPHOZNEXT	= $11F0
  2107 = 1000			SCREEN_LINE_ADDR_LOW	= $1000
  2108 = 1020			SCREEN_LINE_ADDR_HIGH	= $1020
  2109 = 1200			SPRHZ0	= $1200
  2110 = 1210			SPRHZ1	= $1210
  2111 = 1220			SPRHZ2	= $1220
  2112 = 1230			SPRHZ3	= $1230
  2113 = 1240			SPZONT	= $1240
  2114 = 1250			SPZONB	= $1250
  2115 = 1260			SPSRC0	= $1260
  2116 = 1278			SPSRC1	= $1278
  2117 = 1290			SPSRC2	= $1290
  2118 = 12A8			SPSRC3	= $12A8
  2119 = 12C0			SPSRC4	= $12C0
  2120 = 12D8			SPRITEUSE	= $12D8
  2121 = 1300			MIBANK	= $1300
  2122 = 1400			PMBNK0	= $1400
  2123 = 1500			PMBNK1	= $1500
  2124 = 1600			PMBNK2	= $1600
  2125 = 1700			PMBNK3	= $1700
  2126 = A32B			A	= DATAORIGIN+$032B
  2127 = A32C			B	= DATAORIGIN+$032C
  2128 = A32D			C	= DATAORIGIN+$032D
  2129 = A32E			D	= DATAORIGIN+$032E
  2130 = A32F			E	= DATAORIGIN+$032F
  2131 = A330			F	= DATAORIGIN+$0330
  2132 = A331			G	= DATAORIGIN+$0331
  2133 = A332			H	= DATAORIGIN+$0332
  2134 = A333			I	= DATAORIGIN+$0333
  2135 = A334			J	= DATAORIGIN+$0334
  2136 = A335			K	= DATAORIGIN+$0335
  2137 = A336			L	= DATAORIGIN+$0336
  2138 = A337			TITLEPHASE	= DATAORIGIN+$0337
  2139 = A338			SCORE	= DATAORIGIN+$0338
  2140 = A33A			LIVES	= DATAORIGIN+$033A
  2141 = A33B			adr.HISCORE	= DATAORIGIN+$033B
  2142 89F8			.var HISCORE	= adr.HISCORE .word
  2143 = A351			TOPMEM	= DATAORIGIN+$0351
  2144 = A353			CHBASE1	= DATAORIGIN+$0353
  2145
  2146 89F8			@exit
  2147
  2148 89F8 A2 00		@halt	ldx #0
  2149 89FA 9A				txs
  2150
  2151 89FB 60				rts
  2152
  2153 89FC 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  2154
  2155 8A0C			.local	@DEFINES
  2156 8A0C			ATARI
  2157 				.endl
  2158
  2159 = 8A0C 47 82		DISPLAY_LIST_TITLE
  2159 = 8A0E 7A 82		DISPLAY_LIST_GAME
  2159 = 8A10 3B A3		HISCORE
  2159 				.endl
  2160
  2161 				; -----------------------------------------------------------
  2162
  2163 8A12				icl 'cpu6502.asm'
Source: cpu6502.asm
   296 					opt l+
   239 					opt l+
   240
   241
   242
   243 				/* ----------------------------------------------------------------------- */
   244
   245
   246
   247 8A12			.proc	hiBYTE
   248 					lda :STACKORIGIN,x
   249 8A12				:4 lsr @
   250 					sta :STACKORIGIN,x
   251 					rts
   252 				.endp
   253
   254 8A12			.proc	hiWORD
   255 					lda :STACKORIGIN+STACKWIDTH,x
   256 					sta :STACKORIGIN,x
   257 					rts
   258 				.endp
   259
   260 8A12			.proc	hiCARD
   261 					lda :STACKORIGIN+STACKWIDTH*3,x
   262 					sta :STACKORIGIN+STACKWIDTH,x
   263
   264 					lda :STACKORIGIN+STACKWIDTH*2,x
   265 					sta :STACKORIGIN,x
   266 					rts
   267 				.endp
   268
   269
   270 8A12			.proc	movaBX_EAX		; mov [BX], EAX
   271 8A12				:MAXSIZE mva eax+# :STACKORIGIN-1+#*STACKWIDTH,x
   272 					rts
   273 				.endp
   274
   275 				/*
   276 				.proc	@pushBYTE
   277 					adc :STACKORIGIN+STACKWIDTH,x
   278 					sta bp+1
   279
   280 					mva (bp),y :STACKORIGIN,x
   281
   282 				;	lda #$00
   283 				;	sta :STACKORIGIN+STACKWIDTH,x
   284 				;	sta :STACKORIGIN+STACKWIDTH*2,x
   285 				;	sta :STACKORIGIN+STACKWIDTH*3,x
   286
   287 					rts
   288 				.endp
   289
   290
   291 				.proc	@pullWORD (.word ya) .reg
   292 					add :STACKORIGIN-1,x
   293 					sta bp2
   294 					tya
   295 					adc :STACKORIGIN-1+STACKWIDTH,x
   296 					sta bp2+1
   297
   298 					ldy #$00
   299
   300 					mva :STACKORIGIN,x (bp2),y
   301 					iny
   302 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   303
   304 					rts
   305 				.endp
   306
   307
   308 				.proc	@pullCARD (.word ya) .reg
   309 					add :STACKORIGIN-1,x
   310 					sta bp2
   311 					tya
   312 					adc :STACKORIGIN-1+STACKWIDTH,x
   313 					sta bp2+1
   314
   315 					ldy #$00
   316
   317 					mva :STACKORIGIN,x (bp2),y
   318 					iny
   319 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   320 					iny
   321 					mva :STACKORIGIN+STACKWIDTH*2,x (bp2),y
   322 					iny
   323 					mva :STACKORIGIN+STACKWIDTH*3,x (bp2),y
   324
   325 					rts
   326 				.endp
   327
   328
   329 				.proc	@pushWORD (.word ya) .reg
   330 					add :STACKORIGIN,x
   331 					sta bp2
   332 					tya
   333 					adc :STACKORIGIN+STACKWIDTH,x
   334 					sta bp2+1
   335
   336 					ldy #$00
   337
   338 					mva (bp2),y :STACKORIGIN,x
   339 					iny
   340 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   341
   342 					rts
   343 				.endp
   344
   345
   346 				.proc	@pushCARD (.word ya) .reg
   347 					add :STACKORIGIN,x
   348 					sta bp2
   349 					tya
   350 					adc :STACKORIGIN+STACKWIDTH,x
   351 					sta bp2+1
   352
   353 					ldy #$00
   354
   355 					mva (bp2),y :STACKORIGIN,x
   356 					iny
   357 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   358 					iny
   359 					mva (bp2),y :STACKORIGIN+STACKWIDTH*2,x
   360 					iny
   361 					mva (bp2),y :STACKORIGIN+STACKWIDTH*3,x
   362
   363 					rts
   364 				.endp
   365 				*/
   365
   366
   367 8A12			.proc	shlEAX_CL
   368
   369 				;SHORT	jsr @expandToCARD1.SHORT
   370 				;	jmp CARD
   371
   372 				;SMALL	jsr @expandToCARD1.SMALL
   373 				;	jmp CARD
   374
   375 8A12			BYTE	lda #0
   376 					sta :STACKORIGIN-1+STACKWIDTH,x
   377
   378 8A12			WORD	lda #0
   379 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   380 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   381
   382 8A12			CARD	clc
   383 					ldy :STACKORIGIN,x	; cl
   384 					beq stop
   385 8A12			@	asl :STACKORIGIN-1,x	; eax
   386 					rol :STACKORIGIN-1+STACKWIDTH,x
   387 					rol :STACKORIGIN-1+STACKWIDTH*2,x
   388 					rol :STACKORIGIN-1+STACKWIDTH*3,x
   389 					dey
   390 					bne @-
   391
   392 8A12			stop	rts
   393 				.endp
   394
   395
   396 8A12			.proc	shrAL_CL
   397
   398 				;SHORT	jsr @expandToCARD1.SHORT
   399 				;	jmp shrEAX_CL
   400
   401 8A12			BYTE	ldy :STACKORIGIN,x	; cl
   402 					beq stop
   403 8A12			@	lsr :STACKORIGIN-1,x
   404 					dey
   405 					bne @-
   406
   407 8A12			stop	lda #0
   408 					sta :STACKORIGIN-1+STACKWIDTH,x
   409 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   410 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   411
   412 					rts
   413 				.endp
   414
   415 8A12			.proc	shrAX_CL
   416
   417 				;SMALL	jsr @expandToCARD1.SMALL
   418 				;	jmp shrEAX_CL
   419
   420 8A12			WORD	ldy :STACKORIGIN,x	; cl
   421 					beq stop
   422 8A12			@	lsr :STACKORIGIN-1+STACKWIDTH,x
   423 					ror :STACKORIGIN-1,x
   424 					dey
   425 					bne @-
   426
   427 8A12			stop	lda #0
   428 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   429 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   430
   431 					rts
   432 				.endp
   433
   434 8A12			.proc	shrEAX_CL
   435
   436 					ldy :STACKORIGIN,x	; cl
   437 					beq stop
   438 8A12			@	lsr :STACKORIGIN-1+STACKWIDTH*3,x
   439 					ror :STACKORIGIN-1+STACKWIDTH*2,x
   440 					ror :STACKORIGIN-1+STACKWIDTH,x
   441 					ror :STACKORIGIN-1,x
   442 					dey
   443 					bne @-
   444
   445 8A12			stop	rts
   446 				.endp
   447
   448 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   449 				; wynik operacji ADD zostanie potraktowany jako INTEGER / CARDINAL
   450 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   451
   452 8A12			.proc	addAL_CL
   453
   454 8A12 A0 00			ldy #0
   455 8A14 98				tya
   456 8A15 95 9F			sta :STACKORIGIN-1+STACKWIDTH*2,x
   457 8A17 95 AF			sta :STACKORIGIN-1+STACKWIDTH*3,x
   458
   459 8A19 B5 7F			lda :STACKORIGIN-1,x
   460 8A1B 18 75 80			add :STACKORIGIN,x
   461 8A1E 95 7F			sta :STACKORIGIN-1,x
   462 8A20 90 01			scc
   463 8A22 C8				iny
   464 8A23 98			  tya
   465 8A24 95 8F			sta :STACKORIGIN-1+STACKWIDTH,x
   466
   467 8A26 60				rts
   468 				.endp
   469
   470 8A27			.proc	addAX_CX
   471
   472 					ldy #0
   473
   474 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   475
   476 					lda :STACKORIGIN-1,x
   477 					add :STACKORIGIN,x
   478 					sta :STACKORIGIN-1,x
   479
   480 					lda :STACKORIGIN-1+STACKWIDTH,x
   481 					adc :STACKORIGIN+STACKWIDTH,x
   482 					sta :STACKORIGIN-1+STACKWIDTH,x
   483 					scc
   484 					iny
   485
   486 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   487
   488 					rts
   489 				.endp
   490
   491
   492 8A27			.proc	addEAX_ECX
   493 				/*
   494 				SHORT	jsr @expandToCARD.SHORT
   495 					jsr @expandToCARD1.SHORT
   496 					jmp CARD
   497
   498 				SMALL	jsr @expandToCARD.SMALL
   499 					jsr @expandToCARD1.SMALL
   500 				*/
   500
   501 8A27			CARD	lda :STACKORIGIN-1,x
   502 					add :STACKORIGIN,x
   503 					sta :STACKORIGIN-1,x
   504
   505 					lda :STACKORIGIN-1+STACKWIDTH,x
   506 					adc :STACKORIGIN+STACKWIDTH,x
   507 					sta :STACKORIGIN-1+STACKWIDTH,x
   508
   509 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   510 					adc :STACKORIGIN+STACKWIDTH*2,x
   511 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   512
   513 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   514 					adc :STACKORIGIN+STACKWIDTH*3,x
   515 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   516
   517 					rts
   518 				.endp
   519
   520
   521 8A27			.proc	subAL_CL
   522
   523 					ldy #0
   524
   525 					lda :STACKORIGIN-1,x
   526 					sub :STACKORIGIN,x
   527 					sta :STACKORIGIN-1,x
   528 					scs
   529 					dey
   530
   531 					sty :STACKORIGIN-1+STACKWIDTH,x
   532 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   533 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   534
   535 					rts
   536 				.endp
   537
   538 8A27			.proc	subAX_CX
   539
   540 					ldy #0
   541
   542 					lda :STACKORIGIN-1,x		; ax
   543 					sub :STACKORIGIN,x		; cx
   544 					sta :STACKORIGIN-1,x
   545
   546 					lda :STACKORIGIN-1+STACKWIDTH,x
   547 					sbc :STACKORIGIN+STACKWIDTH,x
   548 					sta :STACKORIGIN-1+STACKWIDTH,x
   549 					scs
   550 					dey
   551
   552 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   553 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   554
   555 					rts
   556 				.endp
   557
   558 8A27			.proc	subEAX_ECX
   559
   560 					lda :STACKORIGIN-1,x
   561 					sub :STACKORIGIN,x
   562 					sta :STACKORIGIN-1,x
   563
   564 					lda :STACKORIGIN-1+STACKWIDTH,x
   565 					sbc :STACKORIGIN+STACKWIDTH,x
   566 					sta :STACKORIGIN-1+STACKWIDTH,x
   567
   568 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   569 					sbc :STACKORIGIN+STACKWIDTH*2,x
   570 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   571
   572 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   573 					sbc :STACKORIGIN+STACKWIDTH*3,x
   574 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   575
   576 					rts
   577 				.endp
   578
   579
   580 8A27			.proc	@expandSHORT2SMALL
   581 					ldy #$00
   582 					lda :STACKORIGIN,x
   583 					spl
   584 					dey
   585 					sty :STACKORIGIN+STACKWIDTH,x
   586
   587 					rts
   588 				.endp
   589
   590 8A27			.proc	@expandSHORT2SMALL1
   591 					ldy #$00
   592 					lda :STACKORIGIN-1,x
   593 					spl
   594 					dey
   595 					sty :STACKORIGIN-1+STACKWIDTH,x
   596
   597 					rts
   598 				.endp
   599
   600
   601 8A27			.proc	@expandToCARD
   602
   603 8A27 B5 90		SMALL	lda :STACKORIGIN+STACKWIDTH,x
   604 8A29 10 04			bpl WORD
   605
   606 8A2B A9 FF			lda #$ff
   607 8A2D D0 10			bne _wo
   608
   609 8A2F A9 00		WORD	lda #$00
   610 8A31 F0 0C			beq _wo
   611
   612 8A33 B5 80		SHORT	lda :STACKORIGIN,x
   613 8A35 10 04			bpl BYTE
   614
   615 8A37 A9 FF			lda #$ff
   616 8A39 D0 02			bne _by
   617
   618 8A3B A9 00		BYTE	lda #$00
   619
   620 8A3D 95 90		_by	sta :STACKORIGIN+STACKWIDTH,x
   621 8A3F 95 A0		_wo	sta :STACKORIGIN+STACKWIDTH*2,x
   622 8A41 95 B0		_lo	sta :STACKORIGIN+STACKWIDTH*3,x
   623 8A43 60				rts
   624 				.endp
   625
   626
   627 8A44			.proc	@expandToCARD1
   628
   629 8A44			SMALL	lda :STACKORIGIN-1+STACKWIDTH,x
   630 					bpl WORD
   631
   632 					lda #$ff
   633 					bne _wo
   634
   635 8A44			WORD	lda #$00
   636 					beq _wo
   637
   638 8A44			SHORT	lda :STACKORIGIN-1,x
   639 					bpl BYTE
   640
   641 					lda #$ff
   642 					bne _by
   643
   644 8A44			BYTE	lda #$00
   645
   646 8A44			_by	sta :STACKORIGIN-1+STACKWIDTH,x
   647 8A44			_wo	sta :STACKORIGIN-1+STACKWIDTH*2,x
   648 8A44			_lo	sta :STACKORIGIN-1+STACKWIDTH*3,x
   649 					rts
   650 				.endp
   651
   652 				/*
   653 				.proc	@cmpFor_WORD (.word ya) .reg
   654 					sta ztmp
   655 					sty ztmp+1
   656
   657 					ldy #1
   658 					lda (ztmp),y
   659 					cmp :STACKORIGIN+1+STACKWIDTH,x
   660 					bne stop
   661 					dey
   662 					lda (ztmp),y
   663 					cmp :STACKORIGIN+1,x
   664 				stop	rts
   665 				.endp
   666
   667
   668 				.proc	@cmpFor_CARD (.word ya) .reg
   669 					sta ztmp
   670 					sty ztmp+1
   671
   672 					ldy #3
   673 					lda (ztmp),y
   674 					cmp :STACKORIGIN+1+STACKWIDTH*3,x
   675 					bne stop
   676 					dey
   677 					lda (ztmp),y
   678 					cmp :STACKORIGIN+1+STACKWIDTH*2,x
   679 					bne stop
   680 					dey
   681 					lda (ztmp),y
   682 					cmp :STACKORIGIN+1+STACKWIDTH,x
   683 					bne stop
   684 					dey
   685 					lda (ztmp),y
   686 					cmp :STACKORIGIN+1,x
   687
   688 				stop	rts
   689 				.endp
   690
   691
   692 				.proc	@cmpFor_SHORTINT(.word ya) .reg
   693 					sta ztmp
   694 					sty ztmp+1
   695
   696 					ldy	#0
   697 					lda	(ztmp),y
   698 					sec
   699 					sbc	:STACKORIGIN+1,x
   700 					bne	@cmpFor_INT.L4
   701
   702 					jmp	@cmpFor_INT.L1
   703 				.endp
   704
   705
   706 				.proc	@cmpFor_SMALLINT(.word ya) .reg
   707 					sta ztmp
   708 					sty ztmp+1
   709
   710 					ldy	#1
   711 					lda	(ztmp),y
   712 					sec
   713 					sbc	:STACKORIGIN+1+STACKWIDTH,x
   714 					bne	@cmpFor_INT.L4
   715
   716 					dey
   717 					lda	(ztmp),y
   718 					cmp	:STACKORIGIN+1,x
   719
   720 					jmp	@cmpFor_INT.L1
   721 				.endp
   722
   723
   724 				.proc	@cmpFor_INT(.word ya) .reg
   725 					sta ztmp
   726 					sty ztmp+1
   727
   728 					ldy	#3
   729 					lda	(ztmp),y
   730 					sec
   731 					sbc	:STACKORIGIN+1+STACKWIDTH*3,x
   732 					bne	L4
   733
   734 					dey
   735 					lda	(ztmp),y
   736 					cmp	:STACKORIGIN+1+STACKWIDTH*2,x
   737 					bne	L1
   738
   739 					dey
   740 					lda	(ztmp),y
   741 					cmp	:STACKORIGIN+1+STACKWIDTH,x
   742 					bne	L1
   743
   744 					dey
   745 					lda	(ztmp),y
   746 					cmp	:STACKORIGIN+1,x
   747
   748 				L1	beq	L2
   749 					bcs	L3
   750
   751 					lda	#$FF	; Set the N flag
   752 				L2	rts
   753
   754 				L3	lda	#$01	; Clear the N flag
   755 					rts
   756
   757 				L4	bvc	L5
   758 					eor	#$FF	; Fix the N flag if overflow
   759 					ora	#$01	; Clear the Z flag
   760 				L5	rts
   761 				.endp
   762 				*/
   762
   763
   764 				; Piotr Fusik, 15.04.2002
   765 				; originally by Ullrich von Bassewitz
   766
   767 8A44			.proc	cmpSHORTINT
   768 					lda	:STACKORIGIN-1,x
   769 					clv:sec
   770 					sbc	:STACKORIGIN,x
   771 					bne	cmpINT.L4
   772
   773 					jmp	cmpINT.L1
   774 				.endp
   775
   776
   777 8A44			.proc	cmpSMALLINT
   778 					lda	:STACKORIGIN-1+STACKWIDTH,x
   779 					clv:sec
   780 					sbc	:STACKORIGIN+STACKWIDTH,x
   781 					bne	cmpINT.L4
   782
   783 					lda	:STACKORIGIN-1,x
   784 					cmp	:STACKORIGIN,x
   785
   786 					jmp	cmpINT.L1
   787 				.endp
   788
   789
   790 8A44			.proc	cmpINT
   791 					lda	:STACKORIGIN-1+STACKWIDTH*3,x
   792 					clv:sec
   793 					sbc	:STACKORIGIN+STACKWIDTH*3,x
   794 					bne	L4
   795
   796 					lda	:STACKORIGIN-1+STACKWIDTH*2,x
   797 					cmp	:STACKORIGIN+STACKWIDTH*2,x
   798 					bne	L1
   799
   800 					lda	:STACKORIGIN-1+STACKWIDTH,x
   801 					cmp	:STACKORIGIN+STACKWIDTH,x
   802 					bne	L1
   803
   804 					lda	:STACKORIGIN-1,x
   805 					cmp	:STACKORIGIN,x
   806
   807 8A44			L1	beq	L2
   808 					bcs	L3
   809
   810 					lda	#$FF	; Set the N flag
   811 8A44			L2	rts
   812
   813 8A44			L3	lda	#$01	; Clear the N flag
   814 					rts
   815
   816 8A44			L4	bvc	L5
   817 					eor	#$FF	; Fix the N flag if overflow
   818 					ora	#$01	; Clear the Z flag
   819 8A44			L5	rts
   820 				.endp
   821
   822
   823 8A44			.proc	cmpEAX_ECX
   824 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   825 					cmp :STACKORIGIN+STACKWIDTH*3,x
   826 					bne _done
   827 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   828 					cmp :STACKORIGIN+STACKWIDTH*2,x
   829 					bne _done
   830 8A44			AX_CX
   831 					lda :STACKORIGIN-1+STACKWIDTH,x
   832 					cmp :STACKORIGIN+STACKWIDTH,x
   833 					bne _done
   834 					lda :STACKORIGIN-1,x
   835 					cmp :STACKORIGIN,x
   836
   837 8A44			_done	rts
   838 				.endp
   839
   840
   841 8A44			.proc	cmpSTRING2CHAR
   842
   843 					lda :STACKORIGIN-1,x
   844 					sta ztmp8
   845 					lda :STACKORIGIN-1+STACKWIDTH,x
   846 					sta ztmp8+1
   847
   848 					lda :STACKORIGIN,x
   849 					sta ztmp10
   850
   851 					ldy #0
   852
   853 					lda (ztmp8),y		; if length <> 1
   854 					cmp #1
   855 					bne fail
   856
   857 					iny
   858
   859 8A44			loop	lda (ztmp8),y
   860 					cmp ztmp10
   861 					bne fail
   862
   863 					lda #0
   864 					seq
   865
   866 8A44			fail	lda #$ff
   867
   868 					ldy #1
   869
   870 					cmp #0
   871 					rts
   872 				.endp
   873
   874
   875
   876 8A44			.proc	cmpCHAR2STRING
   877
   878 					lda :STACKORIGIN-1,x
   879 					sta ztmp8
   880
   881 					lda :STACKORIGIN,x
   882 					sta ztmp10
   883 					lda :STACKORIGIN+STACKWIDTH,x
   884 					sta ztmp10+1
   885
   886 					ldy #0
   887
   888 					lda (ztmp10),y		; if length <> 1
   889 					cmp #1
   890 					bne fail
   891
   892 					iny
   893
   894 8A44			loop	lda (ztmp10),y
   895 					cmp ztmp8
   896 					bne fail
   897
   898 					lda #0
   899 					seq
   900
   901 8A44			fail	lda #$ff
   902
   903 					ldy #1
   904
   905 					cmp #0
   906 					rts
   907 				.endp
   908
   909
   910 8A44			.proc	cmpSTRING
   911 				  max = ctmp0
   912 					lda :STACKORIGIN-1,x
   913 					sta ztmp8
   914 					lda :STACKORIGIN-1+STACKWIDTH,x
   915 					sta ztmp8+1
   916
   917 					lda :STACKORIGIN,x
   918 					sta ztmp10
   919 					lda :STACKORIGIN+STACKWIDTH,x
   920 					sta ztmp10+1
   921
   922 					l?? #0 ???  	rts    ???o  ? Y  ?   ???  .endp   ???B  ?       ???  	iny    ???  	iny    ???  	bne l3 ???  	bne l3 ???  .endp Y ???  	bne l3 ???  .endp   ???  .endp   ???  .endp  ????  	spl   ????  .endp Y ??? 
   923
   924 					lda (ztmp8),y		; if length1 = 0
   925 					beq fail
   926 					lda (ztmp10),y		; if length2 = 0
   927 					beq fail
   928
   929 					lda (ztmp8),y		; if length1 <> length2
   930 					cmp (ztmp10),y
   931 					bne fail
   932
   933 					sta max
   934
   935 					inw ztmp8
   936 					inw ztmp10
   937
   938 8A44			loop	
   939 				  lda (ztmp8),y
   940 					cmp (ztmp10),y
   941 					bne fail
   942
   943 					iny
   944
   945
   946 					cpy max
   947 					bne loop
   948
   949 					lda #0
   950 					seq
   951
   952 8A44			fail
   953 					lda #$ff
   954 					ldy #1
   955
   956 					cmp #0
   957 					rts
   958 				.endp
   959
   960
   961 8A44			.proc	notaBX
   962
   963 					.rept MAXSIZE
   964 					LDA :STACKORIGIN+#*STACKWIDTH,X
   965 					EOR #$FF
   966 					STA :STACKORIGIN+#*STACKWIDTH,X
   967 					.ENDR
   967 					.endr
Source: REPT
   964 					LDA :STACKORIGIN+#*STACKWIDTH,X
   964 					EOR #$FF
   964 					STA :STACKORIGIN+#*STACKWIDTH,X
   964 					LDA :STACKORIGIN+#*STACKWIDTH,X
   964 					EOR #$FF
   964 					STA :STACKORIGIN+#*STACKWIDTH,X
   964 					LDA :STACKORIGIN+#*STACKWIDTH,X
   964 					EOR #$FF
   964 					STA :STACKORIGIN+#*STACKWIDTH,X
   964 					LDA :STACKORIGIN+#*STACKWIDTH,X
   964 					EOR #$FF
   964 					STA :STACKORIGIN+#*STACKWIDTH,X
Source: cpu6502.asm
   968
   969 					rts
   970 				.endp
   971
   972
   973 8A44			.proc	notBOOLEAN
   974 					lda :STACKORIGIN,x
   975 					bne _0
   976
   977 					lda #true
   978 					sne
   979
   980 8A44			_0	lda #false
   981 					sta :STACKORIGIN,x
   982
   983 					rts
   984 				.endp
   985
   986
   987 8A44			.proc	negBYTE
   988 					lda #$00
   989 					sub :STACKORIGIN,x
   990 					sta :STACKORIGIN,x
   991
   992 					lda #$00
   993 					sbc #$00
   994 					sta :STACKORIGIN+STACKWIDTH,x
   995
   996 					lda #$00
   997 					sbc #$00
   998 					sta :STACKORIGIN+STACKWIDTH*2,x
   999
  1000 					lda #$00
  1001 					sbc #$00
  1002 					sta :STACKORIGIN+STACKWIDTH*3,x
  1003
  1004 					rts
  1005 				.endp
  1006
  1007 8A44			.proc	negWORD
  1008 					lda #$00
  1009 					sub :STACKORIGIN,x
  1010 					sta :STACKORIGIN,x
  1011
  1012 					lda #$00
  1013 					sbc :STACKORIGIN+STACKWIDTH,x
  1014 					sta :STACKORIGIN+STACKWIDTH,x
  1015
  1016 					lda #$00
  1017 					sbc #$00
  1018 					sta :STACKORIGIN+STACKWIDTH*2,x
  1019
  1020 					lda #$00
  1021 					sbc #$00
  1022 					sta :STACKORIGIN+STACKWIDTH*3,x
  1023
  1024 					rts
  1025 				.endp
  1026
  1027 8A44			.proc	negCARD
  1028 8A44 A9 00			lda #$00
  1029 8A46 38 F5 80			sub :STACKORIGIN,x
  1030 8A49 95 80			sta :STACKORIGIN,x
  1031
  1032 8A4B A9 00			lda #$00
  1033 8A4D F5 90			sbc :STACKORIGIN+STACKWIDTH,x
  1034 8A4F 95 90			sta :STACKORIGIN+STACKWIDTH,x
  1035
  1036 8A51 A9 00			lda #$00
  1037 8A53 F5 A0			sbc :STACKORIGIN+STACKWIDTH*2,x
  1038 8A55 95 A0			sta :STACKORIGIN+STACKWIDTH*2,x
  1039
  1040 8A57 A9 00			lda #$00
  1041 8A59 F5 B0			sbc :STACKORIGIN+STACKWIDTH*3,x
  1042 8A5B 95 B0			sta :STACKORIGIN+STACKWIDTH*3,x
  1043
  1044 8A5D 60				rts
  1045 				.endp
  1046
  1047
  1048 8A5E			.proc	negBYTE1
  1049 					lda #$00
  1050 					sub :STACKORIGIN-1,x
  1051 					sta :STACKORIGIN-1,x
  1052
  1053 					lda #$00
  1054 					sbc #$00
  1055 					sta :STACKORIGIN-1+STACKWIDTH,x
  1056
  1057 					lda #$00
  1058 					sbc #$00
  1059 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1060
  1061 					lda #$00
  1062 					sbc #$00
  1063 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1064
  1065 					rts
  1066 				.endp
  1067
  1068 8A5E			.proc	negWORD1
  1069 					lda #$00
  1070 					sub :STACKORIGIN-1,x
  1071 					sta :STACKORIGIN-1,x
  1072
  1073 					lda #$00
  1074 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1075 					sta :STACKORIGIN-1+STACKWIDTH,x
  1076
  1077 					lda #$00
  1078 					sbc #$00
  1079 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1080
  1081 					lda #$00
  1082 					sbc #$00
  1083 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1084
  1085 					rts
  1086 				.endp
  1087
  1088 8A5E			.proc	negCARD1
  1089 					lda #$00
  1090 					sub :STACKORIGIN-1,x
  1091 					sta :STACKORIGIN-1,x
  1092
  1093 					lda #$00
  1094 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1095 					sta :STACKORIGIN-1+STACKWIDTH,x
  1096
  1097 					lda #$00
  1098 					sbc :STACKORIGIN-1+STACKWIDTH*2,x
  1099 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1100
  1101 					lda #$00
  1102 					sbc :STACKORIGIN-1+STACKWIDTH*3,x
  1103 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1104
  1105 					rts
  1106 				.endp
  1107
  1108
  1109 8A5E			.proc	andAL_CL
  1110
  1111 					lda :STACKORIGIN-1,x
  1112 					and :STACKORIGIN,x
  1113 					sta :STACKORIGIN-1,x
  1114
  1115 					rts
  1116 				.endp
  1117
  1118 8A5E			.proc	andAX_CX
  1119
  1120 					.rept 2
  1121 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1122 					AND :STACKORIGIN+#*STACKWIDTH,X
  1123 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1124 					.ENDR
  1124 					.endr
Source: REPT
  1121 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1121 					AND :STACKORIGIN+#*STACKWIDTH,X
  1121 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1121 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1121 					AND :STACKORIGIN+#*STACKWIDTH,X
  1121 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1125
  1126 					rts
  1127 				.endp
  1128
  1129 8A5E			.proc	andEAX_ECX
  1130
  1131 					.rept MAXSIZE
  1132 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1133 					AND :STACKORIGIN+#*STACKWIDTH,X
  1134 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1135 					.ENDR
  1135 					.endr
Source: REPT
  1132 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					AND :STACKORIGIN+#*STACKWIDTH,X
  1132 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					AND :STACKORIGIN+#*STACKWIDTH,X
  1132 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					AND :STACKORIGIN+#*STACKWIDTH,X
  1132 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					AND :STACKORIGIN+#*STACKWIDTH,X
  1132 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1136
  1137 					rts
  1138 				.endp
  1139
  1140
  1141 8A5E			.proc	orAL_CL
  1142
  1143 					lda :STACKORIGIN-1,x
  1144 					ora :STACKORIGIN,x
  1145 					sta :STACKORIGIN-1,x
  1146
  1147 					rts
  1148 				.endp
  1149
  1150 8A5E			.proc	orAX_CX
  1151
  1152 					.rept 2
  1153 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1154 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1155 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1156 					.ENDR
  1156 					.endr
Source: REPT
  1153 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1153 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1153 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1153 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1153 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1153 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1157
  1158 					rts
  1159 				.endp
  1160
  1161 8A5E			.proc	orEAX_ECX
  1162
  1163 					.rept MAXSIZE
  1164 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1165 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1166 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1167 					.ENDR
  1167 					.endr
Source: REPT
  1164 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1164 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1164 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1164 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1164 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1168
  1169 					rts
  1170 				.endp
  1171
  1172
  1173 8A5E			.proc	xorAL_CL
  1174
  1175 					lda :STACKORIGIN-1,x
  1176 					eor :STACKORIGIN,x
  1177 					sta :STACKORIGIN-1,x
  1178
  1179 					rts
  1180 				.endp
  1181
  1182 8A5E			.proc	xorAX_CX
  1183
  1184 					.rept 2
  1185 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1186 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1187 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1188 					.ENDR
  1188 					.endr
Source: REPT
  1185 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1185 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1185 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1185 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1185 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1185 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1189
  1190 					rts
  1191 				.endp
  1192
  1193 8A5E			.proc	xorEAX_ECX
  1194
  1195 					.rept MAXSIZE
  1196 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1197 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1198 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1199 					.ENDR
  1199 					.endr
Source: REPT
  1196 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1196 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1196 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1196 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1196 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1200
  1201 					rts
  1202 				.endp
  1203
  1204
  1205 				/*
  1206 				.proc	iniEAX_ECX_BYTE
  1207
  1208 					mva :STACKORIGIN,x ecx
  1209 					mva :STACKORIGIN-1,x eax
  1210
  1211 					rts
  1212 				.endp
  1213 				*/
  1213
  1214
  1215
  1216 8A5E			.proc	iniEAX_ECX_WORD
  1217
  1218 					mva :STACKORIGIN,x ecx
  1219 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1220
  1221 					mva :STACKORIGIN-1,x eax
  1222 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1223
  1224 					mva #$00 ecx+2
  1225 					sta ecx+3
  1226
  1227 					sta eax+2
  1228 					sta eax+3
  1229
  1230 					rts
  1231 				.endp
  1232
  1233
  1234 8A5E			.proc	iniEAX_ECX_CARD
  1235 					mva :STACKORIGIN,x ecx
  1236 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1237 					mva :STACKORIGIN+STACKWIDTH*2,x ecx+2
  1238 					mva :STACKORIGIN+STACKWIDTH*3,x ecx+3
  1239
  1240 					mva :STACKORIGIN-1,x eax
  1241 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1242 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
  1243 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
  1244
  1245 					rts
  1246 				.endp
  1247
  1248 8A5E			.proc	movZTMP_aBX
  1249 					mva ZTMP8 :STACKORIGIN-1,x
  1250 					mva ZTMP9 :STACKORIGIN-1+STACKWIDTH,x
  1251 					mva ZTMP10 :STACKORIGIN-1+STACKWIDTH*2,x
  1252 					mva ZTMP11 :STACKORIGIN-1+STACKWIDTH*3,x
  1253
  1254 					rts
  1255 				.endp
  1256
  1257
  1258 8A5E				icl '6502\cpu6502_sio.asm'
Source: cpu6502_sio.asm
     1
     2 8A5E			.proc	@sio
     3
     4 					stx dbufa		;< adres bufora
     5 					sty dbufa+1		;> adres bufora
     6 					sta dcmnd		; 'R' read sector / 'P' write sector
     7
     8 					ldy dunit
     9 					lda lsector-1,y
    10 					sta dsctln		; < dlugosc sektora
    11 				;	sta dbyt		;< dlugosc bufora
    12
    13 					lda hsector-1,y
    14 					sta dsctln+1		; > dlugosc sektora 
    15 				;	sta dbyt+1		;> dlugosc bufora
    16
    17 					lda #$c0		; $40 read / $80 write
    18 					sta dstats
    19
    20 					lda #0
    21 					sta casflg		; = 00 to indicate that it isn't a cassette operation
    22
    23 					jmp jdskint
    24
    25 				// A = [1..8]
    26 8A5E			devnrm	tax
    27
    28 					CLC			; clear carry for add
    29 					ADC #$FF-8		; make m = $FF
    30 					ADC #8-1+1		; carry set if in range n to m
    31 					bcs ok
    32
    33 					ldy #-123		; kod bledu "DEVICE OR FILE NOT OPEN"
    34 					rts
    35 					
    36 8A5E			ok	txa
    37 					sta dunit		; nr stacji
    38 					ora #$30
    39 					sta ddevic		; nr stacji + $30
    40
    41 					lda #7
    42 					sta dtimlo		; timeout
    43
    44 					ldy #0
    45 					rts
    46
    47 8A5E			devsec	tya			; zapisz rozmiar sektora
    48 					ldy dunit
    49 					sta hsector-1,y
    50 					txa
    51 					sta lsector-1,y
    52 					rts
    53
    54 8A5E			lsector	:8 dta l(256)
    55 8A5E			hsector	:8 dta h(256)
    56
    57 				.endp
  1259 8A5E				icl '6502\cpu6502_cio.asm'
Source: cpu6502_cio.asm
     1
     2 				/*
     3 					Reset(f, record)
     4 					Rewrite(f, record)
     5
     6 					C = 1	SEC	IOCHECK TRUE
     7 					C = 0	CLC	IOCHECK FALSE
     8 				*/
     8
     9
    10 8A5E			.proc	@openfile (.word ya .byte x) .reg
    11
    12 = 00EA			lfname		= ctmp0
    13 = 00EB			hfname		= ctmp1
    14 = 00EC			code			= ctmp2
    15 = 00ED			iocheck		= ctmp3
    16
    17 					sta bp2
    18 					sty bp2+1
    19
    20 					stx code
    21
    22 					lda #0
    23 					rol @
    24 					sta iocheck
    25
    26 					ldy #s@file.status
    27 					lda (bp2),y
    28 					and #e@file.eof^$ff
    29 					sta (bp2),y
    30
    31 					ldy #s@file.pfname
    32 					lda (bp2),y
    33 					add #1
    34 					sta lfname
    35 					iny
    36 					lda (bp2),y
    37 					adc #0
    38 					sta hfname
    39
    40 					jsr lookup
    41 					bmi error
    42
    43 					ldy #s@file.chanel
    44 					txa
    45 					sta (bp2),y		;CHANNEL
    46
    47 				; -----------------------------------------
    48
    49 					lda #$03		;komenda: OPEN
    50 					sta iccmd,x
    51 					lda lfname
    52 					sta icbufa,x
    53 					lda hfname
    54 					sta icbufa+1,x
    55 					lda code
    56 					sta icax1,x
    57 					lda #$00		;dodatkowy parametr, $00 jest zawsze dobre
    58 					sta icax2,x
    59 					jsr ciov
    60
    61 8A5E			error	sty MAIN.SYSTEM.IOResult
    62
    63 					bpl ok
    64
    65 8A5E			msg	lda iocheck
    66 					beq skp
    67
    68 					sty dx
    69 				;	sty FX_CORE_RESET
    70
    71 					@clrscr
    72
    73 					lda <_error
    74 					ldy >_error
    75 					jsr @printSTRING
    76
    77 					lda #$00
    78 					sta dx+1
    79 					sta dx+2
    80 					sta dx+3
    81
    82 					jsr @printVALUE
    83
    84 					jmp MAIN.@halt
    85
    86 8A5E			skp	ldy #s@file.status
    87 					lda (bp2),y
    88 					ora #e@file.eof
    89 					sta (bp2),y
    90
    91 					ldy #s@file.record
    92 					lda #$00
    93 					sta (bp2),y
    94 					iny
    95 					sta (bp2),y
    96
    97 					rts
    98
    99 8A5E			ok	ldy #s@file.status
   100 					lda (bp2),y
   101 					ora #e@file.open
   102 					sta (bp2),y
   103
   104 					rts
   105
   106 8A5E			_error	dta 6,c'ERROR '
   107
   108 				; -----------------------------------------
   109
   110 8A5E			lookup	ldx #$00
   111 					ldy #$01
   112 8A5E			loop	lda icchid,x
   113 					cmp #$ff
   114 					beq found
   115 					txa
   116 					clc
   117 					adc #$10
   118 					tax
   119 					bpl loop
   120 					ldy #-95       		; kod bledu "TOO MANY CHANNELS OPEN"
   121 8A5E			found	rts
   122 				.endp
   123
   124
   125 				/*
   126 					Close(f)
   127
   128 					C = 1	SEC	IOCHECK TRUE
   129 					C = 0	CLC	IOCHECK FALSE
   130 				*/
   130
   131
   132 8A5E			.proc	@closefile (.word ya) .reg
   133 					sta	bp2
   134 					sty	bp2+1
   135
   136 					ldy	#s@file.status
   137
   138 					lda	#0
   139 					rol	@
   140 					sta	@openfile.iocheck
   141 				;	beq	ok_open
   142
   143 					lda	(bp2),y
   144 					and 	#e@file.open
   145 					bne	ok_open
   146
   147 					ldy	#-123		; kod bledu "DEVICE OR FILE NOT OPEN"
   148 					jmp	@openfile.error
   149
   150 8A5E			ok_open	lda	(bp2),y
   151 					ora	#e@file.eof
   152 					sta	(bp2),y
   153
   154 					ldy	#s@file.chanel
   155 					lda	(bp2),y
   156 					tax
   157
   158 					lda	#$0c		;komenda: CLOSE
   159 					sta	iccmd,x
   160 					jsr	ciov
   161
   162 				;	lda	#0		; iocheck off
   163 				;	sta	@openfile.iocheck
   164
   165 					jmp	@openfile.error
   166
   167 				.endp
   168
   169
   170 				/*
   171 					BlockRead(f, buf, num_records, numread)
   172 					BlockWrite(f, buf, num_records, numwrite)
   173
   174 					C = 1	SEC	IOCHECK TRUE
   175 					C = 0	CLC	IOCHECK FALSE
   176 				*/
   176
   177
   178 8A5E			.proc	@readfile (.word ya .byte x) .reg
   179 					code			= ctmp2
   180 					sta	bp2
   181 					sty	bp2+1
   182
   183 					stx	code
   184
   185 					lda	#$00
   186 					sta	eax+2
   187 					sta	eax+3
   188 					sta	ecx+2
   189 					sta	ecx+3
   190
   191 					sta	MAIN.SYSTEM.IOResult
   192
   193 					rol	@
   194 					sta	@openfile.iocheck
   195
   196 					ldy	#s@file.status
   197 					lda	(bp2),y
   198 					and	#e@file.open
   199 					bne	ok_open
   200
   201 					ldy	#-123			; kod bledu "DEVICE OR FILE NOT OPEN"
   202 					jmp	@openfile.error
   203
   204 8A5E			ok_open	ldy	#s@file.record
   205 					mwa	(bp2),y	ecx
   206
   207 					ldy	#s@file.nrecord
   208 					mwa	(bp2),y	eax
   209
   210 				;	lda	#0
   211 					jsr	imulCX			; record * nrecord = file length to load
   212
   213 					cpw	eax #0
   214 					beq	nothing
   215
   216 					ldy	#s@file.chanel
   217 					lda	(bp2),y
   218 					tax
   219
   220 					mwa	eax	icbufl,x
   221
   222 					ldy	#s@file.buffer
   223 					mwa	(bp2),y	icbufa,x
   224
   225 					lda	code
   226 					and	#$7f
   227 					sta	iccmd,x
   228
   229 					jsr	ciov
   230
   231 					sty	MAIN.SYSTEM.IOResult
   232
   233 					bpl ok
   234
   235 					cpy #136
   236 					beq done
   237
   238 					jsr eof
   239
   240 					lda #$00
   241 					sta eax
   242 					sta eax+1
   243
   244 					jmp	@openfile.msg
   245
   246 8A5E			done	jsr eof
   247
   248 8A5E			ok	mwa icbufl,x	eax
   249 					ldy #s@file.record
   250 					mwa (bp2),y	ecx
   251
   252 					lda #$00
   253 					jsr idivAX_CX.main
   254
   255 8A5E			nothing	lda code
   256 					bpl quit			; blockread(f, buf, len)   short version
   257
   258 					ldy #s@file.numread
   259 					mwa (bp2),y ztmp
   260
   261 					ldy #0
   262 					mwa eax (ztmp),y		; length of loaded data / record = number of records
   263
   264 8A5E			quit	rts
   265
   266 8A5E			eof	ldy #s@file.status
   267 					lda (bp2),y
   268 					ora #e@file.eof
   269 					sta (bp2),y
   270
   271 					rts
   272 				.endp
   273
   274
   275 8A5E			.proc	@ReadDirFileName (.word ya) .reg
   276
   277 					ldx #5
   278 					clc		; iocheck off
   279 					jsr @readfile	; (ya, x)
   280
   281 					ldy eax
   282
   283 					lda MAIN.SYSTEM.IOResult
   284 					smi
   285 					lda #0		; ok
   286
   287 					rts
   288 				.endp
   289
   290
   291 8A5E			.proc	@DirFileName
   292
   293
   294 = 00EA			attr = ctmp0
   295 = 00EB			ln	= ctmp1
   296
   297 					lda #0
   298 					sta attr
   299
   300 					cpy #$12
   301 					bne stop
   302
   303 					lda @buf
   304 					cmp #'*'
   305 					bne skp
   306
   307 					lda #MAIN.SYSUTILS.faReadOnly
   308 					sta attr
   309
   310 8A5E			skp	ldy #1
   311 					ldx #2
   312 					lda #10
   313 					jsr cpName
   314
   315 					ldx #10
   316 					lda @buf,x
   317 					pha
   318 					bpl files
   319
   320 					lda attr
   321 					ora #MAIN.SYSUTILS.faDirectory
   322 					sta attr
   323
   324 					jmp skp2
   325
   326 8A5E			files	lda attr
   327 					ora #MAIN.SYSUTILS.faArchive
   328 					sta attr
   329
   330 8A5E			skp2	pla
   331 					beq stp2
   332
   333 					lda #'.'
   334 					sta (bp2),y
   335 					iny
   336
   337 					lda #13
   338 					jsr cpName
   339 8A5E			stp2
   340 					dey
   341 					tya
   342 8A5E			stop	ldy #0
   343 					sta (bp2),y
   344
   345 					ldx attr
   346 					rts
   347
   348 8A5E			cpName	sta ln
   349 8A5E			cp	lda @buf,x
   350 					cmp #' '
   351 					beq stp
   352 					sta (bp2),y
   353 					iny
   354 					inx
   355 					cpx ln	
   356 					bne cp
   357 8A5E			stp	rts
   358 				.endp
   359
  1260
  1261 8A5E				icl '6502\cpu6502_shortint.asm'		; mul / div -> SHORTINT
Source: cpu6502_shortint.asm
     1
     2 				/*
     3 					mulSHORTINT
     4 					divmulSHORTINT
     5 				*/
     5
     6
     7
     8 8A5E			.proc	mulSHORTINT
     9
    10 					jsr imulBYTE
    11
    12 					lda :STACKORIGIN-1,x
    13 					bpl @+
    14 						sec
    15 						lda eax+1
    16 						sbc :STACKORIGIN,x
    17 						sta eax+1
    18 8A5E			@
    19 					lda :STACKORIGIN,x
    20 					bpl @+
    21 						sec
    22 						lda eax+1
    23 						sbc :STACKORIGIN-1,x
    24 						sta eax+1
    25 8A5E			@
    26 					jmp movaBX_EAX
    27 				.endp
    28
    29
    30 8A5E			.proc	divmulSHORTINT
    31
    32 8A5E			MOD	mva #{jsr} _mod
    33
    34 					lda :STACKORIGIN,x		; divisor sign
    35 					spl
    36 					jsr negBYTE
    37
    38 8A5E			DIV	ldy <idivBYTE
    39 					lda >idivBYTE
    40
    41 8A5E			skp	sty addr
    42 					sta addr+1
    43
    44 					ldy #0
    45
    46 					lda :STACKORIGIN-1,x		; dividend sign
    47 					bpl @+
    48 					jsr negBYTE1
    49 					iny
    50
    51 8A5E			@	lda :STACKORIGIN,x		; divisor sign
    52 					bpl @+
    53 					jsr negBYTE
    54 					iny
    55
    56 8A5E			@	tya
    57 					and #1
    58 					pha
    59
    60 					jsr $ffff			; idiv ecx
    61 8A5E			addr	equ *-2
    62
    63 					jsr movaBX_EAX
    64
    65 8A5E			_mod	bit movZTMP_aBX			; mod
    66 					mva #{bit} _mod
    67
    68 					pla
    69 					seq
    70 					jmp negCARD1
    71
    72 					rts
    73 				.endp
  1262 8A5E				icl '6502\cpu6502_smallint.asm'		; mul / div -> SMALLINT
Source: cpu6502_smallint.asm
     1
     2 				/*
     3 					mulSMALLINT
     4 					divmulSMALLINT
     5 				*/
     5
     6
     7
     8 8A5E			.proc	mulSMALLINT
     9
    10 					jsr imulWORD
    11
    12 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    13 					bpl @+
    14 						sec
    15 						lda eax+2
    16 						sbc :STACKORIGIN,x
    17 						sta eax+2
    18 						lda eax+3
    19 						sbc :STACKORIGIN+STACKWIDTH,x
    20 						sta eax+3
    21 8A5E			@
    22 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    23 					bpl @+
    24 						sec
    25 						lda eax+2
    26 						sbc :STACKORIGIN-1,x
    27 						sta eax+2
    28 						lda eax+3
    29 						sbc :STACKORIGIN-1+STACKWIDTH,x
    30 						sta eax+3
    31 8A5E			@
    32 					jmp movaBX_EAX
    33 				.endp
    34
    35
    36 8A5E			.proc	divmulSMALLINT
    37
    38 8A5E			SHORTREAL
    39 					ldy <divSHORTREAL
    40 					lda >divSHORTREAL
    41 					bne skp
    42
    43 8A5E			MOD	mva #{jsr} _mod
    44
    45 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    46 					spl
    47 					jsr negWORD
    48
    49 8A5E			DIV	ldy <idivWORD
    50 					lda >idivWORD
    51
    52 8A5E			skp	sty addr
    53 					sta addr+1
    54
    55 					ldy #0
    56
    57 					lda :STACKORIGIN-1+STACKWIDTH,x	; dividend sign
    58 					bpl @+
    59 					jsr negWORD1
    60 					iny
    61 8A5E			@
    62 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    63 					bpl @+
    64 					jsr negWORD
    65 					iny
    66 8A5E			@
    67 					tya
    68 					and #1
    69 					pha
    70
    71 					jsr $ffff			; idiv cx
    72 8A5E			addr	equ *-2
    73
    74 					jsr movaBX_EAX
    75
    76 8A5E			_mod	bit movZTMP_aBX			; mod
    77 					mva #{bit} _mod
    78
    79 					pla
    80 					seq
    81 					jmp negCARD1
    82
    83 					rts
    84 				.endp
  1263 8A5E				icl '6502\cpu6502_integer.asm'		; mul / div -> INTEGER
Source: cpu6502_integer.asm
     1
     2 				/*
     3 					mulINTEGER
     4 					divmulINT
     5 				*/
     5
     6
     7 8A5E			.proc	mulINTEGER
     8
     9 					jsr imulCARD
    10
    11 					jmp movaBX_EAX
    12 				.endp
    13
    14
    15 8A5E			.proc	divmulINT
    16
    17 8A5E			REAL	ldy <divREAL
    18 					lda >divREAL
    19 					bne skp
    20
    21 8A5E			MOD	mva #{jsr} _mod
    22
    23 					lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    24 					spl
    25 					jsr negCARD
    26
    27 8A5E			DIV	ldy <idivCARD
    28 					lda >idivCARD
    29
    30 8A5E			skp	sty addr
    31 					sta addr+1
    32
    33 					ldy #0
    34
    35 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; dividend sign
    36 					bpl @+
    37 					jsr negCARD1
    38 					iny
    39
    40 8A5E			@	lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    41 					bpl @+
    42 					jsr negCARD
    43 					iny
    44
    45 8A5E			@	tya
    46 					and #1
    47 					pha
    48
    49 					jsr $ffff				; idiv ecx
    50 8A5E			addr	equ *-2
    51 					jsr movaBX_EAX
    52
    53 8A5E			_mod	bit movZTMP_aBX				; mod
    54 					mva #{bit} _mod
    55
    56 					pla
    57 					seq
    58 					jmp negCARD1
    59
    60 					rts
    61 				.endp
  1264
  1265 8A5E				icl '6502\cpu6502_byte.asm'		; mul / div -> BYTE
Source: cpu6502_byte.asm
     1
     2 				/*
     3 					fmulu_8
     4 					imulCL
     5 					imulBYTE
     6 					idivBYTE
     7 					idiv_AL_CL
     8 				*/
     8
     9
    10 				; Description: Unsigned 8-bit multiplication with unsigned 16-bit result.
    11 				;
    12 				; Input: 8-bit unsigned value in T1
    13 				;	 8-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 16-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 8A5E			.proc fmulu_8
    31
    32 = 00C2			t1	= eax
    33 = 00CA			t2	= ecx
    34
    35 = 00C2			product	= eax
    36
    37 					txa:tay
    38 				;		bcc :+
    39 						    lda T1
    40 						    sta sm1+1
    41 						    sta sm3+1
    42 						    eor #$ff
    43 						    sta sm2+1
    44 						    sta sm4+1
    45
    46 						ldx T2
    47 						sec
    48 8A5E			sm1:		lda square1_lo,x
    49 8A5E			sm2:		sbc square2_lo,x
    50 						sta PRODUCT+0
    51 8A5E			sm3:		lda square1_hi,x
    52 8A5E			sm4:		sbc square2_hi,x
    53
    54 						sta PRODUCT+1
    55
    56 					tya:tax
    57 						rts
    58 				.endp
    59
    60
    61 				/*
    62
    63 				 8 bit multiply and divide routines.
    64 				 Three 8 bit locations
    65 				 ACC, AUX and EXT must be set up,
    66 				 preferably on zero page.
    67
    68 				 MULTIPLY ROUTINE
    69
    70 				 EAX*ECX -> EAX (low,hi) 16 bit result
    71
    72 				*/
    72
    73
    74 8A5E			.proc	imulCL
    75
    76 8A5E A9 00			lda #$00
    77
    78 8A60 A0 09			LDY #$09
    79 8A62 18				CLC
    80 8A63 6A			LOOP	ROR @
    81 8A64 66 C2			ROR eax
    82 8A66 90 03			BCC MUL2
    83 8A68 18				CLC		;DEC AUX above to remove CLC
    84 8A69 65 CA			ADC ecx
    85 8A6B 88			MUL2	DEY
    86 8A6C D0 F5			BNE LOOP
    87
    88 8A6E 85 C3			STA eax+1
    89
    90 8A70 60				RTS
    91 				.endp
    92
    93
    94 8A71			.proc	imulBYTE
    95
    96 					mva :STACKORIGIN,x ecx
    97 					mva :STACKORIGIN-1,x eax
    98
    99 					lda #$00
   100
   101 					sta eax+2
   102 					sta eax+3
   103
   104 					.ifdef fmulinit
   105 					jmp fmulu_8
   106 					els
   107 					jmp imulCL
   108 					eif
   109
   110 				.endp
   111
   112
   113 				.define	jsr_imodBYTE jsr idivBYTE
   114
   115 8A71			.proc	idivBYTE
   116
   117 					mva :STACKORIGIN,x ecx
   118 					mva :STACKORIGIN-1,x eax
   119
   120 					jmp idivAL_CL
   121 				.endp
   122
   123
   124 				; DIVIDE ROUTINE (8 BIT)
   125 				; AL/CL -> ACC, remainder in ZTMP
   126
   127 8A71			.proc idivAL_CL
   128
   129 				;	mva :STACKORIGIN,x cl
   130 				;	mva :STACKORIGIN-1,x al
   131
   132 					lda #$00
   133
   134 					sta eax+1
   135 					sta eax+2
   136 					sta eax+3
   137
   138 					STA ztmp+1
   139 					STA ztmp+2
   140 					STA ztmp+3
   141
   142 					LDY #$08
   143 8A71			LOOP	ASL AL
   144 					ROL @
   145 					CMP CL
   146 					BCC DIV2
   147 					SBC CL
   148 					INC AL
   149 8A71			DIV2
   150 					DEY
   151 					BNE LOOP
   152
   153 					STA ZTMP
   154
   155 					rts
   156 				.endp
   157
  1266 8A71				icl '6502\cpu6502_word.asm'		; mul / div -> WORD
Source: cpu6502_word.asm
     1
     2 				/*
     3 					fmulu_16
     4 					imulCX
     5 					imulWORD
     6 					idivWORD
     7 					idivAX_CX
     8 				*/
     8
     9
    10 				; Description: Unsigned 16-bit multiplication with unsigned 32-bit result.
    11 				;
    12 				; Input: 16-bit unsigned value in T1
    13 				;	 16-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 32-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 				//.proc multiply_16bit_unsigned
    31 						; <T1 * <T2 = AAaa
    32 						; <T1 * >T2 = BBbb
    33 						; >T1 * <T2 = CCcc
    34 						; >T1 * >T2 = DDdd
    35 						;
    36 						;	AAaa
    37 						;     BBbb
    38 						;     CCcc
    39 						; + DDdd
    40 						; ----------
    41 						;   PRODUCT!
    42
    43 						; Setup T1 if changed
    44 8A71			.proc	fmulu_16
    45
    46 = 00C2			t1	= eax
    47 = 00CA			t2	= ecx
    48
    49 = 00C2			product	= eax
    50
    51 					txa:pha
    52 				;		bcc @+
    53 						    lda T1+0
    54 						    sta sm1a+1
    55 						    sta sm3a+1
    56 						    sta sm5a+1
    57 						    sta sm7a+1
    58 						    eor #$ff
    59 						    sta sm2a+1
    60 						    sta sm4a+1
    61 						    sta sm6a+1
    62 						    sta sm8a+1
    63 						    lda T1+1
    64 						    sta sm1b+1
    65 						    sta sm3b+1
    66 						    sta sm5b+1
    67 						    sta sm7b+1
    68 						    eor #$ff
    69 						    sta sm2b+1
    70 						    sta sm4b+1
    71 						    sta sm6b+1
    72 						    sta sm8b+1
    73 				;@
    74 						; Perform <T1 * <T2 = AAaa
    75 						ldx T2+0
    76 						sec
    77 8A71			sm1a:		lda square1_lo,x
    78 8A71			sm2a:		sbc square2_lo,x
    79 						sta PRODUCT+0
    80 8A71			sm3a:		lda square1_hi,x
    81 8A71			sm4a:		sbc square2_hi,x
    82 						;sta _AA+1
    83 						tay
    84
    85 						; Perform >T1_hi * <T2 = CCcc
    86 						sec
    87 8A71			sm1b:		lda square1_lo,x
    88 8A71			sm2b:		sbc square2_lo,x
    89 						sta _cc+1
    90 8A71			sm3b:		lda square1_hi,x
    91 8A71			sm4b:		sbc square2_hi,x
    92 						sta _CC_+1
    93
    94 						; Perform <T1 * >T2 = BBbb
    95 						ldx T2+1
    96 						sec
    97 8A71			sm5a:		lda square1_lo,x
    98 8A71			sm6a:		sbc square2_lo,x
    99 						sta _bb+1
   100 8A71			sm7a:		lda square1_hi,x
   101 8A71			sm8a:		sbc square2_hi,x
   102 						sta _BB_+1
   103
   104 						; Perform >T1 * >T2 = DDdd
   105 						sec
   106 8A71			sm5b:		lda square1_lo,x
   107 8A71			sm6b:		sbc square2_lo,x
   108 						sta _dd+1
   109 8A71			sm7b:		lda square1_hi,x
   110 8A71			sm8b:		sbc square2_hi,x
   111 				;		sta PRODUCT+3
   112 						tax
   113
   114 						; Add the separate multiplications together
   115 						clc
   116 				;_AA:		lda #0
   117 						tya
   118 8A71			_bb:		adc #0
   119 				;		sta PRODUCT+1
   120 						tay
   121 8A71			_BB_:		lda #0
   122 8A71			_CC_:		adc #0
   123 						sta PRODUCT+2
   124 						bcc @+
   125 				;		    inc PRODUCT+3
   126 						inx
   127 						    clc
   128 8A71			@
   129 						tya
   130 8A71			_cc:		adc #0
   131 				;		adc PRODUCT+1
   132 						sta PRODUCT+1
   133 8A71			_dd:		lda #0
   134 						adc PRODUCT+2
   135 						sta PRODUCT+2
   136 						scc
   137 				;		    inc PRODUCT+3
   138 						inx
   139
   140 					stx PRODUCT+3
   141
   142 					pla:tax
   143
   144 					rts
   145 				.endp
   146
   147
   148 				/*
   149
   150 				 16 bit multiply and divide routines.
   151 				 Three 16 bit (two-byte) locations
   152 				 ACC, AUX and EXT must be set up,
   153 				 preferably on zero page.
   154
   155 				 MULTIPLY ROUTINE
   156
   157 				 EAX*ECX -> EAX (low,hi) 32 bit result
   158
   159 				*/
   159
   160
   161 8A71			.proc	imulCX
   162
   163 					lda #$00
   164 					sta eax+3
   165
   166 					LDY #$11			; A = 0 !
   167 					CLC
   168 8A71			LOOP	ROR eax+3
   169 					ROR @
   170 					ROR eax+1
   171 					ROR eax
   172 					BCC MUL2
   173 					CLC
   174 					ADC ecx
   175 					PHA
   176 					LDA ecx+1
   177 					ADC eax+3
   178 					STA eax+3
   179 					PLA
   180 8A71			MUL2	DEY
   181 					BNE LOOP
   182
   183 					STA eax+2
   184
   185 					rts
   186 				.endp
   187
   188
   189 8A71			.proc	imulWORD
   190
   191 					mva :STACKORIGIN,x ecx
   192 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   193
   194 					mva :STACKORIGIN-1,x eax
   195 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   196
   197 					.ifdef fmulinit
   198 					jmp fmulu_16
   199 					els
   200 					jmp imulCX
   201 					eif
   202 				.endp
   203
   204
   205 				.define	jsr_imodWORD jsr idivWORD
   206
   207 8A71			.proc	idivWORD
   208
   209 					mva :STACKORIGIN,x ecx
   210 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   211
   212 					mva :STACKORIGIN-1,x eax
   213 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   214
   215 					jmp idivAX_CX
   216 				.endp
   217
   218
   219 				; DIVIDE ROUTINE (16 BIT)
   220 				; AX/CX -> ACC, remainder in ZTMP
   221
   222 8A71			.proc	idivAX_CX
   223
   224 				;	jsr iniEAX_ECX_WORD
   225 8A71			main
   226 					LDA #0
   227 					STA ztmp+1
   228 					STA ztmp+2
   229 					STA ztmp+3
   230
   231 					sta eax+2
   232 					sta eax+3
   233
   234 					.ifdef fmulinit
   235 					.rept 16
   236 					ASL ax
   237 					ROL ax+1
   238 					ROL @
   239 					ROL ztmp+1
   240 					tay
   241 					CMP cx
   242 					LDA ztmp+1
   243 					SBC cx+1
   244 					BCC @+
   245 					STA ztmp+1
   246 					tya
   247 					SBC cx
   248 					tay
   249 					INC ax
   250 				@	tya
   251 					.endr
   252
   253 					els
   254 					LDY #$10
   255
   256 8A71			LOOP	ASL ax
   257 					ROL ax+1
   258 					ROL @
   259 					ROL ztmp+1
   260 					sta edx
   261 					CMP cx
   262 					LDA ztmp+1
   263 					SBC cx+1
   264 					BCC DIV2
   265 					STA ztmp+1
   266 					lda edx
   267 					SBC cx
   268 					sta edx
   269 					INC ax
   270 8A71			DIV2	lda edx
   271 					DEY
   272 					BNE LOOP
   273 					eif
   274
   275 					STA ztmp
   276
   277 					rts
   278 				.endp
   279
  1267 8A71				icl '6502\cpu6502_cardinal.asm'		; mul / div -> CARDINAL
Source: cpu6502_cardinal.asm
     1
     2 				/*
     3 					imulECX
     4 					imulCARD
     5 					idivCARD
     6 					idivEAX_ECX
     7 				*/
     7
     8
     9 				; *** MUL32: 32-bit multiply
    10 				; EAX * ECX -> ZTMP8-ZTMP11
    11 8A71			.proc	imulECX
    12
    13 					lda #0
    14 					sta ZTMP10
    15 					sta ZTMP9
    16 					sta ZTMP8
    17
    18 					ldy #32
    19 8A71			MUL320	lsr ZTMP10
    20 					ror ZTMP9
    21 					ror ZTMP8
    22 					ror @
    23 					ror eax+3
    24 					ror eax+2
    25 					ror eax+1
    26 					ror eax
    27 					bcc MUL321
    28 					clc
    29 					adc ecx
    30 					pha
    31 					lda ecx+1
    32 					adc ZTMP8
    33 					sta ZTMP8
    34 					lda ecx+2
    35 					adc ZTMP9
    36 					sta ZTMP9
    37 					lda ecx+3
    38 					adc ZTMP10
    39 					sta ZTMP10
    40 					pla
    41 8A71			MUL321	dey
    42 				       	bpl MUL320
    43
    44 					rts
    45 				.endp
    46
    47
    48 8A71			.proc	imulCARD
    49
    50 					jsr iniEAX_ECX_CARD
    51
    52 					jmp imulECX
    53 				.endp
    54
    55
    56 				.define	jsr_imodCARD jsr idivCARD
    57
    58 8A71			.proc	idivCARD
    59
    60 					jsr iniEAX_ECX_CARD
    61
    62 					jmp idivEAX_ECX.CARD
    63 				.endp
    64
    65
    66 				; *** UDIV32: 32-bit unsigned division
    67 				; input: dividend at ZTMP0-ZTMP3
    68 				;        divisor at ZTMP4-ZTMP7
    69 				; output: result at ZTMP0-ZTMP3
    70 				;         remainder at ZTMP8-ZTMP11
    71 				; X,Y preserved
    72
    73 8A71			.proc	idivEAX_ECX
    74
    75 8A71			REAL	mva :STACKORIGIN-1+STACKWIDTH*2,x :STACKORIGIN-1+STACKWIDTH*3,x
    76 					mva :STACKORIGIN-1+STACKWIDTH,x :STACKORIGIN-1+STACKWIDTH*2,x
    77 					mva :STACKORIGIN-1,x :STACKORIGIN-1+STACKWIDTH,x
    78 					mva #$00 :STACKORIGIN-1,x
    79
    80 8A71			CARD	;jsr iniEAX_ECX_CARD
    81
    82 8A71			MAIN	LDA #0
    83 					STA ZTMP8
    84 					STA ZTMP9
    85 					STA ZTMP10
    86 					STA ZTMP11
    87
    88 					LDY #32
    89 8A71			UDIV320	ASL eax
    90 					ROL eax+1
    91 					ROL eax+2
    92 					ROL eax+3
    93 					ROL ZTMP8
    94 					ROL ZTMP9
    95 					ROL ZTMP10
    96 					ROL ZTMP11
    97 							;do a subtraction
    98 					LDA ZTMP8
    99 					CMP ecx
   100 					LDA ZTMP9
   101 					SBC ecx+1
   102 					LDA ZTMP10
   103 					SBC ecx+2
   104 					LDA ZTMP11
   105 					SBC ecx+3
   106 					BCC UDIV321
   107 				 			;overflow, do the subtraction again, this time store the result
   108 					STA ecx+3	;we have the high byte already
   109 					LDA ZTMP8
   110 					SBC ecx		;byte 0
   111 					STA ZTMP8
   112 					LDA ZTMP9
   113 					SBC ecx+1
   114 					STA ZTMP9	;byte 1
   115 					LDA ZTMP10
   116 					SBC ecx+2
   117 					STA ZTMP10	;byte 2
   118 					INC eax		;set result bit
   119
   120 8A71			UDIV321	DEY
   121 					BNE UDIV320
   122
   123 					rts
   124 				.endp
   125
  1268
  1269 8A71				icl '6502\cpu6502_shortreal.asm'	; mul / div -> SHORTREAL	Q8.8
Source: cpu6502_shortreal.asm
     1 				; SHORTREAL	fixed-point Q8.8, 16bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulSHORTREAL
     6 					divSHORTREAL
     7 				*/
     7
     8
     9
    10 8A71			.proc	mulSHORTREAL
    11
    12 					jsr imulWORD
    13
    14 					mva #0 eax+3
    15 					mva eax+1 eax
    16 					mva eax+2 eax+1
    17
    18 					ldy eax+3
    19
    20 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    21 					bpl @+
    22 					sec
    23 					lda eax+1
    24 					sbc :STACKORIGIN,x
    25 					sta eax+1
    26 					tya
    27 					sbc :STACKORIGIN+STACKWIDTH,x
    28 					tay
    29 8A71			@
    30 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    31 					bpl @+
    32 					sec
    33 					lda eax+1
    34 					sbc :STACKORIGIN-1,x
    35 					sta eax+1
    36 					tya
    37 					sbc :STACKORIGIN-1+STACKWIDTH,x
    38 					tay
    39 8A71			@
    40 					sty eax+2
    41
    42 					jmp movaBX_EAX
    43 				.endp
    44
    45
    46
    47 8A71			.proc	divSHORTREAL
    48 					jsr iniEAX_ECX_WORD
    49
    50 					mva eax+1 eax+2
    51 					mva eax eax+1
    52 					lda #0
    53 					sta eax
    54 					sta eax+3
    55 					sta ecx+3
    56
    57 					jmp idivEAX_ECX.main
    58 				.endp
  1270 8A71				icl '6502\cpu6502_real.asm'		; mul / div -> REAL		Q24.8
Source: cpu6502_real.asm
     1 				; REAL	fixed-point Q24.8, 32bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulREAL
     6 					divREAL
     7 				*/
     7
     8
     9
    10 8A71			.proc	mulREAl
    11
    12 				;	jsr iniEAX_ECX_CARD
    13
    14 					mva :STACKORIGIN,x ecx0
    15 					mva :STACKORIGIN+STACKWIDTH,x ecx1
    16 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
    17 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
    18
    19 					mva :STACKORIGIN-1,x eax
    20 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
    21 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
    22 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
    23
    24 				;	jsr imul64				; imul ecx 64 bit
    25
    26 					lda #$00
    27 					sta edx		;Clear upper half of
    28 					sta edx+1	;product
    29 					sta edx+2
    30 					sta edx+3
    31
    32 					sta ztmp8
    33 					sta ztmp9
    34 					sta ztmp10
    35 					sta ztmp11
    36
    37 					ldy #$20	;Set binary count to 32
    38 8A71			SHIFT_R	lsr eax+3	;Shift multiplyer right
    39 					ror eax+2
    40 					ror eax+1
    41 					ror eax
    42 					bcc ROTATE_R	;Go rotate right if c = 0
    43 					lda edx		;Get upper half of product
    44 					clc		;and add multiplicand to
    45 					adc #0		;it
    46 8A71			ecx0	equ *-1
    47 					sta edx
    48 					lda edx+1
    49 					adc #0
    50 8A71			ecx1	equ *-1
    51 					sta edx+1
    52 					lda edx+2
    53 					adc #0
    54 8A71			ecx2	equ *-1
    55 					sta edx+2
    56 					lda edx+3
    57 					adc #0
    58 8A71			ecx3	equ *-1
    59 8A71			ROTATE_R  ror @		;Rotate partial product
    60 				        sta edx+3	;right
    61 				        ror edx+2
    62 				        ror edx+1
    63 				        ror edx
    64 				        ror ztmp11
    65 				        ror ztmp10
    66 				        ror ztmp9
    67 				        ror ztmp8
    68 				        dey		;Decrement bit count and
    69 				        bne SHIFT_R	;loop until 32 bits are
    70
    71 				;	mva ztmp8 eax
    72 					mva ztmp9 eax
    73 					mva ztmp10 eax+1
    74 					mva ztmp11 eax+2
    75
    76
    77 				;	mva eax+1 eax
    78 				;	mva eax+2 eax+1
    79 				;	mva eax+3 eax+2
    80
    81 					ldy edx
    82
    83 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; t1
    84 					bpl @+
    85 					sec
    86 					tya
    87 					sbc :STACKORIGIN,x
    88 					tay
    89 8A71			@
    90 					lda :STACKORIGIN+STACKWIDTH*3,x		; t2
    91 					bpl @+
    92 					sec
    93 					tya
    94 					sbc :STACKORIGIN-1,x
    95 					tay
    96 8A71			@
    97 					sty eax+3
    98
    99 					jmp movaBX_EAX
   100 				.endp
   101
   102
   103 				/*
   104 				;32 bit multiply with 64 bit product
   105
   106 				.proc	imul64
   107
   108 					lda #$00
   109 					sta edx		;Clear upper half of
   110 					sta edx+1	;product
   111 					sta edx+2
   112 					sta edx+3
   113
   114 					sta ztmp8
   115 					sta ztmp9
   116 					sta ztmp10
   117 					sta ztmp11
   118
   119 					ldy #$20	;Set binary count to 32
   120 				SHIFT_R	lsr eax+3	;Shift multiplyer right
   121 					ror eax+2
   122 					ror eax+1
   123 					ror eax
   124 					bcc ROTATE_R	;Go rotate right if c = 0
   125 					lda edx		;Get upper half of product
   126 					clc		;and add multiplicand to
   127 					adc ecx		;it
   128 					sta edx
   129 					lda edx+1
   130 					adc ecx+1
   131 					sta edx+1
   132 					lda edx+2
   133 					adc ecx+2
   134 					sta edx+2
   135 					lda edx+3
   136 					adc ecx+3
   137 				ROTATE_R  ror @		;Rotate partial product
   138 				        sta edx+3	;right
   139 				        ror edx+2
   140 				        ror edx+1
   141 				        ror edx
   142 				        ror ztmp11
   143 				        ror ztmp10
   144 				        ror ztmp9
   145 				        ror ztmp8
   146 				        dey		;Decrement bit count and
   147 				        bne SHIFT_R	;loop until 32 bits are
   148
   149 					mva ztmp8 eax
   150 					mva ztmp9 eax+1
   151 					mva ztmp10 eax+2
   152 					mva ztmp11 eax+3
   153
   154 					rts
   155 				.endp
   156 				*/
   156
   157
   158 				; 64bit / 32bit = 32bit
   159 				; eax = eax + edx
   160
   161 8A71			.proc	divREAL
   162
   163 					mva :STACKORIGIN,x ecx0
   164 					sta ecx0_
   165 					mva :STACKORIGIN+STACKWIDTH,x ecx1
   166 					sta ecx1_
   167 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
   168 					sta ecx2_
   169 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
   170
   171 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+4
   172 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+3
   173 					mva :STACKORIGIN-1+STACKWIDTH,x eax+2
   174 					mva :STACKORIGIN-1,x eax+1
   175
   176 					lda #$00
   177 					sta eax
   178 					sta eax+5
   179 					sta eax+6
   180 					sta eax+7
   181
   182 					STA ZTMP8
   183 					STA ZTMP9
   184 					STA ZTMP10
   185 					STA ZTMP11
   186
   187 					LDY #64
   188 8A71			UDIV320	ASL eax
   189 					ROL eax+1
   190 					ROL eax+2
   191 					ROL eax+3
   192 					ROL eax+4
   193 					ROL eax+5
   194 					ROL eax+6
   195 					ROL eax+7
   196
   197 					ROL ZTMP8
   198 					ROL ZTMP9
   199 					ROL ZTMP10
   200 					ROL ZTMP11
   201 							;do a subtraction
   202 					LDA ZTMP8
   203 					CMP #0
   204 8A71			ecx0	equ *-1
   205 					LDA ZTMP9
   206 					SBC #0
   207 8A71			ecx1	equ *-1
   208 					LDA ZTMP10
   209 					SBC #0
   210 8A71			ecx2	equ *-1
   211 					LDA ZTMP11
   212 					SBC #0
   213 8A71			ecx3	equ *-1
   214 					BCC UDIV321
   215 				 			;overflow, do the subtraction again, this time store the result
   216 					STA ecx3	;we have the high byte already
   217 					LDA ZTMP8
   218 					SBC #0		;byte 0
   219 8A71			ecx0_	equ *-1
   220 					STA ZTMP8
   221 					LDA ZTMP9
   222 					SBC #0
   223 8A71			ecx1_	equ *-1
   224 					STA ZTMP9	;byte 1
   225 					LDA ZTMP10
   226 					SBC #0
   227 8A71			ecx2_	equ *-1
   228 					STA ZTMP10	;byte 2
   229
   230 					INC eax		;set result bit
   231
   232 8A71			UDIV321	DEY
   233 					BNE UDIV320
   234
   235 					rts
   236 				.endp
   237
   238
   239 				/*
   240 				.proc	divREAL
   241
   242 					jsr iniEAX_ECX_CARD
   243
   244 					mva eax+3 eax+4
   245 					mva eax+2 eax+3
   246 					mva eax+1 eax+2
   247 					mva eax eax+1
   248
   249 					lda #$00
   250 					sta eax
   251 					sta eax+5
   252 					sta eax+6
   253 					sta eax+7
   254
   255 					STA ZTMP8
   256 					STA ZTMP9
   257 					STA ZTMP10
   258 					STA ZTMP11
   259
   260 					LDY #64
   261 				UDIV320	ASL eax
   262 					ROL eax+1
   263 					ROL eax+2
   264 					ROL eax+3
   265 					ROL eax+4
   266 					ROL eax+5
   267 					ROL eax+6
   268 					ROL eax+7
   269
   270 					ROL ZTMP8
   271 					ROL ZTMP9
   272 					ROL ZTMP10
   273 					ROL ZTMP11
   274 							;do a subtraction
   275 					LDA ZTMP8
   276 					CMP ecx
   277 					LDA ZTMP9
   278 					SBC ecx+1
   279 					LDA ZTMP10
   280 					SBC ecx+2
   281 					LDA ZTMP11
   282 					SBC ecx+3
   283 					BCC UDIV321
   284 				 			;overflow, do the subtraction again, this time store the result
   285 					STA ecx+3	;we have the high byte already
   286 					LDA ZTMP8
   287 					SBC ecx		;byte 0
   288 					STA ZTMP8
   289 					LDA ZTMP9
   290 					SBC ecx+1
   291 					STA ZTMP9	;byte 1
   292 					LDA ZTMP10
   293 					SBC ecx+2
   294 					STA ZTMP10	;byte 2
   295
   296 					INC eax		;set result bit
   297
   298 				UDIV321	DEY
   299 					BNE UDIV320
   300
   301 					rts
   302 				.endp
   303 				*/
   303
  1271 8A71				icl '6502\cpu6502_single.asm'		; mul / div -> SINGLE		IEEE-754
Source: cpu6502_single.asm
     1 				; JAVA IEEE-32 (IEEE-754)
     2 				; David Schmenk
     3 				; https://sourceforge.net/projects/vm02/
     4 				; http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/src/
     5
     6 				/*
     7 					org eax
     8
     9 				FP1MAN0	.ds 1
    10 				FP1MAN1	.ds 1
    11 				FP1MAN2	.ds 1
    12 				FP1MAN3	.ds 1
    13
    14 					org ztmp8
    15
    16 				FP1SGN	.ds 1
    17 				FP1EXP	.ds 1
    18
    19 					org edx
    20
    21 				FP2MAN0	.ds 1
    22 				FP2MAN1	.ds 1
    23 				FP2MAN2	.ds 1
    24 				FP2MAN3	.ds 1
    25
    26 					org ztmp10
    27
    28 				FP2SGN	.ds 1
    29 				FP2EXP	.ds 1
    30
    31 					org ecx
    32
    33 				FPMAN0	.ds 1
    34 				FPMAN1	.ds 1
    35 				FPMAN2	.ds 1
    36 				FPMAN3	.ds 1
    37
    38 					org bp2
    39
    40 				FPSGN	.ds 1
    41 				FPEXP	.ds 1
    42
    43 				*/
    43
    44
    45 = 00CF			@rx	= bp+1
    46
    47 = 000A			MIN_EXPONENT	= 10
    48 = 00FF			MAX_EXPONENT	= 255
    49
    50
    51 8A71			.proc	NEGINT
    52
    53 					LDA	#$00
    54 					SEC
    55
    56 8A71			enter	SBC	FPMAN0
    57 					STA	FPMAN0
    58 					LDA	#$00
    59 					SBC	FPMAN1
    60 					STA	FPMAN1
    61 					LDA	#$00
    62 					SBC	FPMAN2
    63 					STA	FPMAN2
    64 					LDA	#$00
    65 					SBC	FPMAN3
    66 					STA	FPMAN3
    67 					RTS
    68 				.endp
    69
    70
    71 8A71			.proc	FFRAC
    72 					inx
    73 					lda :STACKORIGIN-1,x
    74 					sta :STACKORIGIN,x
    75
    76 					lda :STACKORIGIN-1+STACKWIDTH,x
    77 					sta :STACKORIGIN+STACKWIDTH,x
    78
    79 					lda :STACKORIGIN-1+STACKWIDTH*2,x
    80 					sta :STACKORIGIN+STACKWIDTH*2,x
    81
    82 					lda :STACKORIGIN-1+STACKWIDTH*3,x
    83 					eor #$80
    84 					sta :STACKORIGIN+STACKWIDTH*3,x
    85
    86 					dex
    87
    88 					jsr F2I
    89 					jsr I2F
    90
    91 					lda :STACKORIGIN+STACKWIDTH*3,x
    92 					eor #$80
    93 					sta :STACKORIGIN+STACKWIDTH*3,x
    94
    95 					inx
    96
    97 					jsr FSUB
    98
    99 					dex
   100
   101 					rts
   102 				.endp
   103
   104
   105 8A71			.proc	FROUND
   106 				;	LDA	#$00
   107 				;	STA	FP2SGN
   108
   109 					lda :STACKORIGIN,x
   110 					STA	FP2MAN0
   111 					lda :STACKORIGIN+STACKWIDTH,x
   112 					STA	FP2MAN1
   113 					lda :STACKORIGIN+STACKWIDTH*2,x
   114 					CMP	#$80		; SET CARRY FROM MSB
   115 					ORA	#$80		; SET HIDDEN BIT
   116 					STA	FP2MAN2
   117 					lda :STACKORIGIN+STACKWIDTH*3,x
   118 				;	EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   119 					ROL
   120 					STA	FP2EXP
   121 					LDA	#$00
   122 					STA	FPSGN
   123 					BCC	@+
   124 					SBC	FP2MAN0
   125 					STA	FP2MAN0
   126 					LDA	#$00
   127 					SBC	FP2MAN1
   128 					STA	FP2MAN1
   129 					LDA	#$00
   130 					SBC	FP2MAN2
   131 					STA	FP2MAN2
   132 					LDA	#$FF
   133 8A71			@	STA	FP2MAN3
   134 					lda #$00
   135 					STA	FP1MAN0
   136 					STA	FP1MAN1
   137 					CMP	#$80		; SET CARRY FROM MSB
   138 					ORA	#$80		; SET HIDDEN BIT
   139 					STA	FP1MAN2
   140
   141 					lda :STACKORIGIN+STACKWIDTH*3,x
   142 					and #$80
   143 					ora #$3f		; 0.5 / -0.5
   144
   145 					inx
   146
   147 					jsr FSUB.enter
   148
   149 					dex
   150
   151 					rts
   152 				.endp
   153
   154
   155 8A71			.proc	FSUB
   156 					LDA	#$80		; TOGGLE SIGN
   157 					BNE	@+
   158 8A71			FADD:	LDA	#$00
   159 8A71			@	STA	FP2SGN
   160 				;	stx @rx
   161
   162 					lda :STACKORIGIN,x
   163 					STA	FP2MAN0
   164 					lda :STACKORIGIN+STACKWIDTH,x
   165 					STA	FP2MAN1
   166 					lda :STACKORIGIN+STACKWIDTH*2,x
   167 					CMP	#$80		; SET CARRY FROM MSB
   168 					ORA	#$80		; SET HIDDEN BIT
   169 					STA	FP2MAN2
   170 					lda :STACKORIGIN+STACKWIDTH*3,x
   171 					EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   172 					ROL
   173 					STA	FP2EXP
   174 					LDA	#$00
   175 					STA	FPSGN
   176 					BCC	@+
   177 					SBC	FP2MAN0
   178 					STA	FP2MAN0
   179 					LDA	#$00
   180 					SBC	FP2MAN1
   181 					STA	FP2MAN1
   182 					LDA	#$00
   183 					SBC	FP2MAN2
   184 					STA	FP2MAN2
   185 					LDA	#$FF
   186 8A71			@	STA	FP2MAN3
   187 					lda :STACKORIGIN-1,x
   188 					STA	FP1MAN0
   189 					lda :STACKORIGIN-1+STACKWIDTH,x
   190 					STA	FP1MAN1
   191 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   192 					CMP	#$80		; SET CARRY FROM MSB
   193 					ORA	#$80		; SET HIDDEN BIT
   194 					STA	FP1MAN2
   195 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   196 8A71			enter	ROL
   197 					STA	FP1EXP
   198 					LDA	#$00
   199 					BCC	@+
   200 					SBC	FP1MAN0
   201 					STA	FP1MAN0
   202 					LDA	#$00
   203 					SBC	FP1MAN1
   204 					STA	FP1MAN1
   205 					LDA	#$00
   206 					SBC	FP1MAN2
   207 					STA	FP1MAN2
   208 					LDA	#$FF
   209 8A71			@	STA	FP1MAN3
   210 					LDA	FP1EXP		; CALCULATE WHICH MANTISSA TO SHIFT
   211 					STA	FPEXP
   212 					SEC
   213 					SBC	FP2EXP
   214 					BEQ	FADDMAN
   215 					BCS	@+
   216 					EOR	#$FF
   217 					TAY
   218 					INY
   219 					LDA	FP2EXP
   220 					STA	FPEXP
   221 					LDA	FP1MAN3
   222 					CPY	#24		; KEEP SHIFT RANGE VALID
   223 					BCC	FP1SHFT
   224 					LDA	#$00
   225 					STA	FP1MAN3
   226 					STA	FP1MAN2
   227 					STA	FP1MAN1
   228 					STA	FP1MAN0
   229 					BEQ	FADDMAN
   230 8A71			FP1SHFT:	CMP	#$80	; SHIFT FP1 DOWN
   231 					ROR
   232 					ROR	FP1MAN2
   233 					ROR	FP1MAN1
   234 					ROR	FP1MAN0
   235 					DEY
   236 					BNE	FP1SHFT
   237 					STA	FP1MAN3
   238 					JMP	FADDMAN
   239
   240 8A71			@	TAY
   241 					LDA	FP2MAN3
   242 					CPY	#24		; KEEP SHIFT RANGE VALID
   243 					BCC	FP2SHFT
   244 					LDA	#$00
   245 					STA	FP2MAN3
   246 					STA	FP2MAN2
   247 					STA	FP2MAN1
   248 					STA	FP2MAN0
   249 					BEQ	FADDMAN
   250 8A71			FP2SHFT:	CMP	#$80	; SHIFT FP2 DOWN
   251 					ROR
   252 					ROR	FP2MAN2
   253 					ROR	FP2MAN1
   254 					ROR	FP2MAN0
   255 					DEY
   256 					BNE	FP2SHFT
   257 					STA	FP2MAN3
   258 8A71			FADDMAN:	LDA	FP1MAN0
   259 					CLC
   260 					ADC	FP2MAN0
   261 					STA	FPMAN0
   262 					LDA	FP1MAN1
   263 					ADC	FP2MAN1
   264 					STA	FPMAN1
   265 					LDA	FP1MAN2
   266 					ADC	FP2MAN2
   267 					STA	FPMAN2
   268 					LDA	FP1MAN3
   269 					ADC	FP2MAN3
   270 					STA	FPMAN3
   271 					BPL	FPNORM
   272
   273 					LDA	#$80
   274 					STA	FPSGN
   275
   276 					JSR	NEGINT
   277
   278 					jmp FPNORM
   279 				.endp
   280
   281
   282 8A71			.proc	FPNORM
   283 					BEQ	FPNORMLEFT	; NORMALIZE FP, A = FPMANT3
   284 8A71			FPNORMRIGHT:	INC	FPEXP
   285 					LSR
   286 					STA	FPMAN3
   287 					ROR	FPMAN2
   288 					ROR	FPMAN1
   289 					LDA	FPMAN0
   290 					ROR
   291 					ADC	#$00
   292 					STA	FPMAN0
   293 					LDA	FPMAN1
   294 					ADC	#$00
   295 					STA	FPMAN1
   296 					LDA	FPMAN2
   297 					ADC	#$00
   298 					STA	FPMAN2
   299 					LDA	FPMAN3
   300 					ADC	#$00
   301 					BNE	FPNORMRIGHT
   302 					LDA	FPEXP
   303 					ASL	FPMAN2
   304 					LSR
   305 					ORA	FPSGN
   306
   307 				;	ldx @rx
   308 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   309 					LDA	FPMAN2
   310 					ROR
   311 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   312
   313 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   314 					asl @
   315 					tay
   316 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   317 					spl
   318 					iny
   319 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   320 					bcc zero
   321 					cpy #MAX_EXPONENT
   322 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   323
   324 					LDA	FPMAN1
   325 					sta :STACKORIGIN-1+STACKWIDTH,x
   326 					LDA	FPMAN0
   327 					sta :STACKORIGIN-1,x
   328 					rts
   329
   330 8A71			FPNORMLEFT:	LDA	FPMAN2
   331 					BNE	FPNORMLEFT1
   332 					LDA	FPMAN1
   333 					BNE	FPNORMLEFT8
   334 					LDA	FPMAN0
   335 					BNE	FPNORMLEFT16
   336
   337 				;	ldx @rx			; RESULT IS ZERO
   338 8A71			zero	lda #0
   339
   340 					sta :STACKORIGIN-1,x
   341 					sta :STACKORIGIN-1+STACKWIDTH,x
   342 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   343 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   344 					rts
   345
   346 8A71			FPNORMLEFT16:	TAY
   347 					LDA	FPEXP
   348 					SEC
   349 					SBC	#$10
   350 					STA	FPEXP
   351 					LDA	#$00
   352 					STA	FPMAN1
   353 					STA	FPMAN0
   354 					TYA
   355 					BNE	FPNORMLEFT1
   356 8A71			FPNORMLEFT8:	TAY
   357 					LDA	FPMAN0
   358 					STA	FPMAN1
   359 					LDA	FPEXP
   360 					SEC
   361 					SBC	#$08
   362 					STA	FPEXP
   363 					LDA	#$00
   364 					STA	FPMAN0
   365 					TYA
   366 8A71			FPNORMLEFT1:	BMI	FPNORMDONE
   367 8A71			@	DEC	FPEXP
   368 					ASL	FPMAN0
   369 					ROL	FPMAN1
   370 					ROL
   371 					BPL	@-
   372 8A71			FPNORMDONE:	ASL
   373 					TAY
   374 					LDA	FPEXP
   375 					LSR
   376 					ORA	FPSGN
   377
   378 				;	ldx @rx
   379 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   380 					TYA
   381 					ROR
   382 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   383
   384 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   385 					asl @
   386 					tay
   387 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   388 					spl
   389 					iny
   390 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   391 					bcc zero
   392 					cpy #MAX_EXPONENT
   393 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   394
   395 					LDA	FPMAN1
   396 					sta :STACKORIGIN-1+STACKWIDTH,x
   397 					LDA	FPMAN0
   398 					sta :STACKORIGIN-1,x
   399
   400 					rts
   401 				.endp
   402
   403
   404 8A71			.proc	FMUL
   405
   406 					stx @rx
   407
   408 					lda :STACKORIGIN,x
   409 					STA	FP2MAN0
   410 					lda :STACKORIGIN+STACKWIDTH,x
   411 					STA	FP2MAN1
   412 					lda :STACKORIGIN+STACKWIDTH*2,x
   413 					CMP	#$80		; SET CARRY FROM MSB
   414 					ORA	#$80		; SET HIDDEN BIT
   415 					STA	FP2MAN2
   416 				 	lda :STACKORIGIN+STACKWIDTH*3,x
   417 					ROL
   418 					STA	FP2EXP
   419 					BNE	@+
   420
   421 				; MUL BY ZERO, RESULT ZERO
   422 				;	LDA	#$00
   423 8A71			ZERO:	STA :STACKORIGIN-1,x
   424 					STA :STACKORIGIN-1+STACKWIDTH,x
   425 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   426 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   427 					rts
   428
   429 8A71			@	LDA	#$00
   430 					ROR
   431 					STA	FPSGN
   432 					lda :STACKORIGIN-1,x
   433 					STA	FP1MAN0
   434 					lda :STACKORIGIN-1+STACKWIDTH,x
   435 					STA	FP1MAN1
   436 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   437 					CMP	#$80		; SET CARRY FROM MSB
   438 					ORA	#$80		; SET HIDDEN BIT
   439 					STA	FP1MAN2
   440 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   441 					ROL
   442 					STA	FP1EXP
   443 					BEQ	ZERO		; MUL BY ZERO, RESULT ZERO
   444
   445 					LDA	#$00
   446 					ROR
   447 					EOR	FPSGN
   448 					STA	FPSGN
   449 					LDA	FP1EXP
   450 					CLC			; ADD EXPONENTS
   451 					ADC	FP2EXP
   452 					SEC			; SUBTRACT BIAS
   453 					SBC	#$7F
   454 					STA	FPEXP
   455 					LDX	#$00
   456 					STX	FPMAN0
   457 					STX	FPMAN1
   458 					STX	FPMAN2
   459 					STX	FPMAN3
   460 					STX	TMP
   461 8A71			FMULNEXTBYTE:	LDA	FP1MAN0,X
   462 					BNE	@+
   463 					LDX	FPMAN1		; SHORT CIRCUIT BYTE OF ZERO BITS
   464 					STX	FPMAN0
   465 					LDX	FPMAN2
   466 					STX	FPMAN1
   467 					LDX	FPMAN3
   468 					STX	FPMAN2
   469 					STA	FPMAN3
   470 					INC	TMP
   471 					LDX	TMP
   472 					CPX	#$03
   473 					BNE	FMULNEXTBYTE
   474
   475 					ldx @rx
   476 					LDA	FPMAN3
   477 					JMP	FPNORM
   478
   479 8A71			@	EOR	#$FF
   480 					LDX	#$08
   481 8A71			FMULTSTBITS:	LSR	FPMAN3
   482 					ROR	FPMAN2
   483 					ROR	FPMAN1
   484 					ROR	FPMAN0
   485 					LSR
   486 					BCS	FMULNEXTTST
   487 					TAY
   488 					LDA	FP2MAN0
   489 					ADC	FPMAN0
   490 					STA	FPMAN0
   491 					LDA	FP2MAN1
   492 					ADC	FPMAN1
   493 					STA	FPMAN1
   494 					LDA	FP2MAN2
   495 					ADC	FPMAN2
   496 					STA	FPMAN2
   497 					LDA	#$00
   498 					ADC	FPMAN3
   499 					STA	FPMAN3
   500 					TYA
   501 8A71			FMULNEXTTST:	DEX
   502 					BNE	FMULTSTBITS
   503 					INC	TMP
   504 					LDX	TMP
   505 					CPX	#$03
   506 					BNE	FMULNEXTBYTE
   507
   508 					ldx @rx
   509 					LDA	FPMAN3
   510 					JMP	FPNORM
   511 				.endp
   512
   513
   514 8A71			.proc	FDIV
   515
   516 					stx @rx
   517
   518 					lda :STACKORIGIN,x
   519 					STA	FP2MAN0
   520 					lda :STACKORIGIN+STACKWIDTH,x
   521 					STA	FP2MAN1
   522 					lda :STACKORIGIN+STACKWIDTH*2,x
   523 					CMP	#$80		; SET CARRY FROM MSB
   524 					ORA	#$80		; SET HIDDEN BIT
   525 					STA	FP2MAN2
   526 					lda :STACKORIGIN+STACKWIDTH*3,x
   527 					ROL
   528 					STA	FP2EXP
   529 					BNE	@+
   530
   531 				;	LDA	#$00
   532 8A71			ZERO:	STA :STACKORIGIN-1,x
   533 					STA :STACKORIGIN-1+STACKWIDTH,x
   534 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   535 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   536 					rts
   537 				;	LDA	#23		; DIVIDE BY ZERO, ERROR
   538 				;	JMP	SYSTHROW
   539
   540 8A71			@	LDA	#$00
   541 					ROR
   542 					STA	FPSGN
   543 					lda :STACKORIGIN-1,x
   544 					STA	FP1MAN0
   545 					lda :STACKORIGIN-1+STACKWIDTH,x
   546 					STA	FP1MAN1
   547 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   548 					CMP	#$80		; SET CARRY FROM MSB
   549 					ORA	#$80		; SET HIDDEN BIT
   550 					STA	FP1MAN2
   551 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   552 					ROL
   553 					STA	FP1EXP
   554 					BEQ	ZERO		; DIVIDE ZERO, RESULT ZERO
   555
   556 					LDA	#$00
   557 					STA	FP1MAN3
   558 					ROR
   559 					EOR	FPSGN
   560 					STA	FPSGN
   561 					LDA	FP1EXP
   562 					SEC			; SUBTRACT EXPONENTS
   563 					SBC	FP2EXP
   564 					CLC
   565 					ADC	#$7F		; ADD BACK BIAS
   566 					STA	FPEXP
   567
   568 					LDX	#24		; #BITS
   569 8A71			FDIVLOOP:	LDA	FP1MAN0
   570 					SEC
   571 					SBC	FP2MAN0
   572 					STA	TMP
   573 					LDA	FP1MAN1
   574 					SBC	FP2MAN1
   575 					STA	TMP+1
   576 					LDA	FP1MAN2
   577 					SBC	FP2MAN2
   578 					TAY
   579 					LDA	FP1MAN3
   580 					SBC	#$00
   581 					BCC	FDIVNEXTBIT
   582 					STA	FP1MAN3
   583 					STY	FP1MAN2
   584 					LDA	TMP+1
   585 					STA	FP1MAN1
   586 					LDA	TMP
   587 					STA	FP1MAN0
   588 8A71			FDIVNEXTBIT:	ROL	FPMAN0
   589 					ROL	FPMAN1
   590 					ROL	FPMAN2
   591 					ASL	FP1MAN0
   592 					ROL	FP1MAN1
   593 					ROL	FP1MAN2
   594 					ROL	FP1MAN3
   595 					DEX
   596 					BNE	FDIVLOOP
   597
   598 					ldx @rx
   599 					LDA	#$00
   600 					JMP	FPNORM
   601 				.endp
   602
   603
   604 8A71			.proc	FCMPL
   605 8A71			FCMPG:
   606 					CLV
   607
   608 					LDA	:STACKORIGIN+STACKWIDTH*3,X	; COMPARE SIGNS
   609 					AND	#$80
   610 					STA	FP2SGN
   611 					LDA	:STACKORIGIN-1+STACKWIDTH*3,X
   612 					AND	#$80
   613 					CMP	FP2SGN
   614 					BCC	FCMPGTSGN
   615 					BEQ	@+
   616 					BCS	FCMPLTSGN
   617 8A71			@	LDA	:STACKORIGIN-1+STACKWIDTH*3,X	; COMPARE AS MAGNITUDE
   618 					CMP	:STACKORIGIN+STACKWIDTH*3,X
   619 					BCC	FCMPLT
   620 					BEQ	@+
   621 					BCS	FCMPGT
   622 8A71			@	LDA	:STACKORIGIN-1+STACKWIDTH*2,X
   623 					CMP	:STACKORIGIN+STACKWIDTH*2,X
   624 					BCC	FCMPLT
   625 					BEQ	@+
   626 					BCS	FCMPGT
   627 8A71			@	LDA	:STACKORIGIN-1+STACKWIDTH,X
   628 					CMP	:STACKORIGIN+STACKWIDTH,X
   629 					BCC	FCMPLT
   630 					BEQ	@+
   631 					BCS	FCMPGT
   632 8A71			@	LDA	:STACKORIGIN-1,X
   633 					CMP	:STACKORIGIN,X
   634 					BCC	FCMPLT
   635 					BEQ	FCMPEQ
   636 					BCS	FCMPGT
   637 8A71			FCMPEQ:	LDA #0			; EQUAL
   638 					RTS
   639
   640 8A71			FCMPGT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   641 					BMI	FCMPLTSGN
   642 8A71			FCMPGTSGN:	LDA	#$01	; GREATER THAN
   643 					RTS
   644
   645 8A71			FCMPLT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   646 					BMI	FCMPGTSGN
   647 8A71			FCMPLTSGN:	LDA	#$FF	; LESS THAN
   648 					RTS
   649 				.endp
   650
   651
   652 8A71			.proc	F2I
   653
   654 					lda :STACKORIGIN,x
   655 					STA	FPMAN0
   656 					lda :STACKORIGIN+STACKWIDTH,x
   657 					STA	FPMAN1
   658 					lda :STACKORIGIN+STACKWIDTH*2,x
   659 					CMP	#$80		; SET CARRY FROM MSB
   660 					ORA	#$80		; SET HIDDEN BIT
   661 					STA	FPMAN2
   662 					lda :STACKORIGIN+STACKWIDTH*3,x
   663 					ROL	@
   664 					STA	FPEXP
   665 					LDA	#$00
   666 					ROR	@
   667 					STA	FPSGN
   668 					LDA	FPEXP		; CHECK FOR LESS THAN ONE
   669 					SEC
   670 					SBC	#$7F
   671 					BCS	@+
   672
   673 8A71			ZERO:	LDA	#$00		; RETURN ZERO
   674 					STA :STACKORIGIN,x
   675 					STA :STACKORIGIN+STACKWIDTH,x
   676 					STA :STACKORIGIN+STACKWIDTH*2,x
   677 					STA :STACKORIGIN+STACKWIDTH*3,x
   678 					rts
   679
   680 8A71			@	CMP	#23
   681 					BCS	F2ISHL
   682 					STA	FPEXP
   683 					LDA	#23
   684 					SEC
   685 					SBC	FPEXP
   686 					TAY			; SHIFT MANTISSA RIGHT
   687 					LDA	FPMAN2
   688 8A71			F2ISHR:	LSR	@
   689 					ROR	FPMAN1
   690 					ROR	FPMAN0
   691 					DEY
   692 					BNE	F2ISHR
   693 					STA	FPMAN2
   694 					STY	FPMAN3
   695 8A71			F2ICHKNEG:	LDA	FPSGN
   696 					BPL	@+		; CHECK FOR NEGATIVE
   697 					ASL	@		; LDA #$00; SEC
   698
   699 					JSR	NEGINT.enter
   700
   701 8A71			@	LDA	FPMAN3
   702 					STA :STACKORIGIN+STACKWIDTH*3,x
   703 					LDA	FPMAN2
   704 					STA :STACKORIGIN+STACKWIDTH*2,x
   705 					LDA	FPMAN1
   706 					STA :STACKORIGIN+STACKWIDTH,x
   707 					LDA	FPMAN0
   708 					STA :STACKORIGIN,x
   709 					rts
   710
   711 8A71			F2ISHL:	CMP	#32
   712 					BCC	@+
   713 					LDA	#$FF		; OVERFLOW, STORE MAXINT
   714 					STA	FPMAN0
   715 					STA	FPMAN1
   716 					STA	FPMAN2
   717 					LSR	@
   718 					STA	FPMAN3
   719 					BNE	F2ICHKNEG
   720 8A71			@	SEC
   721 					SBC	#23
   722 					BNE	@+
   723 					STA	FPMAN3
   724 					BEQ	F2ICHKNEG
   725 8A71			@	TAY			; SHIFT MANTISSA LEFT
   726 					LDA	#$00
   727 8A71			@	ASL	FPMAN0
   728 					ROL	FPMAN1
   729 					ROL	FPMAN2
   730 					ROL	@
   731 					DEY
   732 					BNE	@-
   733 					STA	FPMAN3
   734 					BEQ	F2ICHKNEG
   735 				.endp
   736
   737
   738 8A71			.proc	I2F
   739
   740 					lda :STACKORIGIN,x
   741 					STA	FPMAN0
   742 					lda :STACKORIGIN+STACKWIDTH,x
   743 					STA	FPMAN1
   744 					lda :STACKORIGIN+STACKWIDTH*2,x
   745 					STA	FPMAN2
   746 					lda :STACKORIGIN+STACKWIDTH*3,x
   747 					STA	FPMAN3
   748 					AND	#$80
   749 					STA	FPSGN
   750 					BPL	@+
   751 				;	LDX	#FPMAN0
   752 					JSR	NEGINT
   753 8A71			@	LDA	#$7F+23
   754 					STA	FPEXP
   755
   756 					inx			; ten zabieg zapisze pod :STACKORIGIN,x
   757 								; zamiast :STACKORIGIN-1,x
   758 					LDA	FPMAN3
   759 					JSR	FPNORM
   760
   761 					dex
   762 					rts
   763 				.endp
   764
   765
   766 8A71			.proc	I2F_m
   767
   768 					lda :STACKORIGIN-1,x
   769 					STA	FPMAN0
   770 					lda :STACKORIGIN-1+STACKWIDTH,x
   771 					STA	FPMAN1
   772 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   773 					STA	FPMAN2
   774 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   775
   776 					STA	FPMAN3
   777 					AND	#$80
   778 					STA	FPSGN
   779 					BPL	@+
   780 				;	LDX	#FPMAN0
   781 					JSR	NEGINT
   782 8A71			@	LDA	#$7F+23
   783 					STA	FPEXP
   784
   785 					LDA	FPMAN3
   786 					JMP	FPNORM
   787 				.endp
  1272
  1273
  1274 8A71			.proc	@printCHAR
  1275 					ldy :STACKORIGIN,x
  1276 					jmp @print
  1277 				.endp
  1278
  1279
  1280 8A71			.proc	@printEOL
  1281 					ldy #eol
  1282 					jmp @print
  1283 				.endp
  1284
  1285
  1286 8A71			.proc	@print (.byte y) .reg
  1287 8A71 8A 48			txa:pha
  1288
  1289 8A73 98				tya
  1290 8A74 20 39 8B			jsr @putchar
  1291
  1292 8A77 68 AA			pla:tax
  1293 8A79 60				rts
  1294 				.endp
  1295
  1296
  1297 8A7A			.proc	@printPCHAR (.word ya) .reg
  1298 					
  1299 					sta cndx0
  1300 					sty cndx1
  1301
  1302 					stx ctmp2
  1303
  1304 					lda #0
  1305 					sta ctmp0
  1306
  1307 8A7A			loop	
  1308 					ldy ctmp0
  1309 					lda (cndx0),y
  1310 					beq stop
  1311
  1312 					inc ndx0
  1313 					beq stop
  1314
  1315 					jsr @putchar
  1316
  1317 					jmp loop
  1318
  1319 8A7A			stop	
  1320 					ldx ctmp2
  1321 					rts
  1322 				.endp
  1323
  1324
  1325 8A7A			.proc	@printSTRING (.word ya) .reg
  1326 					sta ztmp
  1327 					sty ztmp+1
  1328
  1329 					stx ctmp2
  1330
  1331 					ldy #0
  1332 					sty ctmp0
  1333 					lda (ztmp),y
  1334 					sta ctmp3
  1335
  1336 					inw ztmp
  1337
  1338 8A7A			loop	
  1339 					ldy ctmp0
  1340 					lda (ztmp),y
  1341 				;	beq stop
  1342
  1343 					cpy ctmp1
  1344 					beq stop
  1345
  1346 					inc ctmp0
  1347
  1348 					jsr @putchar
  1349
  1350 					jmp loop
  1351
  1352 8A7A			stop	ldx ctmp2
  1353 					rts
  1354 				.endp
  1355
  1356
  1357 8A7A			.proc	@printBOOLEAN
  1358 					lda :STACKORIGIN,x
  1359 					beq _0
  1360
  1361 8A7A			_1	lda <_true
  1362 					ldy >_true
  1363 					jmp @printSTRING
  1364
  1365 8A7A			_0	lda <_false
  1366 					ldy >_false
  1367 					jmp @printSTRING
  1368
  1369 8A7A			_true	dta 4,c'TRUE'
  1370 8A7A			_false	dta 5,c'FALSE'
  1371 				.endp
  1372
  1373
  1374 8A7A			.proc	mov_BYTE_DX
  1375 					mva :STACKORIGIN,x dx
  1376 					mva #$00 dx+1
  1377 					sta dx+2
  1378 					sta dx+3
  1379
  1380 					rts
  1381 				.endp
  1382
  1383 8A7A			.proc	mov_WORD_DX
  1384 					mva :STACKORIGIN,x dx
  1385 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1386 					mva #$00 dx+2
  1387 					sta dx+3
  1388
  1389 					rts
  1390 				.endp
  1391
  1392 8A7A			.proc	mov_CARD_DX
  1393 8A7A B5 80 85 C6			mva :STACKORIGIN,x dx
  1394 8A7E B5 90 85 C7			mva :STACKORIGIN+STACKWIDTH,x dx+1
  1395 8A82 B5 A0 85 C8			mva :STACKORIGIN+STACKWIDTH*2,x dx+2
  1396 8A86 B5 B0 85 C9			mva :STACKORIGIN+STACKWIDTH*3,x dx+3
  1397
  1398 8A8A 60				rts
  1399 				.endp
  1400
  1401
  1402 8A8B			.proc	@printMINUS
  1403 8A8B A0 2D			ldy #'-'
  1404 8A8D 20 F5 8A			jsr @printVALUE.pout
  1405
  1406 8A90 4C 44 8A			jmp negCARD
  1407 				.endp
  1408
  1409
  1410 8A93			.proc	@printSHORTREAL
  1411 					jsr @expandToCARD.SMALL
  1412 					jmp @printREAL
  1413 				.endp
  1414
  1415
  1416 8A93			.proc	@FTOA
  1417
  1418 = 00C6			i	= edx
  1419 = 00CA			fra	= ecx
  1420 = 00C2			hlp	= eax
  1421
  1422 = 00D2			exp	= ztmp
  1423 = 00D3			b	= ztmp+1
  1424 = 00D4			sht	= ztmp+2
  1425
  1426 = 0440			bit	= @buf+64
  1427
  1428 					stx ctmp3
  1429
  1430 					mva :STACKORIGIN,x I
  1431 					sta :STACKORIGIN+9
  1432 					mva :STACKORIGIN+STACKWIDTH,x I+1
  1433 					sta :STACKORIGIN+STACKWIDTH+9
  1434 					mva :STACKORIGIN+STACKWIDTH*2,x I+2
  1435 					sta :STACKORIGIN+STACKWIDTH*2+9
  1436 					mva :STACKORIGIN+STACKWIDTH*3,x I+3
  1437 					sta :STACKORIGIN+STACKWIDTH*3+9	; Sign
  1438
  1439 					bpl skp
  1440
  1441 					ldy #'-'
  1442 					jsr @printVALUE.pout
  1443
  1444 8A93			skp
  1445 				; optimize OK (test_3.pas), line = 32
  1446
  1447 					lda :STACKORIGIN+STACKWIDTH*3+9
  1448 					asl :STACKORIGIN+9
  1449 					rol :STACKORIGIN+STACKWIDTH+9
  1450 					rol :STACKORIGIN+STACKWIDTH*2+9
  1451 					rol @
  1452 					sta EXP				; Exponent
  1453
  1454 				; optimize OK (test_3.pas), line = 33
  1455
  1456 					lda I
  1457 					sta FRA
  1458 					lda I+1
  1459 					sta FRA+1
  1460 					lda I+2
  1461 					sta FRA+2
  1462 					lda I+3
  1463 					sta FRA+3
  1464 					asl FRA
  1465 					rol FRA+1
  1466 					rol FRA+2
  1467 					rol FRA+3
  1468
  1469 				; optimize OK (test_3.pas), line = 35
  1470
  1471 					lda EXP
  1472 					sub #$7F
  1473 					sta SHT
  1474
  1475 				; optimize OK (test_3.pas), line = 37
  1476
  1477 					ldx #$3f
  1478 					lda #0
  1479 					sta:rpl bit,x-
  1480
  1481 				; For
  1482
  1483 				; optimize OK (test_3.pas), line = 39
  1484
  1485 				;	sta B
  1486 					tax
  1487
  1488 				; optimize OK (test_3.pas), line = 39
  1489
  1490 8A93			l_01D4
  1491 				;	lda B
  1492 				;	cmp #$17
  1493 					cpx #$17
  1494 					bcc *+7
  1495 					beq *+5
  1496
  1497 				; ForToDoProlog
  1498 					jmp l_01EE
  1499
  1500 				; optimize OK (test_3.pas), line = 40
  1501
  1502 				;	lda #$20
  1503 				;	add B
  1504 				;	tax
  1505
  1506 					lda FRA+2
  1507 					sta BIT+$20,x
  1508
  1509 				; optimize OK (test_3.pas), line = 41
  1510
  1511 					asl FRA
  1512 					rol FRA+1
  1513 					rol FRA+2
  1514 					rol FRA+3
  1515
  1516 				; ForToDoEpilog
  1517 8A93			c_01D4
  1518 				;	inc B
  1519 					inx
  1520
  1521 					seq
  1522
  1523 				; WhileDoEpilog
  1524 					jmp l_01D4
  1525 8A93			l_01EE
  1526 8A93			b_01D4
  1527
  1528 				; optimize OK (test_3.pas), line = 44
  1529
  1530 					mva #$80 BIT+$1f
  1531
  1532 				; optimize OK (test_3.pas), line = 46
  1533
  1534 					mva #$00 I
  1535 					sta I+1
  1536 					sta I+2
  1537 					sta I+3
  1538
  1539 				; optimize OK (test_3.pas), line = 47
  1540
  1541 					sta FRA+1
  1542 					sta FRA+2
  1543 					sta FRA+3
  1544
  1545 					mva #$01 FRA
  1546
  1547 				; For
  1548
  1549 				; optimize OK (test_3.pas), line = 49
  1550
  1551 					lda SHT
  1552 					add #$1F
  1553 					sta B
  1554
  1555 				; optimize OK (test_3.pas), line = 49
  1556
  1557 					tay
  1558
  1559 8A93			l_035B
  1560 				;	lda B
  1561 				;	cmp #$00
  1562 				;	bcs *+5
  1563
  1564 				; ForToDoProlog
  1565 				;	jmp l_0375
  1566
  1567 				; optimize OK (test_3.pas), line = 50
  1568
  1569 				;	ldy B
  1570 					lda BIT,y
  1571 					bpl l_03D7
  1572
  1573 				; optimize OK (test_3.pas), line = 50
  1574
  1575 					lda I				; Mantissa
  1576 					add FRA
  1577 					sta I
  1578 					lda I+1
  1579 					adc FRA+1
  1580 					sta I+1
  1581 					lda I+2
  1582 					adc FRA+2
  1583 					sta I+2
  1584 					lda I+3
  1585 					adc FRA+3
  1586 					sta I+3
  1587
  1588 				; IfThenEpilog
  1589 8A93			l_03D7
  1590
  1591 				; optimize OK (test_3.pas), line = 52
  1592
  1593 					asl FRA
  1594 					rol FRA+1
  1595 					rol FRA+2
  1596 					rol FRA+3
  1597
  1598 				; ForToDoEpilog
  1599 8A93			c_035B
  1600 				;	dec B
  1601 					dey
  1602
  1603 				;	lda B
  1604 				;	cmp #$ff
  1605 					cpy #$ff
  1606 					seq
  1607
  1608 				; WhileDoEpilog
  1609 					jmp l_035B
  1610 8A93			l_0375
  1611 8A93			b_035B
  1612
  1613 				; optimize OK (test_3.pas), line = 55
  1614
  1615 					mva #$00 FRA
  1616 					sta FRA+1
  1617 					sta FRA+2
  1618 					sta FRA+3
  1619
  1620 				; optimize OK (test_3.pas), line = 56
  1621
  1622 					sta EXP
  1623
  1624 					sta hlp
  1625 					sta hlp+1
  1626
  1627 					lda #$80
  1628 					sta hlp+2
  1629 				; For
  1630
  1631 				; optimize OK (test_3.pas), line = 58
  1632
  1633 					lda SHT
  1634 					add #$20
  1635 				;	sta B
  1636
  1637 					tay
  1638
  1639 				; optimize OK (test_3.pas), line = 58
  1640
  1641 					add #23
  1642 					sta ctmp3
  1643 				; To
  1644 8A93			l_0508
  1645
  1646 				; ForToDoCondition
  1647
  1648 				; optimize OK (test_3.pas), line = 58
  1649
  1650 				;	lda B
  1651 				;	cmp #0
  1652 					cpy ctmp3
  1653
  1654 					bcc *+7
  1655 					beq *+5
  1656
  1657 				; ForToDoProlog
  1658 					jmp l_0534
  1659
  1660 				; optimize OK (test_3.pas), line = 59
  1661
  1662 				;	ldy B
  1663 					lda BIT,y
  1664 					bpl l_0596
  1665
  1666 				; optimize OK (test_3.pas), line = 59
  1667
  1668 					lda FRA
  1669 					add hlp
  1670 					sta FRA
  1671 					lda FRA+1
  1672 					adc hlp+1
  1673 					sta FRA+1
  1674 					lda FRA+2
  1675 					adc hlp+2
  1676 					sta FRA+2
  1677
  1678 				; IfThenEpilog
  1679 8A93			l_0596
  1680
  1681 					lsr hlp+2
  1682 					ror hlp+1
  1683 					ror hlp
  1684
  1685 				; ForToDoEpilog
  1686 8A93			c_0508
  1687 				;	inc B						; inc ptr byte [CounterAddress]
  1688 					iny
  1689
  1690 					seq
  1691
  1692 				; WhileDoEpilog
  1693 					jmp l_0508
  1694 8A93			l_0534
  1695 8A93			b_0508
  1696 8A93				:3 mva fra+# fracpart+#
  1697
  1698 					mva #6 @float.afterpoint	; wymagana liczba miejsc po przecinku
  1699 					@float #500000
  1700
  1701 					ldx ctmp3
  1702
  1703 					rts
  1704 				.endp
  1705
  1706
  1707 8A93			.proc	@printREAL
  1708
  1709 					stx ctmp3
  1710
  1711 					lda :STACKORIGIN+STACKWIDTH*3,x
  1712 					spl
  1713 					jsr @printMINUS
  1714
  1715 					jsr mov_CARD_DX
  1716
  1717 					mva dx+1 intpart		; intpart := uvalue shr 8
  1718 					mva dx+2 intpart+1
  1719 					mva dx+3 intpart+2
  1720 					mva #$00 intpart+3
  1721
  1722 					sta dx+3			; fracpart := uvalue and $FF (dx)
  1723 					sta dx+2
  1724 					sta dx+1
  1725
  1726 					sta fracpart
  1727 					sta fracpart+1
  1728
  1729 					lda dx
  1730 					sta fracpart+2
  1731
  1732 8A93				:4 mva intpart+# dx+#		; integer part
  1733
  1734 					mva #4 @float.afterpoint		; wymagana liczba miejsc po przecinku
  1735 					@float #5000
  1736
  1737 					ldx ctmp3
  1738
  1739 					rts
  1740
  1741 8A93 00 00 00 00		intpart		.dword
  1742
  1743 				.endp
  1744
  1745
  1746 8A97			.proc	@float (.long axy) .reg
  1747 					cnt = ctmp0
  1748 					afterpoint = ctmp1
  1749 					 
  1750 					sty cx
  1751 					stx cx+1
  1752 					sta cx+2
  1753
  1754 					lda Pout_Flag       		; print integer part
  1755 					pha
  1756 					jsr @printVALUE
  1757 					pla
  1758 					sta Pout_Flag
  1759
  1760 					lda #0
  1761 					sta dx
  1762 					sta dx+1
  1763 					sta dx+2
  1764 					sta dx+3
  1765
  1766 8A97			loop	lda fracpart+2
  1767 					bpl skp
  1768
  1769 					clc
  1770 				;	lda cx
  1771 				;	spl
  1772 				;	sec
  1773
  1774 					lda dx
  1775 					adc cx
  1776 					sta dx
  1777 					lda dx+1
  1778 					adc cx+1
  1779 					sta dx+1
  1780 					lda dx+2
  1781 					adc cx+2
  1782 					sta dx+2
  1783 				;	lda dx+3
  1784 				;	adc #0
  1785 				;	sta dx+3
  1786
  1787 8A97			skp	lsr cx+2
  1788 					ror cx+1
  1789 					ror cx
  1790
  1791 					asl fracpart
  1792 					rol fracpart+1
  1793 					rol fracpart+2
  1794
  1795 					lda cx
  1796 					ora cx+1
  1797 					ora cx+2
  1798
  1799 					bne loop
  1800
  1801 					ldy #'.'
  1802 					jsr @printVALUE.pout
  1803
  1804 8A97				:4 mva dx+# fracpart+#
  1805
  1806 					lda Pout_Flag
  1807 					pha
  1808
  1809 					lda #064   
  1810 					sta Pout_Flag
  1811 					jsr @printVALUE			; floating part length
  1812
  1813 					sta cnt
  1814
  1815 					pla
  1816 					sta Pout_Flag
  1817
  1818 8A97			lp	
  1819 				  lda cnt
  1820 					cmp afterpoint 
  1821 					bcs ok
  1822
  1823 					ldy #'0'
  1824 					jsr @printVALUE.pout
  1825
  1826 					inc cnt
  1827 					bne lp
  1828
  1829 8A97			ok	:4 mva fracpart+# dx+#
  1830 					jmp @printVALUE			; print floating part
  1831
  1832 				.endp
  1833
  1834
  1835 8A97			.proc	@printSHORTINT
  1836
  1837 					lda :STACKORIGIN,x
  1838 					spl
  1839 					jsr @printMINUS
  1840
  1841 					jmp @printBYTE
  1842 				.endp
  1843
  1844
  1845 8A97			.proc	@printSMALLINT
  1846
  1847 					lda :STACKORIGIN+STACKWIDTH,x
  1848 					spl
  1849 					jsr @printMINUS
  1850
  1851 					jmp @printWORD
  1852 				.endp
  1853
  1854
  1855 8A97			.proc	@printINT
  1856
  1857 8A97 B5 B0			lda :STACKORIGIN+STACKWIDTH*3,x
  1858 8A99 10 03			spl
  1859 8A9B 20 8B 8A			jsr @printMINUS
  1860
  1861 8A9E 4C A1 8A			jmp @printCARD
  1862 				.endp
  1863
  1864
  1865 8AA1			.proc	@printCARD
  1866 8AA1 20 7A 8A			jsr mov_CARD_DX
  1867 8AA4 4C A7 8A			jmp @printVALUE
  1868 				.endp
  1869
  1870
  1871 8AA7			.proc	@printWORD
  1872 					jsr mov_WORD_DX
  1873 					jmp @printVALUE
  1874 				.endp
  1875
  1876
  1877 8AA7			.proc	@printBYTE
  1878 					jsr mov_BYTE_DX
  1879 					jmp @printVALUE
  1880 				.endp
  1881
  1882
  1883 8AA7			.proc	@printVALUE
  1884 = 00EA			  limit = ctmp0
  1885 = 00EB				cnt = ctmp1
  1886 					
  1887 8AA7 A5 C9			lda dx+3
  1888 8AA9 D0 14			bne _32bit
  1889
  1890 8AAB A5 C8			lda dx+2
  1891 8AAD D0 0C			bne _24bit
  1892
  1893 8AAF A5 C7			lda dx+1
  1894 8AB1 D0 04			bne _16bit
  1895
  1896 8AB3 A9 03		_8bit	lda #3
  1897 8AB5 D0 0A			bne l3
  1898
  1899 8AB7 A9 05		_16bit	lda #5
  1900 8AB9 D0 06			bne l3
  1901
  1902 8ABB A9 08		_24bit	lda #8
  1903 8ABD D0 02			bne l3
  1904
  1905 					; prints a 32 bit value to the screen (Graham)
  1906
  1907 8ABF A9 0A		_32bit	lda #10
  1908
  1909 8AC1 85 EA		l3	sta limit
  1910
  1911 8AC3 86 ED			stx ctmp3
  1912
  1913 8AC5 A2 00			ldx #0
  1914 8AC7 86 EB			stx cnt
  1915
  1916 8AC9 20 0A 8B		lp	jsr div10
  1917
  1918 8ACC 9D 4E 02			sta temp_storage,x
  1919 8ACF E8				inx
  1920 8AD0 E4 EA			cpx limit	
  1921 8AD2 D0 F5			bne lp
  1922
  1923 					;ldx #9
  1924 8AD4 CA				dex
  1925
  1926 8AD5 BD 4E 02		l1	lda temp_storage,x
  1927 8AD8 D0 03			bne l2
  1928 8ADA CA				dex		; skip leading zeros
  1929 8ADB D0 F8			bne l1
  1930
  1931 8ADD BD 4E 02		l2	lda temp_storage,x
  1932 8AE0 09 30			ora #$30
  1933 8AE2 A8				tay
  1934
  1935 8AE3 20 F5 8A			jsr pout
  1936 8AE6 E6 EB			inc cnt
  1937
  1938 8AE8 CA				dex
  1939 8AE9 10 F2			bpl l2
  1940
  1941 8AEB A9 00 8D 68 02		mva #0 Pout_Flag
  1942
  1943 8AF0 A5 EB			lda cnt	
  1944
  1945 8AF2 A6 ED			ldx ctmp3
  1946 8AF4 60				rts
  1947
  1948 				; jmp instruction either replaceed by bit, rts, or jmp
  1949 				; replace with bit flag???
  1950 8AF5			pout
  1951 8AF5 2C 68 02			BIT pout_flag
  1952 8AF8 30 05			BMI No_POUT 
  1953 8AFA 70 0D			BVS Exit_POUT
  1954 8AFC 4C 71 8A		  JMP @print
  1955 8AFF			No_POUT
  1956 				;;; pout	   
  1957 				;	sty @buf+1
  1958 				;pbuf	equ *-2
  1959 				;	inc pbuf
  1960
  1961 8AFF 48				PHA
  1962 8B00 98				TYA
  1963 8B01 A4 EE			LDY cndx0
  1964 8B03 99 00 04			STA @buf,Y
  1965 8B06 68			  PLA
  1966 8B07 E6 EE		  INC cndx0
  1967 8B09			Exit_POUT
  1968 8B09 60				RTS
  1969
  1970 				;;; tmp	.byte 0,0,0,0,0,0,0,0,0,0
  1971
  1972 				.endp
  1973
  1974
  1975 				; divides a 32 bit value by 10
  1976 				; remainder is returned in akku
  1977
  1978 8B0A			.proc	div10
  1979 8B0A A0 20		        ldy #32		; 32 bits
  1980 8B0C A9 00		        lda #0
  1981 8B0E 18			        clc
  1982 8B0F 2A			l4      rol @
  1983 8B10 C9 0A		        cmp #10
  1984 8B12 90 02		        bcc skip
  1985 8B14 E9 0A		        sbc #10
  1986 8B16 26 C6		skip    rol dx
  1987 8B18 26 C7		        rol dx+1
  1988 8B1A 26 C8		        rol dx+2
  1989 8B1C 26 C9		        rol dx+3
  1990 8B1E 88			        dey
  1991 8B1F 10 EE		        bpl l4
  1992
  1993 8B21 60				rts
  1994 				.endp
  1995
  1996
  1997 8B22			.proc	@hexStr
  1998
  1999 = 00C6			Value	= edx
  2000 = 00CA			Digits	= ecx
  2001
  2002 					ldx Digits
  2003 					cpx #32
  2004 					scc
  2005 					ldx #32
  2006
  2007 					stx Digits
  2008
  2009 					lda Value
  2010 					jsr hex
  2011 					lda Value+1
  2012 					jsr hex
  2013 					lda Value+2
  2014 					jsr hex
  2015 					lda Value+3
  2016 					jsr hex
  2017
  2018 					lda Digits
  2019 					sta @buf
  2020 					rts
  2021
  2022 8B22			hex	pha
  2023 					and #$f
  2024 					jsr put
  2025 					pla
  2026 8B22				:4 lsr @
  2027 8B22			put	tay
  2028 					lda thex,y
  2029 					sta @buf,x
  2030 					dex
  2031 					rts
  2032
  2033 8B22			thex	dta c'0123456789ABCDEF'
  2034 				.endp
  2035
  2036
  2037 8B22			.proc	@ValueToStr (.word ya) .reg
  2038 				  
  2039 8B22 85 F0			sta cndx2 ;adr
  2040 8B24 84 F1			sty cndx3 ;adr+1
  2041
  2042 8B26 A9 80 8D 68 02		mva #128 Pout_Flag
  2043 					;;;mva <@buf+1 @printVALUE.pbuf
  2044 8B2B A9 01 85 EE			mva <@buf+1 cndx0
  2045
  2046 8B2F 20 0F 8C			JSR Call_Subroutine
  2047 				;adr	equ *-2
  2048
  2049 					;ldy @printVALUE.pbuf
  2050 8B32 A4 EE			ldy cndx0
  2051 8B34 88				dey
  2052 8B35 8C 00 04			sty @buf
  2053
  2054 8B38 60				rts
  2055 				.endp
  2056
  2057
  2058 				;	ecx	isSign
  2059 				;	edx	Result
  2060
  2061 8B39			.proc	@StrToInt (.word ya) .reg
  2062 				  len	= ctmp0        
  2063 					sta bp2
  2064 					sty bp2+1
  2065
  2066 					ldy #0
  2067 					sty MAIN.SYSTEM.IOResult
  2068 					sty edx
  2069 					sty edx+1
  2070 					sty edx+2
  2071 					sty edx+3
  2072
  2073 					lda (bp2),y
  2074 					beq stop
  2075 					sta len
  2076
  2077 					inw bp2
  2078
  2079 					lda (bp2),y
  2080 					cmp #'-'
  2081 					sne
  2082 					iny
  2083
  2084 					sty ecx
  2085
  2086 8B39			l1	lda (bp2),y
  2087
  2088 					CLC
  2089 					ADC #$FF-'9'	; make m = $FF
  2090 					ADC #'9'-'0'+1	; carry set if in range n to m
  2091 					bcs ok
  2092
  2093 					lda #106	; Invalid numeric format
  2094 					sta MAIN.SYSTEM.IOResult
  2095
  2096 					rts		; reg Y contains the index of the character in S which prevented the conversion
  2097
  2098 8B39			ok	jsr fmul10
  2099
  2100 					lda (bp2),y
  2101 					sub #$30
  2102 					sta ztmp
  2103
  2104 					lda #$00
  2105 					sta ztmp+1
  2106 					sta ztmp+2
  2107 					sta ztmp+3
  2108
  2109 					jsr fmul10.add32bit
  2110
  2111 					iny
  2112 					cpy len	
  2113 					bne l1
  2114
  2115 					lda ecx
  2116 					beq stop
  2117
  2118 					jsr negEDX
  2119
  2120 8B39			stop	ldy #0		; reg Y = 0 conversion successful
  2121 					rts
  2122 				.endp
  2123
  2124
  2125 8B39			.proc	negEDX
  2126 					lda #$00	; minus
  2127 					sub edx
  2128 					sta edx
  2129
  2130 					lda #$00
  2131 					sbc edx+1
  2132 					sta edx+1
  2133
  2134 					lda #$00
  2135 					sbc edx+2
  2136 					sta edx+2
  2137
  2138 					lda #$00
  2139 					sbc edx+3
  2140 					sta edx+3
  2141
  2142 					rts
  2143 				.endp
  2144
  2145
  2146 8B39			.proc	fmul10
  2147 					asl edx		;multiply by 2
  2148 					rol edx+1	;temp store in ZTMP
  2149 					rol edx+2
  2150 					rol edx+3
  2151
  2152 					lda edx
  2153 					sta ztmp
  2154 					lda edx+1
  2155 					sta ztmp+1
  2156 					lda edx+2
  2157 					sta ztmp+2
  2158 					lda edx+3
  2159 					sta ztmp+3
  2160
  2161 					asl edx
  2162 					rol edx+1
  2163 					rol edx+2
  2164 					rol edx+3
  2165
  2166 					asl edx
  2167 					rol edx+1
  2168 					rol edx+2
  2169 					rol edx+3
  2170
  2171 8B39			add32bit
  2172 					lda edx
  2173 					add ztmp
  2174 					sta edx
  2175 					lda edx+1
  2176 					adc ztmp+1
  2177 					sta edx+1
  2178 					lda edx+2
  2179 					adc ztmp+2
  2180 					sta edx+2
  2181 					lda edx+3
  2182 					adc ztmp+3
  2183 					sta edx+3
  2184
  2185 					rts
  2186 				.endp
  2187
  2188
  2189 8B39			.proc	@trunc
  2190
  2191 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2192 					spl
  2193 					jsr negCARD
  2194
  2195 					mva :STACKORIGIN+STACKWIDTH,x :STACKORIGIN,x
  2196 					mva :STACKORIGIN+STACKWIDTH*2,x :STACKORIGIN+STACKWIDTH,x
  2197 					mva :STACKORIGIN+STACKWIDTH*3,x :STACKORIGIN+STACKWIDTH*2,x
  2198 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2199
  2200 					tya
  2201 					spl
  2202 					jsr negCARD
  2203
  2204 					rts
  2205 				.endp
  2206
  2207
  2208 8B39			.proc	@round
  2209
  2210 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2211 					spl
  2212 					jsr negCARD
  2213
  2214 					lda :STACKORIGIN,x
  2215 				//	add #$80
  2216 					cmp #$80
  2217 					lda :STACKORIGIN+STACKWIDTH,x
  2218 					adc #0
  2219 					sta :STACKORIGIN,x
  2220 					lda :STACKORIGIN+STACKWIDTH*2,x
  2221 					adc #0
  2222 					sta :STACKORIGIN+STACKWIDTH,x
  2223 					lda :STACKORIGIN+STACKWIDTH*3,x
  2224 					adc #0
  2225 					sta :STACKORIGIN+STACKWIDTH*2,x
  2226
  2227 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2228
  2229 					tya
  2230 					spl
  2231 					jsr negCARD
  2232
  2233 					rts
  2234 				.endp
  2235
  2236
  2237 8B39			.proc	@frac
  2238
  2239 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2240 					spl
  2241 					jsr negCARD
  2242
  2243 					lda #$00
  2244 					sta :STACKORIGIN+STACKWIDTH,x
  2245 					sta :STACKORIGIN+STACKWIDTH*2,x
  2246 					sta :STACKORIGIN+STACKWIDTH*3,x
  2247
  2248 					tya
  2249 					spl
  2250 					jsr negCARD
  2251
  2252 					rts
  2253 				.endp
  2254
  2255
  2256 8B39			.proc	@int
  2257
  2258 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2259 					spl
  2260 					jsr negCARD
  2261
  2262 					lda #$00
  2263 					sta :STACKORIGIN,x
  2264
  2265 					tya
  2266 					spl
  2267 					jsr negCARD
  2268
  2269 					rts
  2270 				.endp
  2271
  2272
  2273 				;----------------------------;
  2274 				; Biblioteka procedur        ;
  2275 				; graficznych                ;
  2276 				;----------------------------;
  2277 				; Autorzy:                   ;
  2278 				;  Slawomir 'SERO' Ritter,   ;
  2279 				;  Jakub Cebula,             ;
  2280 				;  Winfried Hofacker         ;
  2281 				;----------------------------;
  2282 				; Wersja:1.1 DATA:09.01.2008 ;
  2283 				;----------------------------;
  2284
  2285 = 0003			@open	= $03		; Otworz kanal
  2286 = 000C			@close	= $0c		; Zamknij kanal
  2287
  2288 = 0007			@IDget	= $07		; Narysuj punkt
  2289 = 0009			@IDput	= $09		; Narysuj punkt
  2290 = 0011			@IDdraw	= $11		; Narysuj linie
  2291 = 0012			@IDfill	= $12		; Wypelnij obszar
  2292
  2293
  2294 				;------------------------;
  2295 				;Wy:.Y-numer bledu (1-OK);
  2296 				;   f(N)=1-wystapil blad ;
  2297 				;------------------------;
  2298 8B39			.proc	@COMMAND
  2299 8B39			scrchn	equ ctmp0
  2300 8B39			colscr	equ ctmp1
  2301
  2302
  2303
  2304 					ldx	scrchn
  2305 				;;scrchn	equ *-1
  2306
  2307 					sta	iocom,x
  2308
  2309 					lda	colscr
  2310 				;; colscr	equ *-1
  2311 					sta	atachr
  2312
  2313 					jmp	ciov
  2314 				.endp
  2315
  2316 				;------------------------;
  2317 				; Ustaw tryb ekranu      ;
  2318 				;------------------------;
  2319 				;We:.X-numer kanalu      ;
  2320 				;      (normalnie 0)     ;
  2321 				;   .Y-numer trybu (O.S.);
  2322 				;   .A-Ustawiony bit nr :;
  2323 				;     5-Nie kasowanie    ;
  2324 				;       pamieci ekranu   ;
  2325 				;     4-Obecnosc okna    ;
  2326 				;       tekstowego       ;
  2327 				;     2-Odczyt z ekranu  ;
  2328 				;------------------------;
  2329 				;Wy:SCRCHN-numer kanalu  ;
  2330 				;  .Y-numer bledu (1-OK) ;
  2331 				;   f(N)=1 wystapil blad ;
  2332 				;------------------------;
  2333 8B39			@GRAPHICS .proc (.byte x,y,a) .reg
  2334
  2335 					sta	byte1
  2336 					sty	byte2
  2337
  2338 					stx	@COMMAND.scrchn
  2339
  2340 					lda	#@close
  2341 					jsr	xcio
  2342
  2343 					lda	#0		; =opcje
  2344 8B39			byte1	equ	*-1
  2345 					ora	#8		; +zapis na ekranie
  2346 					sta	ioaux1,x
  2347
  2348 					lda	#0
  2349 8B39			byte2	equ	*-1
  2350 					sta	ioaux2,x	;=nr.trybu
  2351
  2352 					mwa	#sname	ioadr,x
  2353
  2354 					lda	#@open
  2355
  2356 8B39			xcio	sta iocom,x
  2357 					jmp ciov
  2358
  2359 8B39			sname	dta c'S:',$9b
  2360
  2361 					.endp
  2362
  2363
  2364 8B39			.proc	@ata2int
  2365 				        asl
  2366 				        php
  2367 				        cmp #2*$60
  2368 				        bcs @+
  2369 				        sbc #2*$20-1
  2370 				        bcs @+
  2371 				        adc #2*$60
  2372 8B39			@       plp
  2373 				        ror
  2374 					rts
  2375 				.endp
  2376
  2377
  2378 				/*
  2379 				  PUT CHAR
  2380
  2381 				  Procedura wyprowadza znak na ekran na pozycji X/Y kursora okreslonej przez zmienne odpowiednio
  2382 				  COLCRS ($55-$56) i ROWCRS ($54). Zaklada sie, ze obowiazuja przy tym domyslne ustawienia OS-u,
  2383 				  to jest ekran jest w trybie Graphics 0, a kanal IOCB 0 jest otwarty dla edytora ekranowego.
  2384
  2385 				  Wyprowadzenie znaku polega na zaladowaniu jego kodu ATASCII do akumulatora i wykonaniu rozkazu
  2386 				  JSR PUTCHR.
  2387 				*/
  2387
  2388
  2389 8B39			.proc	@putchar (.byte a) .reg
  2390
  2391 8B39 2C 39 8B		vbxe	bit *
  2392
  2393 8B3C A2 00			ldx #$00
  2394 					.ifdef MAIN.CRT.TextAttr
  2395 					ora MAIN.CRT.TextAttr
  2396 					.endif
  2397 8B3E A8				tay
  2398 8B3F BD 47 03			lda icputb+1,x
  2399 8B42 48				pha
  2400 8B43 BD 46 03			lda icputb,x
  2401 8B46 48				pha
  2402 8B47 98				tya
  2403
  2404 8B48 60				rts
  2405
  2406 				.endp
  2407
  2408
  2409 				/*
  2410 				  GETLINE
  2411
  2412 				  Program czeka, az uzytkownik wpisze ciag znak�w z klawiatury i nacisnie klawisz RETURN.
  2413 				  Znaki podczas wpisywania sa wyswietlane na ekranie, dzialaja tez normalne znaki kontrolne
  2414 				  (odczyt jest robiony z edytora ekranowego).
  2415
  2416 				  Wywolanie funkcji polega na zaladowaniu adresu, pod jaki maja byc wpisane znaki,
  2417 				  do rejestr�w A/Y (mlodszy/starszy) i wykonaniu rozkazu JSR GETLINE.
  2418
  2419 				*/
  2419
  2420
  2421 8B49			.proc	@GetLine
  2422
  2423 					stx ctmp3
  2424
  2425 					ldx #0
  2426
  2427 					stx MAIN.SYSTEM.EoLn
  2428
  2429 					mwa	#@buf+1	icbufa,x
  2430
  2431 					mwa	#$ff	icbufl,x	; maks. wielkosc tekstu
  2432
  2433 					mva	#$05	iccmd,x
  2434
  2435 					jsr	ciov
  2436
  2437 					dew icbufl
  2438 					mva icbufl @buf			; length
  2439
  2440 					ldx @buf+1
  2441 					cpx #EOL
  2442 					bne skp
  2443
  2444 					ldx #TRUE
  2445 					stx MAIN.SYSTEM.EoLn
  2446 8B49			skp
  2447 					ldx ctmp3
  2448 					rts
  2449 				.endp
  2450
  2451
  2452 8B49			.proc	@GetKey
  2453
  2454 8B49			getk	lda kbcodes	; odczytaj kbcodes
  2455 					cmp #255		; czy jest znak?
  2456 					beq getk	; nie: czekaj
  2457 					ldy #255		; daj zna�, �e klawisz
  2458 					sty kbcodes	; zosta� odebrany
  2459 					tay		; kod klawisza jako indeks
  2460 					lda (keydef),y	; do tablicy w ROM-ie
  2461
  2462 					rts
  2463 				.endp
  2464
  2465
  2466 8B49			.proc	@moveSTRING (.word ya) .reg
  2467
  2468 					sta @move.dst
  2469 					sty @move.dst+1
  2470
  2471 					mva :STACKORIGIN,x @move.src
  2472 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2473
  2474 					ldy #$00
  2475 					lda (@move.src),y
  2476 					add #1
  2477 					sta @move.cnt
  2478 					scc
  2479 					iny
  2480 					sty @move.cnt+1
  2481
  2482 					jmp @move
  2483 				.endp
  2484
  2485
  2486 8B49			.proc	@moveSTRING_1 (.word ya) .reg
  2487
  2488 					sta @move.dst
  2489 					sty @move.dst+1
  2490
  2491 					mva :STACKORIGIN,x @move.src
  2492 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2493
  2494 					ldy #$00
  2495 					lda (@move.src),y
  2496 				;	add #1
  2497 					sta @move.cnt
  2498 					sty @move.cnt+1
  2499
  2500 					inw @move.src
  2501
  2502 					jmp @move
  2503 				.endp
  2504
  2505
  2506 				; Ullrich von Bassewitz, 2003-08-20
  2507 				; Performance increase (about 20%) by
  2508 				; Christian Krueger, 2009-09-13
  2509
  2510 8B49			.proc	@moveu		; assert Y = 0
  2511
  2512 = 00C6			ptr1	= edx
  2513 = 00CA			ptr2	= ecx
  2514 = 00C2			ptr3	= eax
  2515
  2516 8B49 86 ED			stx ctmp3
  2517
  2518 8B4B A0 00			ldy	#0
  2519
  2520 8B4D A6 C3			ldx     ptr3+1		; Get high byte of n
  2521 8B4F F0 13			beq     L2		; Jump if zero
  2522
  2523 				L1:     .rept 2		; Unroll this a bit to make it faster...
  2524 					LDA     (PTR1),Y	
  2525 					STA     (PTR2),Y
  2526 					INY
  2527 					.ENDR
  2527 					.endr
Source: REPT
  2524 8B51 B1 C6			LDA     (PTR1),Y	
  2524 8B53 91 CA			STA     (PTR2),Y
  2524 8B55 C8				INY
  2524 8B56 B1 C6			LDA     (PTR1),Y	
  2524 8B58 91 CA			STA     (PTR2),Y
  2524 8B5A C8				INY
Source: cpu6502.asm
  2528
  2529 8B5B D0 F4			bne     L1
  2530 8B5D E6 C7			inc     ptr1+1
  2531 8B5F E6 CB			inc     ptr2+1
  2532 8B61 CA				dex			; Next 256 byte block
  2533 8B62 D0 ED			bne	L1		; Repeat if any
  2534
  2535 					; the following section could be 10% faster if we were able to copy
  2536 					; back to front - unfortunately we are forced to copy strict from
  2537 					; low to high since this function is also used for
  2538 					; memmove and blocks could be overlapping!
  2539 					; {
  2540 8B64			L2:				; assert Y = 0
  2541 8B64 A6 C2			ldx     ptr3		; Get the low byte of n
  2542 8B66 F0 08			beq     done		; something to copy
  2543
  2544 8B68 B1 C6		L3:     lda     (ptr1),Y	; copy a byte
  2545 8B6A 91 CA			sta     (ptr2),Y
  2546 8B6C C8				iny
  2547 8B6D CA				dex
  2548 8B6E D0 F8			bne     L3
  2549
  2550 					; }
  2551
  2552 8B70 A6 ED		done	ldx ctmp3
  2553
  2554 8B72 60				rts
  2555 				.endp
  2556
  2557
  2558 8B73			@move	.proc (.word ptr1, ptr2, ptr3) .var
  2559
  2560 = 00C6			ptr1	= edx
  2561 = 00CA			ptr2	= ecx
  2562 = 00C2			ptr3	= eax
  2563
  2564 = 00C6			src	= ptr1
  2565 = 00CA			dst	= ptr2
  2566 = 00C2			cnt	= ptr3
  2567
  2568 8B73 A5 CB C5 C7 D0 04 + 	cpw ptr2 ptr1
  2569 8B7D B0 03			scs
  2570 8B7F 4C 49 8B			jmp @moveu
  2571
  2572 8B82 86 ED			stx ctmp3
  2573
  2574 				; Copy downwards. Adjust the pointers to the end of the memory regions.
  2575
  2576 8B84 A5 C7			lda     ptr1+1
  2577 8B86 18 65 C3			add     ptr3+1
  2578 8B89 85 C7			sta     ptr1+1
  2579
  2580 8B8B A5 CB			lda     ptr2+1
  2581 8B8D 18 65 C3			add     ptr3+1
  2582 8B90 85 CB			sta     ptr2+1
  2583
  2584 				; handle fractions of a page size first
  2585
  2586 8B92 A4 C2			ldy     ptr3		; count, low byte
  2587 8B94 D0 06			bne     @entry		; something to copy?
  2588 8B96 F0 0B			beq     PageSizeCopy	; here like bra...
  2589
  2590 8B98			@copyByte:
  2591 8B98 B1 C6			lda     (ptr1),y
  2592 8B9A 91 CA			sta     (ptr2),y
  2593 8B9C			@entry:
  2594 8B9C 88				dey
  2595 8B9D D0 F9			bne     @copyByte
  2596 8B9F B1 C6			lda     (ptr1),y	; copy remaining byte
  2597 8BA1 91 CA			sta     (ptr2),y
  2598
  2599 8BA3			PageSizeCopy:			; assert Y = 0
  2600 8BA3 A6 C3			ldx     ptr3+1		; number of pages
  2601 8BA5 F0 1D			beq     done		; none? -> done
  2602
  2603 8BA7			@initBase:
  2604 8BA7 C6 C7			dec     ptr1+1		; adjust base...
  2605 8BA9 C6 CB			dec     ptr2+1
  2606 8BAB 88				dey			; in entry case: 0 -> FF
  2607 8BAC B1 C6			lda     (ptr1),y	; need to copy this 'intro byte'
  2608 8BAE 91 CA			sta     (ptr2),y	; to 'land' later on Y=0! (as a result of the '.repeat'-block!)
  2609 8BB0 88				dey			; FF ->FE
  2610 8BB1			@copyBytes:
  2611 					.rept 2		; Unroll this a bit to make it faster...
  2612 					LDA     (PTR1),Y
  2613 					STA     (PTR2),Y
  2614 					DEY
  2615 					.ENDR
  2615 					.endr
Source: REPT
  2612 8BB1 B1 C6			LDA     (PTR1),Y
  2612 8BB3 91 CA			STA     (PTR2),Y
  2612 8BB5 88				DEY
  2612 8BB6 B1 C6			LDA     (PTR1),Y
  2612 8BB8 91 CA			STA     (PTR2),Y
  2612 8BBA 88				DEY
Source: cpu6502.asm
  2616 8BBB			@copyEntry:			; in entry case: 0 -> FF
  2617 8BBB D0 F4			bne     @copyBytes
  2618 8BBD B1 C6			lda     (ptr1),y	; Y = 0, copy last byte
  2619 8BBF 91 CA			sta     (ptr2),y
  2620 8BC1 CA				dex			; one page to copy less
  2621 8BC2 D0 E3			bne     @initBase	; still a page to copy?
  2622
  2623 8BC4 A6 ED		done	ldx ctmp3
  2624
  2625 8BC6 60				rts
  2626 				.endp
  2627
  2628
  2629 				; Ullrich von Bassewitz, 29.05.1998
  2630 				; Performance increase (about 20%) by
  2631 				; Christian Krueger, 12.09.2009, slightly improved 12.01.2011
  2632
  2633 8BC7			.proc	@fill (.word ptr1, ptr3 .byte ptr2) .var
  2634
  2635 = 00C6			ptr1 = edx
  2636 = 00CA			ptr3 = ecx
  2637 = 00C2			ptr2 = eax
  2638
  2639 8BC7 86 ED			stx ctmp3
  2640
  2641 8BC9 A6 C2			ldx ptr2
  2642
  2643 8BCB A0 00			ldy #0
  2644
  2645 8BCD 46 CB		        lsr	ptr3+1          ; divide number of
  2646 8BCF 66 CA		        ror	ptr3            ; bytes by two to increase
  2647 8BD1 90 09		        bcc	evenCount       ; speed (ptr3 = ptr3/2)
  2648 8BD3			oddCount:
  2649 								; y is still 0 here
  2650 8BD3 8A			        txa			; restore fill value
  2651 8BD4 91 C6		        sta	(ptr1),y	; save value and increase
  2652 8BD6 E6 C6		        inc	ptr1		; dest. pointer
  2653 8BD8 D0 02		        bne	evenCount
  2654 8BDA E6 C7		        inc	ptr1+1
  2655 8BDC			evenCount:
  2656 8BDC A5 C6			lda	ptr1		; build second pointer section
  2657 8BDE 18				clc
  2658 8BDF 65 CA			adc	ptr3		; ptr2 = ptr1 + (length/2) <- ptr3
  2659 8BE1 85 C2			sta     ptr2
  2660 8BE3 A5 C7			lda     ptr1+1
  2661 8BE5 65 CB			adc     ptr3+1
  2662 8BE7 85 C3			sta     ptr2+1
  2663
  2664 8BE9 8A			        txa			; restore fill value
  2665 8BEA A6 CB		        ldx	ptr3+1		; Get high byte of n
  2666 8BEC F0 13		        beq	L2		; Jump if zero
  2667
  2668 				; Set 256/512 byte blocks
  2669 								; y is still 0 here
  2670 				L1:	.rept 2		; Unroll this a bit to make it faster
  2671 					STA	(PTR1),Y	
  2672 					STA	(PTR2),Y	
  2673 					INY
  2674 					.ENDR
  2674 					.endr
Source: REPT
  2671 8BEE 91 C6			STA	(PTR1),Y	
  2671 8BF0 91 C2			STA	(PTR2),Y	
  2671 8BF2 C8				INY
  2671 8BF3 91 C6			STA	(PTR1),Y	
  2671 8BF5 91 C2			STA	(PTR2),Y	
  2671 8BF7 C8				INY
Source: cpu6502.asm
  2675 8BF8 D0 F4		        bne	L1
  2676 8BFA E6 C7		        inc	ptr1+1
  2677 8BFC E6 C3		        inc	ptr2+1
  2678 8BFE CA			        dex                     ; Next 256 byte block
  2679 8BFF D0 ED		        bne	L1              ; Repeat if any
  2680
  2681 				; Set the remaining bytes if any
  2682
  2683 8C01 A4 CA		L2:	ldy	ptr3            ; Get the low byte of n
  2684 8C03 F0 07			beq	leave           ; something to set? No -> leave
  2685
  2686 8C05 88			L3:	dey
  2687 8C06 91 C6			sta	(ptr1),y	; set bytes in low
  2688 8C08 91 C2			sta	(ptr2),y	; and high section
  2689 8C0A D0 F9			bne     L3		; flags still up to date from dey!
  2690
  2691 8C0C A6 ED		leave	ldx ctmp3
  2692
  2693 8C0E 60				rts			; return
  2694 				.endp
  2695
  2696
  2697 				/*
  2698 				 add strings
  2699 				 result -> @buf
  2700 				*/
  2700
  2701 8C0F			.proc	@addString(.word ya) .reg
  2702
  2703 					sta ztmp
  2704 					sty ztmp+1
  2705
  2706 					stx ctmp3
  2707
  2708 					ldx @buf
  2709 					inx
  2710 					beq stop
  2711
  2712 					ldy #0
  2713 					lda (ztmp),y
  2714 					sta ile
  2715 					beq stop
  2716
  2717 					iny
  2718
  2719 8C0F			load	lda (ztmp),y
  2720 					sta @buf,x
  2721
  2722 					iny
  2723 					inx
  2724 					beq stop
  2725 					dec ile
  2726 					bne load
  2727
  2728 8C0F			stop	dex
  2729 					stx @buf
  2730
  2731 					ldx ctmp3
  2732
  2733 					rts
  2734
  2735 8C0F			ile	brk
  2736 				.endp
  2737
  2738
  2739 				/* ----------------------------------------------------------------------- */
  2740
  2741
  2742 8C0F			.proc	@AllocMem(.word ztmp .word ztmp+2) .var
  2743
  2744 					jsr swap
  2745
  2746 					adw spoint ztmp+2
  2747
  2748 					rts
  2749
  2750 8C0F			swap	txa:pha
  2751
  2752 					mwa spoint bp2
  2753
  2754 					ldx #0
  2755 					ldy #0
  2756
  2757 8C0F			loop	cpy ztmp+2
  2758 					bne @+
  2759 					cpx ztmp+3
  2760 					beq stop
  2761
  2762 8C0F			@	lda (bp2),y
  2763 					pha
  2764
  2765 					lda (ztmp),y
  2766 					sta (bp2),y
  2767
  2768 					pla
  2769 					sta (ztmp),y
  2770
  2771 					iny
  2772 					bne loop
  2773
  2774 					inc ztmp+1
  2775 					inc bp2+1
  2776 					inx
  2777
  2778 					jmp loop
  2779
  2780 8C0F			stop	pla:tax
  2781
  2782 					rts
  2783
  2784 8C0F			spoint	dta a(PROGRAMSTACK)
  2785 				.endp
  2786
  2787
  2788 8C0F			.proc	@FreeMem(.word ztmp .word ztmp+2) .var
  2789
  2790 					sbw @AllocMem.spoint ztmp+2
  2791
  2792 					jmp @AllocMem.swap
  2793 				.endp
  2794
  2795
  2796 				/* ----------------------------------------------------------------------- */
  2797
  2798
  2799 8C0F			.proc	@vbxe_detect
  2800
  2801 					ldy #.sizeof(detect)-1
  2802 					mva:rpl copy,y detect,y-
  2803
  2804 					jmp detect
  2805
  2806 8C0F			copy
  2807 0400				.local	detect,@buf
  2808 				;
  2809 				; 2009 by KMK/DLT
  2810 				;
  2811 					lda #0
  2812 					sta fxptr
  2813
  2814 				        lda #$d6
  2815 				        sta fxptr+1
  2816 				        ldy #FX_MEMB
  2817 				        jsr ?clr
  2818
  2819 				        jsr ?try
  2820 				        bcc ok
  2821
  2822 				        inc fxptr+1
  2823
  2824 					jsr ?try
  2825 					bcc ok
  2826
  2827 					lda #0
  2828 					sta fxptr+1
  2829 					rts
  2830
  2831 0400			?try    ldx $4000
  2832 				        jsr ?chk
  2833 				        bcc ?ret
  2834 				        inx
  2835 				        stx $4000
  2836 				        jsr ?chk
  2837 				        dec $4000
  2838 0400			?ret    rts
  2839
  2840 0400			ok	ldy	#VBXE_MINOR		; get core minor version
  2841 					lda	(fxptr),y
  2842 					rts
  2843
  2844 0400			?chk    lda #$80
  2845 				        jsr _vbxe_write
  2846 				        cpx $4000
  2847 				        bne ?fnd
  2848 				        sec
  2849 0400			        .byte $24
  2850 0400			?fnd    clc
  2851 0400			?clr    lda #$00
  2852 0400			_vbxe_write
  2853 				        sta (fxptr),y
  2854 				        rts
  2855
  2856 				/*
  2857 					lda	#0
  2858 					ldx	#0xd6
  2859 					sta	0xd640			; make sure it isn't coincidence
  2860 					lda	0xd640
  2861 					cmp	#0x10			; do we have major version here?
  2862 					beq	VBXE_Detected		; if so, then VBXE is detected
  2863 					lda	#0
  2864 					inx
  2865 					sta	0xd740			; no such luck, try other location
  2866 					lda	0xd740
  2867 					cmp	#0x10
  2868 					beq	VBXE_Detected
  2869 					ldx 	#0  			; not here, so not present or FX core version too low
  2870 					stx	fxptr+1
  2871 					stx	fxptr
  2872
  2873 					sec
  2874 					rts
  2875
  2876 				VBXE_Detected
  2877 					stx	fxptr+1
  2878 					lda	#0
  2879 					sta	fxptr
  2880
  2881 					ldy	#VBXE_MINOR		; get core minor version
  2882 					lda	(fxptr),y
  2883
  2884 					clc
  2885 					rts	 			; x - page of vbxe
  2886 				*/
  2886
  2887
  2888 					.endl
  2889
  2890 				.endp
  2891
  2892
  2893 8C0F			.proc	@setxdl(.byte a) .reg
  2894 					idx = ctmp0
  2895 					asl @
  2896 					sta idx
  2897
  2898 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000
  2899
  2900 					ldy idx
  2901
  2902 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2903 					and msk,y
  2904 					ora val,y
  2905 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2906
  2907 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2908 					and msk+1,y
  2909 					ora val+1,y
  2910 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2911
  2912 					fxs FX_MEMS #0
  2913 					rts
  2914
  2915 8C0F			msk	.array [6] .word
  2916 					[e@xdl.mapon]  = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2917 					[e@xdl.mapoff] = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2918 					[e@xdl.ovron]  = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2919 					[e@xdl.ovroff] = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2920 					[e@xdl.hr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2921 					[e@xdl.lr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2922 					.enda
  2923
  2924 8C0F			val	.array [6] .word
  2925 					[e@xdl.mapon]  = XDLC_MAPON
  2926 					[e@xdl.mapoff] = XDLC_MAPOFF
  2927 					[e@xdl.ovron]  = XDLC_GMON
  2928 					[e@xdl.ovroff] = XDLC_OVOFF
  2929 					[e@xdl.hr]     = XDLC_GMON|XDLC_HR
  2930 					[e@xdl.lr]     = XDLC_GMON|XDLC_LR
  2931 					.enda
  2932
  2933 				.endp
  2934
  2935
  2936 8C0F			.proc	@vbxe_init
  2937
  2938 					fxs FX_MEMC #%1000+>MAIN.SYSTEM.VBXE_WINDOW	; $b000..$bfff (4K window), cpu on, antic off
  2939 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000	; enable VBXE BANK #0
  2940
  2941 					ldx #.sizeof(s@xdl)-1
  2942 					mva:rpl xdlist,x MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW,x-
  2943
  2944 					jsr cmapini		; init color map
  2945
  2946 					fxsa FX_P1		; A = 0
  2947 					fxsa FX_P2
  2948 					fxsa FX_P3
  2949
  2950 					fxsa FX_IRQ_CONTROL
  2951 					fxsa FX_BLITTER_START
  2952
  2953 					fxsa FX_XDL_ADR0	; XDLIST PROGRAM ADDRES (VBXE_XDLADR = $0000) = bank #0
  2954 					fxsa FX_XDL_ADR1
  2955 					fxsa FX_XDL_ADR2
  2956
  2957 					sta colpf0s
  2958
  2959 					fxs FX_P0 #$ff
  2960
  2961 					mwa #@vbxe_cmap @putchar.vbxe+1
  2962 					mva #{jsr*} @putchar.vbxe
  2963
  2964 					fxs FX_VIDEO_CONTROL #VC_XDL_ENABLED|VC_XCOLOR	;|VC_NO_TRANS
  2965
  2966 					rts
  2967
  2968 8C0F			cmapini	lda colpf1s
  2969 					and #$0f
  2970 					sta colpf1s
  2971
  2972 					lda #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2973 					sta ztmp
  2974
  2975 					mva #4 ztmp+1
  2976
  2977 8C0F			loop	fxs FX_MEMS ztmp
  2978
  2979 					lda >MAIN.SYSTEM.VBXE_WINDOW
  2980 					sta bp+1
  2981
  2982 					ldx #16
  2983 					ldy #0
  2984
  2985 8C0F			lop	mva #$00	(bp),y+
  2986 					mva colpf1s	(bp),y+
  2987 					mva colpf2s	(bp),y+
  2988 					mva #%00010000	(bp),y+		; overlay palette #1
  2989 					bne lop
  2990
  2991 					inc bp+1
  2992 					dex
  2993 					bne lop
  2994
  2995 					inc ztmp
  2996
  2997 					dec ztmp+1
  2998 					bne loop
  2999
  3000 					fxs FX_MEMS #$00		; disable VBXE BANK
  3001 					rts
  3002
  3003 				xdlist	dta s@xdl [0] (XDLC_RPTL, 24-1,\
  3004 					XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,\	;|XDLC_GMON,\
  3005 					192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,\
  3006 					MAIN.SYSTEM.VBXE_MAPADR, $100,\
  3007 					0, 0, 7, 7, %00010001, $ff)
  3007 8C0F			XDLIST	DTA S@XDL [0] (XDLC_RPTL, 24-1,	XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,	192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,	MAIN.SYSTEM.VBXE_MAPADR, $100,	0, 0, 7, 7, %00010001, $ff)
  3008 				.endp
  3009
  3010
  3011 8C0F			.proc	@vbxe_cmap
  3012
  3013 					pha
  3014
  3015 					cmp #eol
  3016 					beq stop
  3017
  3018 					cmp #$7d		; clrscr
  3019 					bne skp
  3020
  3021 					jsr @vbxe_init.cmapini
  3022 					jmp stop
  3023
  3024 8C0F			skp	lda rowcrs
  3025 					pha
  3026 8C0F				:4 lsr @
  3027 					add #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  3028 					fxsa FX_MEMS
  3029
  3030 					pla
  3031 					and #$0f
  3032 					add >MAIN.SYSTEM.VBXE_WINDOW
  3033 					sta bp+1
  3034
  3035 					lda colcrs
  3036 					asl @
  3037 					asl @
  3038 					tay
  3039 					mva colpf0s (bp),y
  3040 					iny
  3041 					mva colpf1s (bp),y
  3042 					iny
  3043 					mva colpf2s (bp),y
  3044
  3045 					fxs FX_MEMS #$00
  3046
  3047 8C0F			stop	pla
  3048
  3049 					rts
  3050 				.endp
  3051
  3052
  3053 				/* ----------------------------------------------------------------------- */
  3054
  3055
  3056 				/*
  3057 				.proc	@cmdline (.byte a) .reg
  3058
  3059 				parno	= ctmp0
  3060 				idpar	= ctmp1
  3061 				lbuf = cndx0
  3062 				hbuf = cndx1
  3063
  3064
  3065 					stx ctmp3
  3066
  3067 					sta idpar
  3068
  3069 					lda #0
  3070 					sta parno
  3071
  3072 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3073 					lsr
  3074 					bcc _no_command_line
  3075
  3076 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3077 					cmp #$c0
  3078 					bcs _no_command_line
  3079
  3080 					ldy #$03
  3081 					lda (dosvec),y
  3082 					cmp #{jmp}
  3083 					bne _no_command_line
  3084
  3085 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3086 					lda (dosvec),y
  3087 					sta lbuf
  3088 					iny
  3089 					lda (dosvec),y
  3090 					sta hbuf
  3091
  3092 					adw dosvec #3 cndx2
  3093
  3094 				loop	lda #0
  3095 					sta @buf
  3096 					JSR Call_Subroutine
  3097 					;jsr $ffff
  3098 				;;zcr	equ *-2
  3099 					beq stop
  3100
  3101 					lda idpar
  3102 					bne skp
  3103
  3104 					ldy #33			; ParamStr(0)
  3105 				_par0	lda (dosvec),y
  3106 					sta @buf-33+1,y
  3107 					iny
  3108 					cpy #36
  3109 					bne _par0
  3110
  3111 					lda #3
  3112 					sta @buf
  3113 					bne stop
  3114
  3115 				skp	ldy #36
  3116 				_cp	lda (dosvec),y
  3117 					sta @buf-36+1,y
  3118 					iny
  3119 					cmp #$9b
  3120 					bne _cp
  3121
  3122 					tya
  3123 					sub #37
  3124 					sta @buf
  3125
  3126 					inc parno
  3127 					lda parno
  3128 				;;; parno	equ *-1
  3129 					cmp idpar
  3130 				;;; idpar	equ *-1
  3131
  3132 					bne loop
  3133
  3134 				stop	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3135 					lda lbuf
  3136 				;; lbuf	equ *-1
  3137 					sta (dosvec),y
  3138 					iny
  3139 					lda hbuf
  3140 				;; hbuf	equ *-1
  3141 					sta (dosvec),y
  3142
  3143 				_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3144
  3145 					lda parno
  3146
  3147 					ldx ctmp3
  3148
  3149 					rts
  3150 				.endp
  3151 				*/
  3151
  3152
  3153
  3154 8C0F			.proc	@CmdLine (.byte a) .reg
  3155 				  arg_len = ctmp0 
  3156 					lbuf = ctmp1	
  3157 					parno	= ctmp2
  3158 					idpar	= cndx0
  3159 					hbuf = cndx1	
  3160 					
  3161 					stx ctmp3
  3162
  3163 					sta idpar
  3164
  3165 					lda #0
  3166 					sta parno
  3167 					sta loop+1
  3168
  3169 					lda	#{jsr*}
  3170 					sta	res
  3171
  3172 				; Get filename from SpartaDOS...
  3173 8C0F			get_param
  3174 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3175 					lsr
  3176 					bcc no_sparta
  3177
  3178 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3179 					cmp #$c0
  3180 					bcs no_sparta
  3181
  3182 					ldy #$03
  3183 					lda (dosvec),y
  3184 					cmp #{jmp}
  3185 					bne no_sparta
  3186
  3187 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3188 					lda (dosvec),y
  3189 					sta lbuf
  3190 					iny
  3191 					lda (dosvec),y
  3192 					sta hbuf
  3193
  3194 					adw dosvec #33 tmp
  3195
  3196 					ldy #0
  3197 8C0F			fnm	lda (tmp),y
  3198 					iny
  3199 					cmp #$9b
  3200 					bne fnm
  3201
  3202 					tya			; remove .COM
  3203 					sub #5
  3204 					tay
  3205 					lda #0
  3206 					sta (tmp),y
  3207 					tay
  3208
  3209 					lda	#3
  3210 					sta	loop+1
  3211 					add	dosvec
  3212 					sta	cndx2 ;get_adr
  3213 					lda	#0
  3214 					adc	dosvec+1
  3215 					sta	cndx3 ;get_adr+1
  3216
  3217 					jmp	_ok
  3218
  3219 8C0F			no_sparta
  3220 					mwa #next get_adr
  3221
  3222 					lda	#{bit*}
  3223 					sta	res
  3224
  3225 				; ... or channel #0
  3226 					lda	MAIN.IOCB@COPY+2	; command
  3227 					cmp	#5			; read line
  3228 					bne	_no_command_line
  3229 					lda	MAIN.IOCB@COPY+3	; status
  3230 					bmi	_no_command_line
  3231 				; don't assume the line is EOL-terminated
  3232 				; DOS II+/D overwrites the EOL with ".COM"
  3233 				; that's why we rely on the length
  3234 					lda	MAIN.IOCB@COPY+9	; length hi
  3235 					bne	_no_command_line
  3236 					ldx	MAIN.IOCB@COPY+8	; length lo
  3237 					beq	_no_command_line
  3238 					inx:inx
  3239 					stx	arg_len
  3240 				; give access to three bytes before the input buffer
  3241 				; in DOS II+/D the device prompt ("D1:") is there
  3242 					lda	MAIN.IOCB@COPY+4
  3243 					sub	#3
  3244 					sta	tmp
  3245 					lda	MAIN.IOCB@COPY+5
  3246 					sbc	#0
  3247 					sta	tmp+1
  3248
  3249 					lda	#0
  3250 					ldy	arg_len
  3251 					sta	(tmp),y
  3252
  3253
  3254 8C0F			loop	ldy	#0
  3255
  3256 8C0F			_ok	ldx	#0
  3257
  3258 8C0F			lprea	lda	(tmp),y
  3259 					sta	@buf+1,x
  3260
  3261 					beq	stop
  3262
  3263 					cmp	#$9b
  3264 					beq	stop
  3265 					cmp	#' '
  3266 					beq	stop
  3267
  3268 					iny
  3269 					inx
  3270 					cpx #32
  3271 					bne lprea
  3272
  3273 8C0F			stop	lda parno
  3274 					cmp idpar
  3275 					beq found
  3276 					JSR Call_Subroutine
  3277 					;jsr $ffff		; sty loop+1
  3278 				;get_adr	equ *-2
  3279 					beq found
  3280
  3281 					inc parno
  3282 					bne loop
  3283
  3284 8C0F			found	lda #0	;+$9b
  3285 					sta @buf+1,x
  3286 					stx @buf
  3287
  3288 8C0F			res	jsr sdxres
  3289
  3290 8C0F			_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3291
  3292 					lda parno
  3293
  3294 					ldx ctmp3
  3295
  3296 					rts
  3297
  3298
  3299 8C0F			sdxres	
  3300 				  ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3301 					lda lbuf
  3302 					sta (dosvec),y
  3303 					iny
  3304 					lda hbuf
  3305 				;;; hbuf	equ *-1
  3306 					sta (dosvec),y
  3307 					rts
  3308
  3309
  3310 8C0F			_next	iny
  3311 8C0F			next	lda (tmp),y
  3312 					beq _eol
  3313 					cmp #' '
  3314 					beq _next
  3315
  3316 					cmp #$9b
  3317 					beq _eol
  3318
  3319 					sty loop+1
  3320 					rts
  3321
  3322 8C0F			_eol	lda #0
  3323 					rts
  3324
  3325 				.endp
  3326
  3327
  3328 				/* ----------------------------------------------------------------------- */
  3329
  3330 				/*
  3331 				.proc	@rstsnd
  3332 					lda #0
  3333 					sta $d208
  3334 					sta $d218
  3335
  3336 					ldy #3
  3337 					sty $d20f
  3338 					sty $d21f
  3339 					rts
  3340 				.endp
  3341 				*/
  3341
  3342
  3343 				;	ert (*>$3fff) .and (*<$8000)
  3344
  3345
  3346 				/* ----------------------------------------------------------------------- */
  3347
  3348
  3349 8C0F			.proc	@xmsBank
  3350
  3351 = 00C2			ptr3 = eax			; position	(4)
  3352
  3353 					mva ptr3+3 ztmp+1	; position shr 14
  3354 					mva ptr3+2 ztmp
  3355 					lda ptr3+1
  3356
  3357 					.rept 6
  3358 					LSR ZTMP+1
  3359 					ROR ZTMP
  3360 					ROR @
  3361 					.ENDR
  3361 					.endr
Source: REPT
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
Source: cpu6502.asm
  3362
  3363 					tax			; index to bank
  3364
  3365 					lda portb
  3366 					and #1
  3367 					ora main.misc.adr.banks,x
  3368 					sta portb
  3369
  3370 					lda ptr3 		; offset
  3371 					sta ztmp
  3372 					lda ptr3+1
  3373 					and #$3f
  3374 					ora #$40
  3375 					sta ztmp+1
  3376
  3377 					rts
  3378 				.endp
  3379
  3380
  3381 8C0F			.proc	@xmsReadBuf (.word ptr1, ptr2) .var
  3382 					src = cndx2
  3383 					max = ctmp0
  3384 = 00C6			ptr1 = dx	; buffer	(2)
  3385
  3386 = 00CA			ptr2 = cx	; count		(2)
  3387 = 00CC			pos = cx+2	; position	(2) pointer
  3388
  3389 = 00C2			ptr3 = eax	; position	(4)
  3390
  3391 					txa:pha
  3392
  3393 					ldy #0
  3394 					lda (pos),y
  3395 					sta ptr3
  3396 					iny
  3397 					lda (pos),y
  3398 					sta ptr3+1
  3399 					iny
  3400 					lda (pos),y
  3401 					sta ptr3+2
  3402 					iny
  3403 					lda (pos),y
  3404 					sta ptr3+3
  3405
  3406 					lda ptr2+1
  3407 					beq lp2
  3408
  3409 8C0F			lp1	jsr @xmsBank
  3410
  3411 					lda ztmp+1
  3412 					cmp #$7f
  3413 					bne skp
  3414 					lda ztmp
  3415 					beq skp
  3416
  3417 					lda #0
  3418 					jsr nextBank
  3419 					jmp skp2
  3420
  3421 8C0F			skp	ldy #0
  3422 					mva:rne (ztmp),y @buf,y+
  3423
  3424 8C0F			skp2	lda portb
  3425 					and #1
  3426 					ora #$fe
  3427 					sta portb
  3428
  3429 					ldy #0
  3430 					mva:rne @buf,y (dx),y+
  3431
  3432 					inc dx+1	// inc(dx, $100)
  3433
  3434 					inl ptr3+1	// inc(position, $100)
  3435
  3436 					dec ptr2+1
  3437 					bne lp1
  3438
  3439 8C0F			lp2	jsr @xmsBank
  3440
  3441 					lda ztmp+1		; zakonczenie kopiowania
  3442 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3443 					bne skp_
  3444
  3445 					lda ztmp
  3446 					add ptr2
  3447 					bcc skp_
  3448
  3449 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3450 					jsr nextBank
  3451 					jmp skp3
  3452
  3453 8C0F			skp_	ldy #0
  3454 8C0F			mv	lda (ztmp),y
  3455 					sta @buf,y
  3456 					iny
  3457 					cpy ptr2
  3458 					bne mv
  3459
  3460 8C0F			skp3	lda portb
  3461 					and #1
  3462 					ora #$fe
  3463 					sta portb
  3464
  3465 					ldy #0
  3466 8C0F			lp3	lda @buf,y
  3467 					sta (dx),y
  3468 					iny
  3469 					cpy ptr2
  3470 					bne lp3
  3471
  3472 					jmp @xmsUpdatePosition
  3473
  3474 8C0F			.local	nextBank
  3475
  3476 					sta max
  3477
  3478 					mwa ztmp src
  3479
  3480 					ldy #0
  3481 8C0F			mv0	
  3482 				  lda (src),y
  3483 					sta @buf,y
  3484 					iny
  3485 					inc ztmp
  3486 					bne mv0
  3487
  3488 					lda portb
  3489 					and #1
  3490 					ora main.misc.adr.banks+1,x
  3491 					sta portb
  3492
  3493 					ldx #0
  3494 8C0F			mv1	
  3495 				  cpy max
  3496 					beq stp
  3497 					lda $4000,x
  3498 					sta @buf,y
  3499 					inx
  3500 					iny
  3501 					bne mv1
  3502 8C0F			stp	rts
  3503 				.endl
  3504
  3505 				.endp
  3506
  3507
  3508 8C0F			.proc	@xmsWriteBuf (.word ptr1, ptr2) .var
  3509 = 00EE			dst	= cndx0
  3510 = 00EB			max	= ctmp1
  3511 				 
  3512 = 00C6			ptr1 = dx	; buffer	(2)
  3513
  3514 = 00CA			ptr2 = cx	; count		(2)
  3515 = 00CC			pos = cx+2	; position	(2) pointer
  3516
  3517 = 00C2			ptr3 = eax	; position	(4)
  3518
  3519 					txa:pha
  3520
  3521 					ldy #0			; przepisz POSITION spod wskaznika
  3522 					lda (pos),y
  3523 					sta ptr3
  3524 					iny
  3525 					lda (pos),y
  3526 					sta ptr3+1
  3527 					iny
  3528 					lda (pos),y
  3529 					sta ptr3+2
  3530 					iny
  3531 					lda (pos),y
  3532 					sta ptr3+3
  3533
  3534 8C0F			lp1	lda portb		; wylacz dodatkowe banki
  3535 					and #1
  3536 					ora #$fe
  3537 					sta portb
  3538
  3539 					ldy #0			; przepisz 256b z BUFFER do @BUF
  3540 					mva:rne (dx),y @buf,y+
  3541
  3542 					jsr @xmsBank		; wlacz dodatkowy bank
  3543
  3544 					lda ptr2+1
  3545 					beq lp2
  3546
  3547 					lda ztmp+1		; jesli przekraczamy granice banku $7FFF
  3548 					cmp #$7f
  3549 					bne skp
  3550 					lda ztmp
  3551 					beq skp
  3552
  3553 					lda #0			; to realizuj wyjatek NEXTBANK, kopiuj 256b
  3554 					jsr nextBank
  3555 					jmp skp2
  3556
  3557 8C0F			skp	mva:rne @buf,y (ztmp),y+
  3558
  3559 8C0F			skp2	inc dx+1		// inc(dx, $100)
  3560
  3561 					inl ptr3+1		// inc(position, $100)
  3562
  3563 					dec ptr2+1
  3564 					bne lp1
  3565
  3566 8C0F			lp2	lda ztmp+1		; zakonczenie kopiowania
  3567 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3568 					bne skp_
  3569
  3570 					lda ztmp
  3571 					add ptr2
  3572 					bcc skp_
  3573
  3574 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3575 					jsr nextBank
  3576 					jmp quit
  3577
  3578 8C0F			skp_	ldy #0
  3579 8C0F			lp3	lda @buf,y
  3580 					sta (ztmp),y
  3581
  3582 					iny
  3583 					cpy ptr2
  3584 					bne lp3
  3585
  3586 8C0F			quit	lda portb
  3587 					and #1
  3588 					ora #$fe
  3589 					sta portb
  3590
  3591 					jmp @xmsUpdatePosition
  3592
  3593 8C0F			.local	nextBank
  3594 				  
  3595 					sta max
  3596
  3597 					mwa ztmp dst
  3598
  3599 					ldy #0
  3600 8C0F			mv0	lda @buf,y
  3601 					sta (dst),y
  3602 					
  3603 					iny
  3604 					inc ztmp
  3605 					bne mv0
  3606
  3607 					lda portb
  3608 					and #1
  3609 					ora main.misc.adr.banks+1,x
  3610 					sta portb
  3611
  3612 					ldx #0
  3613 8C0F			mv1	cpy max
  3614 					beq stp
  3615 					lda @buf,y
  3616 					sta $4000,x
  3617 					inx
  3618 					iny
  3619 					bne mv1
  3620 8C0F			stp	rts
  3621 				.endl
  3622
  3623 				.endp
  3624
  3625
  3626 8C0F			.proc	@xmsAddPosition
  3627
  3628 8C0F				.use @xmsReadBuf
  3629
  3630 					add ptr3
  3631 					sta ptr3
  3632 					lda #$00
  3633 					adc ptr3+1
  3634 					sta ptr3+1
  3635 					lda #$00
  3636 					adc ptr3+2
  3637 					sta ptr3+2
  3638 					lda #$00
  3639 					adc ptr3+3
  3640 					sta ptr3+3
  3641
  3642 					rts
  3643 				.endp
  3644
  3645
  3646 8C0F			.proc	@xmsUpdatePosition
  3647
  3648 8C0F				.use @xmsReadBuf
  3649
  3650 					tya
  3651 					jsr @xmsAddPosition
  3652
  3653 					ldy #0
  3654 					lda ptr3
  3655 					sta (pos),y
  3656 					iny
  3657 					lda ptr3+1
  3658 					sta (pos),y
  3659 					iny
  3660 					lda ptr3+2
  3661 					sta (pos),y
  3662 					iny
  3663 					lda ptr3+3
  3664 					sta (pos),y
  3665
  3666 					pla:tax
  3667 					rts
  3668 				.endp
  3669
  3670
  3671 				/* ----------------------------------------------------------------------- */
  3672
  3673
  3674 8C0F			.proc	@ClrScr
  3675
  3676 					ldx #$00
  3677 					lda #$0c
  3678 					jsr xcio
  3679
  3680 					mwa #ename ioadr,x
  3681
  3682 					mva #$0c ioaux1,x
  3683 					mva #$00 ioaux2,x
  3684
  3685 					lda #$03
  3686
  3687 8C0F			xcio	sta iocom,x
  3688 					jmp ciov
  3689
  3690 8C0F			ename	.byte 'E:',$9b
  3691
  3692 				.endp
  3693
  3694
  3695 				/* ----------------------------------------------------------------------- */
  3696
  3697 8C0F			Call_Subroutine
  3698 8C0F 6C F0 00				JMP (cndx2)
  3699
  3700
  3701
  3702 					opt l+
  2164
  2165 				; -----------------------------------------------------------
  2166
  2167 				.macro UNITINITIALIZATION
  2168 				
  2169 					.ifdef MAIN.SYSTEM.@UnitInit
  2170 					jsr MAIN.SYSTEM.@UnitInit
  2171 					eif
  2172 				
  2173 					.ifdef MAIN.ATARI.@UnitInit
  2174 					jsr MAIN.ATARI.@UnitInit
  2175 					eif
  2176 				
  2177 					.ifdef MAIN..@UnitInit
  2178 					jsr MAIN..@UnitInit
  2179 					eif
  2180 				
  2181 					.ifdef MAIN.B_SYSTEM.@UnitInit
  2182 					jsr MAIN.B_SYSTEM.@UnitInit
  2183 					eif
  2184 				
  2185 					.ifdef MAIN.SYSUTILS.@UnitInit
  2186 					jsr MAIN.SYSUTILS.@UnitInit
  2187 					eif
  2188 				
  2189 					.ifdef MAIN..@UnitInit
  2190 					jsr MAIN..@UnitInit
  2191 					eif
  2192 				
  2193 					.ifdef MAIN.B_CRT.@UnitInit
  2194 					jsr MAIN.B_CRT.@UnitInit
  2195 					eif
  2196 				.endm
  2197
  2198 					ift .SIZEOF(MAIN.SYSTEM) > 0
  2199 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  2199 				SYSTEM: $82CA..$8318
  2200 					eif
  2201
  2202 					ift .SIZEOF(MAIN.ATARI) > 0
  2203 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
  2204 					eif
  2205
  2206 					ift .SIZEOF(MAIN.B_SYSTEM) > 0
  2207 					.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
  2207 				B_SYSTEM: $8319..$8325
  2208 					eif
  2209
  2210 					ift .SIZEOF(MAIN.SYSUTILS) > 0
  2211 					.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
  2211 				SYSUTILS: $8326..$835C
  2212 					eif
  2213
  2214 					ift .SIZEOF(MAIN.B_CRT) > 0
  2215 					.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
  2215 				B_CRT: $835D..$85B4
  2216 					eif
  2217
  2218 					.print 'CODE: ',CODEORIGIN,'..',*-1
  2218 				CODE: $8000..$8C11
  2219
  2220 					org $A000
  2221
  2222 A000			DATAORIGIN
  2223
  2224 A000-A346> 28 00 18 00 + .by  $28 $00 $18 $00 $0C $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2225 A018 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2226 A030 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2227 A048 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2228 A060 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2229 A078 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2230 A090 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2231 A0A8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2232 A0C0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2233 A0D8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2234 A0F0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2235 A108 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2236 A120 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2237 A138 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2238 A150 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2239 A168 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2240 A180 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2241 A198 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2242 A1B0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2243 A1C8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2244 A1E0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2245 A1F8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2246 A210 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2247 A228 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2248 A240 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2249 A258 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2250 A270 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2251 A288 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2252 A2A0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2253 A2B8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2254 A2D0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2255 A2E8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2256 A300 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2257 A318 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2258 A330 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $9A $10 $00 $00 $00 $4C $1D $7C  $15 $AC $0D $C4 $09 $F4 $01
  2259
  2260 = 0347			VARINITSIZE	= *-DATAORIGIN
  2261 = 0354			VARDATASIZE	= 852
  2262
  2263 = A354			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  2264
  2265 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  2265 				DATA: $A000..$A354
  2266
  2267 02E0-02E1> 9D 82			run START
  2268
  2269 				; -----------------------------------------------------------
  2270
  2271 				.macro	STATICDATA
  2272 				.by  $00 $00 $27 $80 $80 $80 $80 $80  $80 $80 $80 $80 $80 $80 $80 $80  $80 $80 $AD $A9 $AE $A4 $80 $A6
  2273 				.by  $A9 $A5 $AC $A4 $80 $80 $80 $80  $80 $80 $80 $80 $80 $80 $80 $80  $80 $80 $00 $28 $00 $00 $00 $00
  2274 				.by  $00 $00 $00 $00 $00 $00 $00 $21  $34 $21 $32 $29 $00 $18 $0D $22  $29 $34 $00 $36 $25 $32 $33 $29
  2275 				.by  $2F $2E $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $28 $00 $30  $32 $2F $27 $32 $21 $2D $2D $29
  2276 				.by  $2E $27 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $30  $25 $34 $25 $32 $00 $2A $0E $00
  2277 				.by  $2D $25 $39 $25 $32 $00 $00 $28  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $08 $39
  2278 				.by  $2F $35 $32 $00 $2E $21 $2D $25  $00 $23 $2F $35 $2C $24 $00 $22  $25 $00 $28 $25 $32 $25 $09 $00
  2279 				.by  $00 $28 $00 $27 $32 $21 $30 $28  $29 $23 $33 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2280 				.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $28 $00 $33 $2F $35
  2281 				.by  $2E $24 $00 $21 $2E $24 $00 $2D  $35 $33 $29 $23 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2282 				.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $08 $33 $23  $2F $32 $25 $00 $1A $00 $00 $13
  2283 				.by  $34 $2F $24 $21 $39 $33 $00 $28  $29 $27 $28 $00 $33 $23 $2F $32  $25 $33 $0E $00 $02 $00 $1A $00
  2284 				.by  $15 $30 $32 $25 $33 $33 $00 $33  $34 $21 $32 $34 $00 $34 $2F $00  $22 $25 $27 $29 $2E $0E $00 $06
  2285 				.by  $33 $23 $2F $32 $25 $1A $00 $06  $2C $29 $36 $25 $33 $1A $00 $6C  $6A $3B $FF $FF $6B $2B $2A $6F
  2286 				.by  $FF $70 $75 $9B $69 $2D $3D $76  $FF $63 $FF $FF $62 $78 $7A $34  $FF $33 $36 $1B $35 $32 $31 $2C
  2287 				.by  $20 $2E $6E $FF $6D $2F $81 $72  $FF $65 $79 $7F $74 $77 $71 $39  $FF $30 $37 $7E $38 $3E $FF $66
  2288 				.by  $68 $64 $FF $82 $67 $73 $61 $4C  $4A $3A $FF $FF $4B $5C $5E $4F  $FF $50 $55 $FF $49 $5F $7C $56
  2289 				.by  $FF $43 $FF $FF $42 $58 $5A $24  $FF $23 $26 $FF $25 $22 $21 $5B  $3B $5D $4E $FF $4D $3F $FF $52
  2290 				.by  $FF $45 $59 $FF $54 $57 $51 $28  $FF $29 $27 $FF $40 $FF $FF $46  $48 $44 $FF $FF $47 $53 $41 $FF
  2291 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  2292 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  2293 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  2294 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  2295 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  2296 				.by  $FF $FF $FF $FF $FF $FF $FF $70  $70 $44 $00 $10 $04 $04 $04 $04  $04 $00 $04 $00 $04 $00 $04 $00
  2297 				.by  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $00
  2298 				.by  $04 $00 $04 $00 $04 $00 $04 $41  $47 $82 $70 $70 $44 $00 $10 $10  $04 $04 $04 $04 $04 $04 $04 $04
  2299 				.by  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $41 $7A $82
  2300 				.endm
  2301
  2302 					end
