mads 2.0.8 build 1 (2 Nov 17)
Source: Mind Field.a65
     1 = 0010			STACKWIDTH	= 16
     2 = 8000			CODEORIGIN	= $8000
     3
     4 = 0001			TRUE		= 1
     5 = 0000			FALSE		= 0
     6
     7 					org $C0
     8
     9 					.print 'ZPFREE: $0000..',*-1
     9 				ZPFREE: $0000..$00BF
    10
    11 = 00C0			fxptr	.ds 2
    12
    13 = 00C2			eax	.ds 4						;8 bytes (aex + edx) -> divREAL
    14 = 00C6			edx	.ds 4
    15 = 00CA			ecx	.ds 4
    16 = 00CE			bp	.ds 2
    17 = 00D0			bp2	.ds 2
    18
    19 				ztmp
    20 = 00D2			ztmp8	.ds 1
    21 = 00D3			ztmp9	.ds 1
    22 = 00D4			ztmp10	.ds 1
    23 = 00D5			ztmp11	.ds 1
    24
    25 = 00D6			TMP	.ds 2
    26
    27 					org $0080
    28
    29 = 0080			STACKORIGIN	.ds STACKWIDTH*4
    30
    31 					.print 'ZPFREE: ',*,'..',$ff
    31 				ZPFREE: $00C0..$00FF
    32
    33 = 00C2			ax	= eax
    34 = 00C2			al	= eax
    35 = 00C3			ah	= eax+1
    36
    37 = 00CA			cx	= ecx
    38 = 00CA			cl	= ecx
    39 = 00CB			ch	= ecx+1
    40
    41 = 00C6			dx	= edx
    42 = 00C6			dl	= edx
    43 = 00C7			dh	= edx+1
    44
    45 					org eax
    46
    47 = 00C2			FP1MAN0	.ds 1
    48 = 00C3			FP1MAN1	.ds 1
    49 = 00C4			FP1MAN2	.ds 1
    50 = 00C5			FP1MAN3	.ds 1
    51
    52 					org ztmp8
    53
    54 = 00D2			FP1SGN	.ds 1
    55 = 00D3			FP1EXP	.ds 1
    56
    57 					org edx
    58
    59 = 00C6			FP2MAN0	.ds 1
    60 = 00C7			FP2MAN1	.ds 1
    61 = 00C8			FP2MAN2	.ds 1
    62 = 00C9			FP2MAN3	.ds 1
    63
    64 					org ztmp10
    65
    66 = 00D4			FP2SGN	.ds 1
    67 = 00D5			FP2EXP	.ds 1
    68
    69 					org ecx
    70
    71 = 00CA			FPMAN0	.ds 1
    72 = 00CB			FPMAN1	.ds 1
    73 = 00CC			FPMAN2	.ds 1
    74 = 00CD			FPMAN3	.ds 1
    75
    76 					org bp2
    77
    78 = 00D0			FPSGN	.ds 1
    79 = 00D1			FPEXP	.ds 1
    80
    81 				.local	RESOURCE
    82 					icl 'res6502.asm'
Source: res6502.asm
     1
  1103 					opt l+
    83
    84 8000				RCDATA 'MINDFIELD.FNT' CHARSET_GAME 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0400			len = .filesize('MINDFIELD.FNT')
    17 					org main.CHARSET_GAME
    19 FFFF> A400-AD3F> 00 00 + 	ins 'MINDFIELD.FNT'
Source: Mind Field.a65
    85 A800				RCDATA 'MIND FIELD TITLE.FNT' CHARSET_TITLE 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0400			len = .filesize('MIND FIELD TITLE.FNT')
    17 A800				org main.CHARSET_TITLE
    19 A800 00 00 00 00 00 00 + 	ins 'MIND FIELD TITLE.FNT'
Source: Mind Field.a65
    86 AC00				RCDATA 'Mind Field Title Screen.txt' TITLE_DATA 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0140			len = .filesize('Mind Field Title Screen.txt')
    17 AC00				org main.TITLE_DATA
    19 AC00 00 00 00 00 00 00 + 	ins 'Mind Field Title Screen.txt'
Source: Mind Field.a65
    87 				.endl
    88
    89 				; -----------------------------------------------------------
    90
    91 AD40				org CODEORIGIN
    92
    93 8000				STATICDATA
Macro: STATICDATA [Source: Mind Field.a65]
     1 8000-8C78> 00 00 28 00 + .by  $00 $00 $28 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $21 $34  $21 $32 $29 $00 $18 $0D $22 $29
     2 8018 34 00 36 25 32 33 + .by  $34 $00 $36 $25 $32 $33 $29 $2F  $2E $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $28 $00 $30 $32
     3 8030 2F 27 32 21 2D 2D + .by  $2F $27 $32 $21 $2D $2D $29 $2E  $27 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $30 $25
     4 8048 34 25 32 00 2A 0E + .by  $34 $25 $32 $00 $2A $0E $00 $2D  $25 $39 $25 $32 $00 $00 $28 $00  $00 $00 $00 $00 $00 $00 $00 $00
     5 8060 00 00 00 00 00 08 + .by  $00 $00 $00 $00 $00 $08 $39 $2F  $35 $32 $00 $2E $21 $2D $25 $00  $23 $2F $35 $2C $24 $00 $22 $25
     6 8078 00 28 25 32 25 09 + .by  $00 $28 $25 $32 $25 $09 $00 $00  $28 $00 $27 $32 $21 $30 $28 $29  $23 $33 $00 $00 $00 $00 $00 $00
     7 8090 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
     8 80A8 00 00 28 00 33 2F + .by  $00 $00 $28 $00 $33 $2F $35 $2E  $24 $00 $21 $2E $24 $00 $2D $35  $33 $29 $23 $00 $00 $00 $00 $00
     9 80C0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $08 $33 $23 $2F
    10 80D8 32 25 00 1A 00 00 + .by  $32 $25 $00 $1A $00 $00 $13 $34  $2F $24 $21 $39 $33 $00 $28 $29  $27 $28 $00 $33 $23 $2F $32 $25
    11 80F0 33 0E 00 02 00 1A + .by  $33 $0E $00 $02 $00 $1A $00 $15  $30 $32 $25 $33 $33 $00 $33 $34  $21 $32 $34 $00 $34 $2F $00 $22
    12 8108 25 27 29 2E 0E 00 + .by  $25 $27 $29 $2E $0E $00 $06 $33  $23 $2F $32 $25 $1A $00 $06 $2C  $29 $36 $25 $33 $1A $00 $6C $6A
    13 8120 3B FF FF 6B 2B 2A + .by  $3B $FF $FF $6B $2B $2A $6F $FF  $70 $75 $9B $69 $2D $3D $76 $FF  $63 $FF $FF $62 $78 $7A $34 $FF
    14 8138 33 36 1B 35 32 31 + .by  $33 $36 $1B $35 $32 $31 $2C $20  $2E $6E $FF $6D $2F $81 $72 $FF  $65 $79 $7F $74 $77 $71 $39 $FF
    15 8150 30 37 7E 38 3E FF + .by  $30 $37 $7E $38 $3E $FF $66 $68  $64 $FF $82 $67 $73 $61 $4C $4A  $3A $FF $FF $4B $5C $5E $4F $FF
    16 8168 50 55 FF 49 5F 7C + .by  $50 $55 $FF $49 $5F $7C $56 $FF  $43 $FF $FF $42 $58 $5A $24 $FF  $23 $26 $FF $25 $22 $21 $5B $3B
    17 8180 5D 4E FF 4D 3F FF + .by  $5D $4E $FF $4D $3F $FF $52 $FF  $45 $59 $FF $54 $57 $51 $28 $FF  $29 $27 $FF $40 $FF $FF $46 $48
    18 8198 44 FF FF 47 53 41 + .by  $44 $FF $FF $47 $53 $41 $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    19 81B0 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    20 81C8 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    21 81E0 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    22 81F8 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
    23 8210 FF FF FF FF FF FF + .by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $70 $C0  $44 $00 $AC $04 $04 $04 $04 $04
    24 8228 04 84 00 44 00 08 + .by  $04 $84 $00 $44 $00 $08 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04
    25 8240 00 04 00 04 00 04 + .by  $00 $04 $00 $04 $00 $04 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04  $41 $1E $82 $70 $70 $44 $00 $08
    26 8258 10 04 04 04 04 04 + .by  $10 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04
    27 8270 04 04 04 41 53 82	.by  $04 $04 $04 $41 $53 $82
Source: Mind Field.a65
    94
    95 8276			START
    96 8276 BA				tsx
    97 8277 8E 60 8A			stx MAIN.@halt+1
    98
    99 					.ifdef fmulinit
   100 					fmulinit
   101 					eif
   102
   103 					ift DATAORIGIN+VARINITSIZE > $BFFF
   104 					ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
   105 					els
   106 					@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
   106 				 MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1\ MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3\ MVA #0 @FILL.PTR2\ JSR @FILL
   106 827A A9 47 85 C6 A9 A3 +  MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1
   106 8282 A9 0D 85 CA A9 00 +  MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3
   106 828A A9 00 85 C2		 MVA #0 @FILL.PTR2
   106 828E 20 2E 8C		 JSR @FILL
   107 					eif
   108
   109 8291 A2 0F			ldx #$0f
   110 8293 BD 40 03 9D 63 8A + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   111
   112 829C A2 00 86 CE			mvx #$00 bp					; lo BP = 0, X = 0 !!!
   113
   114 82A0				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: Mind Field.a65]
Source: Mind Field.a65
   115
   116 82A0			.local	MAIN						; PROCEDURE
   117
   118 					ift l_0125-*>3
   119 82A0 4C DC 89			jmp l_0125
   120 					eif
   121
   122 				; -----------------------------------------------------------
   123
   124 82A3			.local	SYSTEM						; UNIT
   125
   126 82A3			.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER
   127
   128 				; -----------------------------------------------------------
   129
   130 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   131 				; as Pointer
   132 82A3 B5 80 85 CA			mva :STACKORIGIN,x VALUE
   133 82A7 CA				dex						; sub bx, 1
   134
   135 				; -----------------------------------------------------------
   136
   137 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   138 				; as Pointer
   139 82A8 B5 80 85 C6			mva :STACKORIGIN,x A
   140 82AC B5 90 85 C7			mva :STACKORIGIN+STACKWIDTH,x A+1
   141 82B0 CA				dex						; sub bx, 1
   142
   143
   144 				; ---------------------  ASM Block 021  ---------------------
   145
   146 82B1 A0 00			ldy #0
   147 82B3 A5 CA 91 C6			mva value (edx),y
   148
   149
   150 				; -----------------------------------------------------------
   151
   152 = 00C6			A	= edx
   153 = 00CA			VALUE	= ecx
   154
   155 82B7			@exit
   156 					.ifdef @new
   157 					@FreeMem #@VarData #@VarDataSize
   158 					eif
   159 82B7 60				rts						; ret
   160 				.endl
   161
   162 82B8			.local	FILLCHAR_014C					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   163
   164 				; -----------------------------------------------------------
   165
   166 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   167 				; as Pointer
   168 82B8 B5 80 85 C2			mva :STACKORIGIN,x VALUE
   169 82BC CA				dex						; sub bx, 1
   170
   171 				; -----------------------------------------------------------
   172
   173 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   174 				; as Pointer
   175 82BD B5 80 85 CA			mva :STACKORIGIN,x COUNT
   176 82C1 B5 90 85 CB			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   177 82C5 CA				dex						; sub bx, 1
   178
   179 				; -----------------------------------------------------------
   180
   181 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   182 				; as Pointer
   183 82C6 B5 80 85 C6			mva :STACKORIGIN,x A
   184 82CA B5 90 85 C7			mva :STACKORIGIN+STACKWIDTH,x A+1
   185 82CE CA				dex						; sub bx, 1
   186
   187
   188 				; ---------------------  ASM Block 024  ---------------------
   189
   190 82CF 20 2E 8C			jsr @fill
   191
   192
   193 				; -----------------------------------------------------------
   194
   195 = 00C6			A	= edx
   196 = 00CA			COUNT	= ecx
   197 = 00C2			VALUE	= eax
   198
   199 82D2			@exit
   200 					.ifdef @new
   201 					@FreeMem #@VarData #@VarDataSize
   202 					eif
   203 82D2 60				rts						; ret
   204 				.endl
   205
   206 82D3			.local	MOVE_015F					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   207
   208 				; -----------------------------------------------------------
   209
   210 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   211 				; as Pointer
   212 82D3 B5 80 85 C2			mva :STACKORIGIN,x COUNT
   213 82D7 B5 90 85 C3			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   214 82DB CA				dex						; sub bx, 1
   215
   216 				; -----------------------------------------------------------
   217
   218 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   219 				; as Pointer
   220 82DC B5 80 85 CA			mva :STACKORIGIN,x DEST
   221 82E0 B5 90 85 CB			mva :STACKORIGIN+STACKWIDTH,x DEST+1
   222 82E4 CA				dex						; sub bx, 1
   223
   224 				; -----------------------------------------------------------
   225
   226 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   227 				; as Pointer
   228 82E5 B5 80 85 C6			mva :STACKORIGIN,x SOURCE
   229 82E9 B5 90 85 C7			mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
   230 82ED CA				dex						; sub bx, 1
   231
   232
   233 				; ---------------------  ASM Block 033  ---------------------
   234
   235 82EE 20 DA 8B			jsr @move
   236
   237
   238 				; -----------------------------------------------------------
   239
   240 = 00C6			SOURCE	= edx
   241 = 00CA			DEST	= ecx
   242 = 00C2			COUNT	= eax
   243
   244 82F1			@exit
   245 					.ifdef @new
   246 					@FreeMem #@VarData #@VarDataSize
   247 					eif
   248 82F1 60				rts						; ret
   249 				.endl
   250
   251 				; -----------------------------------------------------------
   252
   253 = 0648			M_PI_2	= $0648
   254 = 0192			D_PI_2	= $0192
   255 = 0004			D_PI_180	= $0004
   256 = 0000			MGTIA	= $0000
   257 = 0080			MVBXE	= $0080
   258 = 0010			WINDOW	= $0010
   259 = 0020			NARROW	= $0020
   260 = 0000			VBXE_XDLADR	= $0000
   261 = 0100			VBXE_BCBADR	= $0100
   262 = 1000			VBXE_MAPADR	= $1000
   263 = 5000			VBXE_OVRADR	= $5000
   264 = B000			VBXE_WINDOW	= $B000
   265 = 0000			IDLI	= $0000
   266 = 0001			IVBL	= $0001
   267 = 00FE			CH_DELCHR	= $00FE
   268 = 009B			CH_ENTER	= $009B
   269 = 001B			CH_ESC	= $001B
   270 = 001C			CH_CURS_UP	= $001C
   271 = 001D			CH_CURS_DOWN	= $001D
   272 = 001E			CH_CURS_LEFT	= $001E
   273 = 001F			CH_CURS_RIGHT	= $001F
   274 = 007F			CH_TAB	= $007F
   275 = 009B			CH_EOL	= $009B
   276 = 007D			CH_CLR	= $007D
   277 = 00FD			CH_BELL	= $00FD
   278 = 007E			CH_DEL	= $007E
   279 = 009C			CH_DELLINE	= $009C
   280 = 009D			CH_INSLINE	= $009D
   281 = 0000			COLOR_BLACK	= $0000
   282 = 000E			COLOR_WHITE	= $000E
   283 = 0032			COLOR_RED	= $0032
   284 = 0096			COLOR_CYAN	= $0096
   285 = 0068			COLOR_VIOLET	= $0068
   286 = 00C4			COLOR_GREEN	= $00C4
   287 = 0074			COLOR_BLUE	= $0074
   288 = 00EE			COLOR_YELLOW	= $00EE
   289 = 004A			COLOR_ORANGE	= $004A
   290 = 00E4			COLOR_BROWN	= $00E4
   291 = 003C			COLOR_LIGHTRED	= $003C
   292 = 0004			COLOR_GRAY1	= $0004
   293 = 0006			COLOR_GRAY2	= $0006
   294 = 000A			COLOR_GRAY3	= $000A
   295 = 00CC			COLOR_LIGHTGREEN	= $00CC
   296 = 007C			COLOR_LIGHTBLUE	= $007C
   297 = 0004			FMOPENREAD	= $0004
   298 = 0008			FMOPENWRITE	= $0008
   299 = 0009			FMOPENAPPEND	= $0009
   300 = 000C			FMOPENREADWRITE	= $000C
   301 = A000			SCREENWIDTH	= DATAORIGIN+$0000
   302 = A002			SCREENHEIGHT	= DATAORIGIN+$0002
   303 = A004			FILEMODE	= DATAORIGIN+$0004
   304 = A005			SCREENMODE	= DATAORIGIN+$0005
   305 = A006			IORESULT	= DATAORIGIN+$0006
   306 = A007			EOLN	= DATAORIGIN+$0007
   307 = A008			RNDSEED	= DATAORIGIN+$0008
   308
   309 				.endl							; UNIT SYSTEM
   310
   311 				; -----------------------------------------------------------
   312
   313 82F2			.local	ATARI						; UNIT
   314
   315 				; -----------------------------------------------------------
   316
   317 = 0012			RTCLOK	= $0012
   318 = 004D			ATRACT	= $004D
   319 = 0052			LMARGIN	= $0052
   320 = 0053			RMARGIN	= $0053
   321 = 0054			ROWCRS	= $0054
   322 = 0055			COLCRS	= $0055
   323 = 0057			DINDEX	= $0057
   324 = 0058			SAVMSC	= $0058
   325 = 0200			VDSLST	= $0200
   326 = 0202			VPRCED	= $0202
   327 = 0204			VINTER	= $0204
   328 = 0206			VBREAK	= $0206
   329 = 0208			VKEYBD	= $0208
   330 = 020A			VSERIN	= $020A
   331 = 020C			VSEROR	= $020C
   332 = 020E			VSEROC	= $020E
   333 = 0210			VTIMR1	= $0210
   334 = 0212			VTIMR2	= $0212
   335 = 0214			VTIMR3	= $0214
   336 = 0216			VIMIRQ	= $0216
   337 = 0218			CDTMV1	= $0218
   338 = 021A			CDTMV2	= $021A
   339 = 021C			CDTMV3	= $021C
   340 = 022E			CDTMV4	= $022E
   341 = 0220			CDTMV5	= $0220
   342 = 0222			VVBLKI	= $0222
   343 = 0224			VVBLKD	= $0224
   344 = 0226			CDTMA1	= $0226
   345 = 0228			CDTMA2	= $0228
   346 = 022F			SDNCTK	= $022F
   347 = 0230			SDLSTW	= $0230
   348 = 0230			SDLSTL	= $0230
   349 = 0231			SDLSTH	= $0231
   350 = 0290			TXTROW	= $0290
   351 = 0291			TXTCOL	= $0291
   352 = 0293			TINDEX	= $0293
   353 = 0294			TXTMSC	= $0294
   354 = 022F			SDMCTL	= $022F
   355 = 026F			GPRIOR	= $026F
   356 = 02F0			CRSINH	= $02F0
   357 = 02F3			CHACT	= $02F3
   358 = 02F4			CHBAS	= $02F4
   359 = 02FC			CH	= $02FC
   360 = 02C0			PCOLR0	= $02C0
   361 = 02C1			PCOLR1	= $02C1
   362 = 02C2			PCOLR2	= $02C2
   363 = 02C3			PCOLR3	= $02C3
   364 = 02C4			COLOR0	= $02C4
   365 = 02C5			COLOR1	= $02C5
   366 = 02C6			COLOR2	= $02C6
   367 = 02C7			COLOR3	= $02C7
   368 = 02C8			COLOR4	= $02C8
   369 = D000			HPOSP0	= $D000
   370 = D001			HPOSP1	= $D001
   371 = D002			HPOSP2	= $D002
   372 = D003			HPOSP3	= $D003
   373 = D004			HPOSM0	= $D004
   374 = D005			HPOSM1	= $D005
   375 = D006			HPOSM2	= $D006
   376 = D007			HPOSM3	= $D007
   377 = D008			SIZEP0	= $D008
   378 = D009			SIZEP1	= $D009
   379 = D00A			SIZEP2	= $D00A
   380 = D00B			SIZEP3	= $D00B
   381 = D00C			SIZEM	= $D00C
   382 = D00D			GRAFP0	= $D00D
   383 = D00E			GRAFP1	= $D00E
   384 = D00F			GRAFP2	= $D00F
   385 = D010			GRAFP3	= $D010
   386 = D011			GRAFM	= $D011
   387 = D014			PAL	= $D014
   388 = D012			COLPM0	= $D012
   389 = D013			COLPM1	= $D013
   390 = D014			COLPM2	= $D014
   391 = D015			COLPM3	= $D015
   392 = D016			COLPF0	= $D016
   393 = D017			COLPF1	= $D017
   394 = D018			COLPF2	= $D018
   395 = D019			COLPF3	= $D019
   396 = D01A			COLBK	= $D01A
   397 = D01B			PRIOR	= $D01B
   398 = D01D			GRACTL	= $D01D
   399 = D01E			HITCLR	= $D01E
   400 = D01F			CONSOL	= $D01F
   401 = D200			AUDF1	= $D200
   402 = D201			AUDC1	= $D201
   403 = D202			AUDF2	= $D202
   404 = D203			AUDC2	= $D203
   405 = D204			AUDF3	= $D204
   406 = D205			AUDC3	= $D205
   407 = D206			AUDF4	= $D206
   408 = D207			AUDC4	= $D207
   409 = D208			AUDCTL	= $D208
   410 = D209			STIMER	= $D209
   411 = D20A			SKRES	= $D20A
   412 = D20B			POTGO	= $D20B
   413 = D20D			SEROUT	= $D20D
   414 = D20E			IRQEN	= $D20E
   415 = D20F			SKCTL	= $D20F
   416 = D20F			SKSTAT	= $D20F
   417 = D200			POT0	= $D200
   418 = D201			POT1	= $D201
   419 = D202			POT2	= $D202
   420 = D203			POT3	= $D203
   421 = D204			POT4	= $D204
   422 = D205			POT5	= $D205
   423 = D206			POT6	= $D206
   424 = D207			POT7	= $D207
   425 = D208			ALLPOT	= $D208
   426 = D208			POTST	= $D208
   427 = D209			KBCODE	= $D209
   428 = D20A			RANDOM	= $D20A
   429 = D20D			SERIN	= $D20D
   430 = D20E			IRQST	= $D20E
   431 = D300			PORTA	= $D300
   432 = D301			PORTB	= $D301
   433 = D302			PCCTL	= $D302
   434 = D303			PBCTL	= $D303
   435 = D400			DMACTL	= $D400
   436 = D401			CHACTL	= $D401
   437 = D402			DLISTW	= $D402
   438 = D402			DLISTL	= $D402
   439 = D403			DLISTH	= $D403
   440 = D404			HSCROL	= $D404
   441 = D405			VSCROL	= $D405
   442 = D407			PMBASE	= $D407
   443 = D409			CHBASE	= $D409
   444 = D40A			WSYNC	= $D40A
   445 = D40B			VCOUNT	= $D40B
   446 = D40C			PENH	= $D40C
   447 = D40D			PENV	= $D40D
   448 = D40E			NMIEN	= $D40E
   449 = D40F			NMIRES	= $D40F
   450 = D40F			NMIST	= $D40F
   451
   452 				.endl							; UNIT ATARI
   453
   454 				; -----------------------------------------------------------
   455
   456 82F2			.local	B_SYSTEM					; UNIT
   457
   458 82F2			.local	SETCHARSET					; PROCEDURE
   459
   460 				; -----------------------------------------------------------
   461
   462 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   463 				; as Pointer
   464 82F2 B5 80 8D 0B A0		mva :STACKORIGIN,x MSB
   465 82F7 CA				dex						; sub bx, 1
   466
   467 					ift l_0185-*>3
   468 					jmp l_0185
   469 					eif
   470
   471 				; IfThenEpilog
   472 82F8			l_0185
   473
   474 				; optimize OK (B_SYSTEM), line = 218
   475
   476 82F8 AD 0B A0 8D 09 D4		mva MSB ATARI.CHBASE
   477
   478 				; -----------------------------------------------------------
   479
   480 = A00B			MSB	= DATAORIGIN+$000B
   481
   482 = A00B			@VarData	= MSB
   483 = 0001			@VarDataSize	= 1
   484
   485
   486 82FE			@exit
   487 					.ifdef @new
   488 					@FreeMem #@VarData #@VarDataSize
   489 					eif
   490 82FE 60				rts						; ret
   491 				.endl
   492
   493 				; -----------------------------------------------------------
   494
   495 = A00A			__NMIEN	= DATAORIGIN+$000A
   496 = 0080			PORTB_SELFTEST_OFF	= $0080
   497 = 0002			PORTB_BASIC_OFF	= $0002
   498 = 0001			PORTB_SYSTEM_ON	= $0001
   499
   500 				.endl							; UNIT B_SYSTEM
   501
   502 				; -----------------------------------------------------------
   503
   504 82FF			.local	SYSUTILS					; UNIT
   505
   506 82FF			.local	INTTOSTR					; FUNCTION | ASSEMBLER
   507
   508 				; -----------------------------------------------------------
   509
   510 				; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
   511 				; as Pointer
   512 82FF B5 80 8D 0C A0		mva :STACKORIGIN,x A
   513 8304 B5 90 8D 0D A0		mva :STACKORIGIN+STACKWIDTH,x A+1
   514 8309 B5 A0 8D 0E A0		mva :STACKORIGIN+STACKWIDTH*2,x A+2
   515 830E B5 B0 8D 0F A0		mva :STACKORIGIN+STACKWIDTH*3,x A+3
   516 8313 CA				dex						; sub bx, 1
   517
   518
   519 				; ---------------------  ASM Block 060  ---------------------
   520
   521 8314 8A 48			txa:pha
   522
   523 8316 E8				inx
   524
   525 					@ValueToStr #@printINT
   525 				 LDY> @PRINTINT\ LDA< @PRINTINT\ JSR @VALUETOSTR
   525 8317 A0 8A		 LDY> @PRINTINT
   525 8319 A9 FE		 LDA< @PRINTINT
   525 831B 20 89 8B		 JSR @VALUETOSTR
   526
   527 831E A9 00 8D 10 A0 A9 + 	mwa #@buf Result
   528
   529 8328 68 AA			pla:tax
   530
   531
   532 832A			@exit
   533
   534 				; -----------------------------------------------------------
   535
   536 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   537 				; as Pointer
   538
   539 832A E8				inx						; add bx, 1
   540 832B AD 10 A0 95 80		mva RESULT :STACKORIGIN,x
   541 8330 AD 11 A0 95 90		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   542
   543 					.ifdef @new
   544 					@FreeMem #@VarData #@VarDataSize
   545 					eif
   546
   547 				; -----------------------------------------------------------
   548
   549 = A00C			A	= DATAORIGIN+$000C
   550 = A010			RESULT	= DATAORIGIN+$0010
   551
   552 = A00C			@VarData	= A
   553 = 0006			@VarDataSize	= 6
   554
   555 8335 60				rts						; ret
   556 				.endl
   557
   558 				; -----------------------------------------------------------
   559
   560 = 0001			FAREADONLY	= $0001
   561 = 0002			FAHIDDEN	= $0002
   562 = 0004			FASYSFILE	= $0004
   563 = 0008			FAVOLUMEID	= $0008
   564 = 0010			FADIRECTORY	= $0010
   565 = 0020			FAARCHIVE	= $0020
   566 = 003F			FAANYFILE	= $003F
   567
   568 				.endl							; UNIT SYSUTILS
   569
   570 				; -----------------------------------------------------------
   571
   572 8336			.local	B_CRT						; UNIT
   573
   574 8336			.local	ATASCII2ANTIC_01A6				; FUNCTION | OVERLOAD
   575
   576 				; -----------------------------------------------------------
   577
   578 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   579 				; as Pointer
   580 8336 B5 80 8D 1B A0		mva :STACKORIGIN,x C
   581 833B CA				dex						; sub bx, 1
   582
   583 					ift l_01AF-*>3
   584 					jmp l_01AF
   585 					eif
   586
   587 				; IfThenEpilog
   588 833C			l_01AF
   589
   590 				; ---------------------  ASM Block 064  ---------------------
   591
   592
   593 833C AD 1B A0		        lda c
   594 833F 0A			        asl
   595 8340 08			        php
   596 8341 C9 C0		        cmp #2*$60
   597 8343 B0 06		        bcs @+
   598 8345 E9 3F		        sbc #2*$20-1
   599 8347 B0 02		        bcs @+
   600 8349 69 C0		        adc #2*$60
   601 834B 28			@       plp
   602 834C 6A			        ror
   603 834D 8D 1C A0		        sta result;
   604 				    
   605
   606 8350			@exit
   607
   608 				; -----------------------------------------------------------
   609
   610 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   611 				; as Pointer
   612
   613 8350 E8				inx						; add bx, 1
   614 8351 AD 1C A0 95 80		mva RESULT :STACKORIGIN,x
   615
   616 					.ifdef @new
   617 					@FreeMem #@VarData #@VarDataSize
   618 					eif
   619
   620 				; -----------------------------------------------------------
   621
   622 = A01B			C	= DATAORIGIN+$001B
   623 = A01C			RESULT	= DATAORIGIN+$001C
   624
   625 = A01B			@VarData	= C
   626 = 0002			@VarDataSize	= 2
   627
   628 8356 60				rts						; ret
   629 				.endl
   630
   631 8357			.local	ATASCII2ANTIC_01B3				; FUNCTION | OVERLOAD
   632
   633 				; -----------------------------------------------------------
   634
   635 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   636 				; as Pointer
   637 8357 B5 80 8D D6 83		mva :STACKORIGIN,x S
   638 835C B5 90 8D D7 83		mva :STACKORIGIN+STACKWIDTH,x S+1
   639 8361 CA				dex						; sub bx, 1
   640 					@move S #adr.S #256
   640 				 MWA S @MOVE.PTR1\ MWA #ADR.S @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
   640 8362 AD D6 83 85 C6 AD +  MWA S @MOVE.PTR1
   640 836C A9 1D 85 CA A9 A0 +  MWA #ADR.S @MOVE.PTR2
   640 8374 A9 00 85 C2 A9 01 +  MWA #256 @MOVE.PTR3
   640 837C 20 DA 8B		 JSR @MOVE
   641 837F A9 1D 8D D6 83 A9 + 	mwa #adr.S S
   642
   643 					ift l_01BC-*>3
   644 					jmp l_01BC
   645 					eif
   646
   647 				; IfThenEpilog
   648 8389			l_01BC
   649
   650 				; optimize OK (B_CRT), line = 468
   651
   652 8389 AD 1D A0			lda adr.S+$00
   653 838C 8D 1D A1			sta adr.RESULT+$00
   654 				; For
   655
   656 				; optimize OK (B_CRT), line = 469
   657
   658 838F A9 01 8D 1D A2		mva #$01 I
   659
   660 				; optimize OK (B_CRT), line = 469
   661
   662 8394 AD 1D A0			lda adr.S+$00
   663 8397 8D 1E A2			sta @FORTMP_464
   664 				; To
   665 839A			l_01D6
   666
   667 				; ForToDoCondition
   668
   669 				; optimize OK (B_CRT), line = 469
   670
   671 839A AD 1D A2			lda I
   672 839D CD 1E A2			cmp @FORTMP_464
   673 83A0 90 05			bcc *+7
   674 83A2 F0 03			beq *+5
   675
   676 				; ForToDoProlog
   677 83A4 4C CA 83			jmp l_01E4
   678
   679 				; optimize FAIL ('ATASCII2ANTIC_01A6', B_CRT), line = 470
   680 83A7 E8				inx
   681 83A8 AD 1D A2 95 80		mva I :STACKORIGIN,x
   682 83AD E8				inx
   683 83AE AC 1D A2			ldy I 
   684 83B1 B9 1D A0 95 80		mva adr.S,y :STACKORIGIN,x
   685 83B6 20 36 83			jsr ATASCII2ANTIC_01A6
   686 83B9 B4 7F			ldy :STACKORIGIN-1,x
   687 83BB B5 80 99 1D A1		mva :STACKORIGIN,x adr.RESULT,y
   688 83C0 CA				dex
   689 83C1 CA				dex
   690
   691 				; ForToDoEpilog
   692 83C2			c_01D6
   693 83C2 EE 1D A2			inc I						; inc ptr byte [CounterAddress]
   694
   695 83C5 F0 03			seq
   696
   697 				; WhileDoEpilog
   698 83C7 4C 9A 83			jmp l_01D6
   699 83CA			l_01E4
   700 83CA			b_01D6
   701
   702 83CA			@exit
   703
   704 				; -----------------------------------------------------------
   705
   706 				; Push WORD / SMALLINT / SHORTREAL / POINTER
   707 				; as Pointer
   708
   709 83CA E8				inx						; add bx, 1
   710 83CB AD D8 83 95 80		mva RESULT :STACKORIGIN,x
   711 83D0 AD D9 83 95 90		mva RESULT+1 :STACKORIGIN+STACKWIDTH,x
   712
   713 					.ifdef @new
   714 					@FreeMem #@VarData #@VarDataSize
   715 					eif
   716
   717 				; -----------------------------------------------------------
   718
   719 = A01D			adr.S	= DATAORIGIN+$001D
   720 83D5			.var S	= adr.S .word
   721 = A11D			adr.RESULT	= DATAORIGIN+$011D
   722 83D5			.var RESULT	= adr.RESULT .word
   723 = A21D			I	= DATAORIGIN+$021D
   724 = A21E			@FORTMP_464	= DATAORIGIN+$021E
   725
   726 = 83D6			@VarData	= S
   727 = 0202			@VarDataSize	= 514
   728
   729 83D5 60				rts						; ret
   730 = 83D6 1D A0		S
   730 = 83D8 1D A1		RESULT
   730 				.endl
   731
   732 83DA			.local	CRT_INIT_01FA					; PROCEDURE | OVERLOAD
   733
   734 				; -----------------------------------------------------------
   735
   736 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   737 				; as Pointer
   738 83DA B5 80 8D 22 A2		mva :STACKORIGIN,x HEIGHT
   739 83DF CA				dex						; sub bx, 1
   740
   741 				; -----------------------------------------------------------
   742
   743 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   744 				; as Pointer
   745 83E0 B5 80 8D 21 A2		mva :STACKORIGIN,x WIDTH
   746 83E5 CA				dex						; sub bx, 1
   747
   748 				; -----------------------------------------------------------
   749
   750 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   751 				; as Pointer
   752 83E6 B5 80 8D 1F A2		mva :STACKORIGIN,x VRAM_ADDRESS
   753 83EB B5 90 8D 20 A2		mva :STACKORIGIN+STACKWIDTH,x VRAM_ADDRESS+1
   754 83F0 CA				dex						; sub bx, 1
   755
   756 					ift l_020F-*>3
   757 					jmp l_020F
   758 					eif
   759
   760 				; IfThenEpilog
   761 83F1			l_020F
   762
   763 				; optimize OK (B_CRT), line = 483
   764
   765 83F1 AD 1F A2 8D 12 A0		mva VRAM_ADDRESS CRT_VRAM
   766 83F7 AD 20 A2 8D 13 A0		mva VRAM_ADDRESS+1 CRT_VRAM+1
   767
   768 				; optimize OK (B_CRT), line = 484
   769
   770 83FD AD 21 A2 8D 16 A0		mva WIDTH CRT_SCREENWIDTH
   771
   772 				; optimize OK (B_CRT), line = 485
   773
   774 8403 AD 22 A2 8D 17 A0		mva HEIGHT CRT_SCREENHEIGHT
   775
   776 				; optimize OK (B_CRT), line = 486
   777
   778 8409 AD 22 A2			lda HEIGHT
   779 840C 85 CA			sta :ecx
   780 840E AD 21 A2			lda WIDTH
   781 8411 85 C2			sta :eax
   782 					.ifdef fmulinit
   783 					fmulu_8
   784 					els
   785 8413 20 C5 8A			imulCL
   786 					eif
   787 8416 A5 C2			lda :eax
   788 8418 8D 14 A0			sta CRT_SIZE
   789 841B A5 C3			lda :eax+1
   790 841D 8D 15 A0			sta CRT_SIZE+1
   791
   792 				; optimize OK (B_CRT), line = 487
   793
   794 8420 AD 12 A0 8D 18 A0		mva CRT_VRAM CRT_CURSOR
   795 8426 AD 13 A0 8D 19 A0		mva CRT_VRAM+1 CRT_CURSOR+1
   796
   797 				; optimize OK (B_CRT), line = 488
   798
   799 842C A9 00 8D 1A A0		mva #$00 CRT_LEFTMARGIN
   800
   801 				; -----------------------------------------------------------
   802
   803 = A21F			VRAM_ADDRESS	= DATAORIGIN+$021F
   804 = A221			WIDTH	= DATAORIGIN+$0221
   805 = A222			HEIGHT	= DATAORIGIN+$0222
   806
   807 = A21F			@VarData	= VRAM_ADDRESS
   808 = 0004			@VarDataSize	= 4
   809
   810
   811 8431			@exit
   812 					.ifdef @new
   813 					@FreeMem #@VarData #@VarDataSize
   814 					eif
   815 8431 60				rts						; ret
   816 				.endl
   817
   818 8432			.local	CRT_CLEAR_0248					; PROCEDURE | OVERLOAD
   819
   820 					ift l_024B-*>3
   821 					jmp l_024B
   822 					eif
   823
   824 				; IfThenEpilog
   825 8432			l_024B
   826
   827 				; optimize OK (B_CRT), line = 504
   828
   829 8432 AD 12 A0			lda CRT_VRAM
   830 8435 85 C6			sta :edx
   831 8437 AD 13 A0			lda CRT_VRAM+1
   832 843A 85 C7			sta :edx+1
   833 843C AD 14 A0			lda CRT_SIZE
   834 843F 85 CA			sta :ecx
   835 8441 AD 15 A0			lda CRT_SIZE+1
   836 8444 85 CB			sta :ecx+1
   837 8446 A9 00			lda #$00
   838 8448 85 C2			sta :eax
   839 844A 20 2E 8C			jsr @fill
   840
   841 				; optimize OK (B_CRT), line = 505
   842
   843 844D AD 12 A0 8D 18 A0		mva CRT_VRAM CRT_CURSOR
   844 8453 AD 13 A0 8D 19 A0		mva CRT_VRAM+1 CRT_CURSOR+1
   845
   846 8459			@exit
   847 					.ifdef @new
   848 					@FreeMem #@VarData #@VarDataSize
   849 					eif
   850 8459 60				rts						; ret
   851 				.endl
   852
   853 845A			.local	CRT_GOTOXY					; PROCEDURE
   854
   855 				; -----------------------------------------------------------
   856
   857 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   858 				; as Pointer
   859 845A B5 80 8D 24 A2		mva :STACKORIGIN,x Y
   860 845F CA				dex						; sub bx, 1
   861
   862 				; -----------------------------------------------------------
   863
   864 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   865 				; as Pointer
   866 8460 B5 80 8D 23 A2		mva :STACKORIGIN,x X
   867 8465 CA				dex						; sub bx, 1
   868
   869 					ift l_0269-*>3
   870 					jmp l_0269
   871 					eif
   872
   873 				; IfThenEpilog
   874 8466			l_0269
   875
   876 				; optimize OK (B_CRT), line = 516
   877
   878 8466 AD 16 A0			lda CRT_SCREENWIDTH
   879 8469 85 CA			sta :ecx
   880 846B AD 24 A2			lda Y
   881 846E 85 C2			sta :eax
   882 					.ifdef fmulinit
   883 					fmulu_8
   884 					els
   885 8470 20 C5 8A			imulCL
   886 					eif
   887 8473 A5 C2			lda :eax
   888 8475 18 6D 23 A2			add X
   889 8479 85 89			sta :STACKORIGIN+9
   890 847B A5 C3			lda :eax+1
   891 847D 69 00			adc #$00
   892 847F 85 99			sta :STACKORIGIN+STACKWIDTH+9
   893 8481 A5 89			lda :STACKORIGIN+9
   894 8483 18 6D 12 A0			add CRT_VRAM
   895 8487 8D 18 A0			sta CRT_CURSOR
   896 848A A5 99			lda :STACKORIGIN+STACKWIDTH+9
   897 848C 6D 13 A0			adc CRT_VRAM+1
   898 848F 8D 19 A0			sta CRT_CURSOR+1
   899
   900 				; -----------------------------------------------------------
   901
   902 = A223			X	= DATAORIGIN+$0223
   903 = A224			Y	= DATAORIGIN+$0224
   904
   905 = A223			@VarData	= X
   906 = 0002			@VarDataSize	= 2
   907
   908
   909 8492			@exit
   910 					.ifdef @new
   911 					@FreeMem #@VarData #@VarDataSize
   912 					eif
   913 8492 60				rts						; ret
   914 				.endl
   915
   916 8493			.local	CRT_WRITE_0284					; PROCEDURE | OVERLOAD
   917
   918 				; -----------------------------------------------------------
   919
   920 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   921 				; as Pointer
   922 8493 B5 80 8D FD 84		mva :STACKORIGIN,x S
   923 8498 B5 90 8D FE 84		mva :STACKORIGIN+STACKWIDTH,x S+1
   924 849D CA				dex						; sub bx, 1
   925 					@move S #adr.S #256
   925 				 MWA S @MOVE.PTR1\ MWA #ADR.S @MOVE.PTR2\ MWA #256 @MOVE.PTR3\ JSR @MOVE
   925 849E AD FD 84 85 C6 AD +  MWA S @MOVE.PTR1
   925 84A8 A9 25 85 CA A9 A2 +  MWA #ADR.S @MOVE.PTR2
   925 84B0 A9 00 85 C2 A9 01 +  MWA #256 @MOVE.PTR3
   925 84B8 20 DA 8B		 JSR @MOVE
   926 84BB A9 25 8D FD 84 A9 + 	mwa #adr.S S
   927
   928 					ift l_028D-*>3
   929 					jmp l_028D
   930 					eif
   931
   932 				; IfThenEpilog
   933 84C5			l_028D
   934
   935 				; optimize OK (B_CRT), line = 531
   936
   937 84C5 AD FD 84			lda S
   938 84C8 18 69 01			add #$01
   939 84CB 85 C6			sta :edx
   940 84CD AD FE 84			lda S+1
   941 84D0 69 00			adc #$00
   942 84D2 85 C7			sta :edx+1
   943 84D4 AD 25 A2			lda adr.S+$00
   944 84D7 85 C2			sta :eax
   945 84D9 AD 18 A0			lda CRT_CURSOR
   946 84DC 85 CA			sta :ecx
   947 84DE AD 19 A0			lda CRT_CURSOR+1
   948 84E1 85 CB			sta :ecx+1
   949 84E3 A9 00			lda #$00
   950 84E5 85 C3			sta :eax+1
   951 84E7 20 DA 8B			jsr @move
   952
   953 				; optimize OK (B_CRT), line = 532
   954
   955 84EA AD 18 A0			lda CRT_CURSOR
   956 84ED 18 6D 25 A2			add adr.S+$00
   957 84F1 8D 18 A0			sta CRT_CURSOR
   958 84F4 AD 19 A0			lda CRT_CURSOR+1
   959 84F7 69 00			adc #$00
   960 84F9 8D 19 A0			sta CRT_CURSOR+1
   961
   962 				; -----------------------------------------------------------
   963
   964 = A225			adr.S	= DATAORIGIN+$0225
   965 84FC			.var S	= adr.S .word
   966
   967 = 84FD			@VarData	= S
   968 = 0100			@VarDataSize	= 256
   969
   970
   971 84FC			@exit
   972 					.ifdef @new
   973 					@FreeMem #@VarData #@VarDataSize
   974 					eif
   975 84FC 60				rts						; ret
   976 = 84FD 25 A2		S
   976 				.endl
   977
   978 84FF			.local	CRT_WRITE_029A					; PROCEDURE | OVERLOAD
   979
   980 				; -----------------------------------------------------------
   981
   982 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   983 				; as Pointer
   984 84FF B5 80 8D 25 A3		mva :STACKORIGIN,x C
   985 8504 CA				dex						; sub bx, 1
   986
   987 					ift l_02A3-*>3
   988 					jmp l_02A3
   989 					eif
   990
   991 				; IfThenEpilog
   992 8505			l_02A3
   993
   994 				; optimize OK (B_CRT), line = 537
   995
   996 8505 AD 19 A0			lda CRT_CURSOR+1
   997 8508 85 CF			sta :bp+1
   998 850A AC 18 A0			ldy CRT_CURSOR
   999 850D AD 25 A3			lda C
  1000 8510 91 CE			sta (:bp),y
  1001
  1002 				; optimize FAIL (0, B_CRT), line = 538
  1003 8512 EE 18 A0 D0 03 EE + 	inw CRT_CURSOR
  1004
  1005 				; -----------------------------------------------------------
  1006
  1007 = A325			C	= DATAORIGIN+$0325
  1008
  1009 = A325			@VarData	= C
  1010 = 0001			@VarDataSize	= 1
  1011
  1012
  1013 851A			@exit
  1014 					.ifdef @new
  1015 					@FreeMem #@VarData #@VarDataSize
  1016 					eif
  1017 851A 60				rts						; ret
  1018 				.endl
  1019
  1020 851B			.local	CRT_WRITE_02AE					; PROCEDURE | OVERLOAD
  1021
  1022 				; -----------------------------------------------------------
  1023
  1024 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  1025 				; as Pointer
  1026 851B B5 80 8D 26 A3		mva :STACKORIGIN,x NUM
  1027 8520 CA				dex						; sub bx, 1
  1028
  1029 					ift l_02B7-*>3
  1030 					jmp l_02B7
  1031 					eif
  1032
  1033 				; IfThenEpilog
  1034 8521			l_02B7
  1035
  1036 				; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 543
  1037 8521 E8				inx
  1038 8522 AD 26 A3 95 80		mva NUM :STACKORIGIN,x
  1039 8527 20 A2 8A			jsr @expandToCARD.BYTE
  1040 852A 20 FF 82			jsr SYSUTILS.INTTOSTR
  1041 852D 20 57 83			jsr ATASCII2ANTIC_01B3
  1042 8530 20 93 84			jsr CRT_WRITE_0284
  1043
  1044 				; -----------------------------------------------------------
  1045
  1046 = A326			NUM	= DATAORIGIN+$0326
  1047
  1048 = A326			@VarData	= NUM
  1049 = 0001			@VarDataSize	= 1
  1050
  1051
  1052 8533			@exit
  1053 					.ifdef @new
  1054 					@FreeMem #@VarData #@VarDataSize
  1055 					eif
  1056 8533 60				rts						; ret
  1057 				.endl
  1058
  1059 8534			.local	CRT_WRITE_02BE					; PROCEDURE | OVERLOAD
  1060
  1061 				; -----------------------------------------------------------
  1062
  1063 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  1064 				; as Pointer
  1065 8534 B5 80 8D 27 A3		mva :STACKORIGIN,x NUM
  1066 8539 B5 90 8D 28 A3		mva :STACKORIGIN+STACKWIDTH,x NUM+1
  1067 853E CA				dex						; sub bx, 1
  1068
  1069 					ift l_02C7-*>3
  1070 					jmp l_02C7
  1071 					eif
  1072
  1073 				; IfThenEpilog
  1074 853F			l_02C7
  1075
  1076 				; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 548
  1077 853F E8				inx
  1078 8540 AD 27 A3 95 80		mva NUM :STACKORIGIN,x
  1079 8545 AD 28 A3 95 90		mva NUM+1 :STACKORIGIN+STACKWIDTH,x
  1080 854A 20 96 8A			jsr @expandToCARD.WORD
  1081 854D 20 FF 82			jsr SYSUTILS.INTTOSTR
  1082 8550 20 57 83			jsr ATASCII2ANTIC_01B3
  1083 8553 20 93 84			jsr CRT_WRITE_0284
  1084
  1085 				; -----------------------------------------------------------
  1086
  1087 = A327			NUM	= DATAORIGIN+$0327
  1088
  1089 = A327			@VarData	= NUM
  1090 = 0002			@VarDataSize	= 2
  1091
  1092
  1093 8556			@exit
  1094 					.ifdef @new
  1095 					@FreeMem #@VarData #@VarDataSize
  1096 					eif
  1097 8556 60				rts						; ret
  1098 				.endl
  1099
  1100 8557			.local	CRT_KEYPRESSED					; FUNCTION
  1101
  1102 					ift l_02D0-*>3
  1103 					jmp l_02D0
  1104 					eif
  1105
  1106 				; IfThenEpilog
  1107 8557			l_02D0
  1108
  1109 				; optimize OK (B_CRT), line = 592
  1110
  1111 8557 A9 00 8D 29 A3		mva #$00 RESULT
  1112
  1113 				; optimize OK (B_CRT), line = 593
  1114
  1115 855C AD 0F D2			lda ATARI.SKSTAT
  1116 855F A0 01			ldy #1
  1117 8561 29 04			and #$04
  1118 8563 F0 01			beq @+
  1119 8565 88				dey
  1120 8566			@
  1121 					.ifdef IFTMP_28
  1122 					sty IFTMP_28
  1123 					eif
  1124 8566 98				tya
  1125 8567 D0 03			bne *+5
  1126 8569 4C 71 85			jmp l_02ED
  1127
  1128 				; optimize OK (B_CRT), line = 593
  1129
  1130 856C A9 01 8D 29 A3		mva #$01 RESULT
  1131
  1132 				; IfThenEpilog
  1133 8571			l_02ED
  1134
  1135 8571			@exit
  1136
  1137 				; -----------------------------------------------------------
  1138
  1139 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1140 				; as Pointer
  1141
  1142 8571 E8				inx						; add bx, 1
  1143 8572 AD 29 A3 95 80		mva RESULT :STACKORIGIN,x
  1144
  1145 					.ifdef @new
  1146 					@FreeMem #@VarData #@VarDataSize
  1147 					eif
  1148
  1149 				; -----------------------------------------------------------
  1150
  1151 = A329			RESULT	= DATAORIGIN+$0329
  1152
  1153 = A329			@VarData	= RESULT
  1154 = 0001			@VarDataSize	= 1
  1155
  1156 8577 60				rts						; ret
  1157 				.endl
  1158
  1159 8578			.local	CRT_STARTPRESSED				; FUNCTION
  1160
  1161 					ift l_0307-*>3
  1162 					jmp l_0307
  1163 					eif
  1164
  1165 				; IfThenEpilog
  1166 8578			l_0307
  1167
  1168 				; optimize OK (B_CRT), line = 749
  1169
  1170 8578 AD 1F D0			lda ATARI.CONSOL
  1171 857B A0 01			ldy #1
  1172 857D 29 01			and #$01
  1173 857F F0 01			beq @+
  1174 8581 88				dey
  1175 8582			@
  1176 8582 8C 2A A3			sty RESULT
  1177
  1178 8585			@exit
  1179
  1180 				; -----------------------------------------------------------
  1181
  1182 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
  1183 				; as Pointer
  1184
  1185 8585 E8				inx						; add bx, 1
  1186 8586 AD 2A A3 95 80		mva RESULT :STACKORIGIN,x
  1187
  1188 					.ifdef @new
  1189 					@FreeMem #@VarData #@VarDataSize
  1190 					eif
  1191
  1192 				; -----------------------------------------------------------
  1193
  1194 = A32A			RESULT	= DATAORIGIN+$032A
  1195
  1196 = A32A			@VarData	= RESULT
  1197 = 0001			@VarDataSize	= 1
  1198
  1199 858B 60				rts						; ret
  1200 				.endl
  1201
  1202 				; -----------------------------------------------------------
  1203
  1204 = 0028			DEFAULT_SCREENWIDTH	= $0028
  1205 = 0018			DEFAULT_SCREENHEIGHT	= $0018
  1206 = 009B			CHAR_RETURN	= $009B
  1207 = 001B			CHAR_ESCAPE	= $001B
  1208 = 007E			CHAR_BACKSPACE	= $007E
  1209 = 007F			CHAR_TAB	= $007F
  1210 = 0081			CHAR_INVERSE	= $0081
  1211 = 0082			CHAR_CAPS	= $0082
  1212 = 00DB			ICHAR_RETURN	= $00DB
  1213 = 005B			ICHAR_ESCAPE	= $005B
  1214 = 007E			ICHAR_BACKSPACE	= $007E
  1215 = 007F			ICHAR_TAB	= $007F
  1216 = 00C1			ICHAR_INVERSE	= $00C1
  1217 = 00C2			ICHAR_CAPS	= $00C2
  1218 = 811E			adr.CRT_KEYCODE	= CODEORIGIN+$011E
  1219 858C			.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
  1220 = A012			CRT_VRAM	= DATAORIGIN+$0012
  1221 = A014			CRT_SIZE	= DATAORIGIN+$0014
  1222 = A016			CRT_SCREENWIDTH	= DATAORIGIN+$0016
  1223 = A017			CRT_SCREENHEIGHT	= DATAORIGIN+$0017
  1224 = A018			CRT_CURSOR	= DATAORIGIN+$0018
  1225 = A01A			CRT_LEFTMARGIN	= DATAORIGIN+$001A
  1226 = D209			KBCODE	= $D209
  1227 = D01F			CONSOL	= $D01F
  1228
  1229 = 858C 1E 81		CRT_KEYCODE
  1229 				.endl							; UNIT B_CRT
  1230
  1231 858E			.local	TITLEVBI					; PROCEDURE | ASSEMBLER | INTERRUPT
  1232
  1233
  1234 				; ---------------------  ASM Block 066  ---------------------
  1235
  1236
  1237 858E A9 9E				lda #<title00dli
  1238 8590 8D 00 02				sta vdslst+0
  1239 8593 A9 85				lda #>title00dli
  1240 8595 8D 01 02				sta vdslst+1
  1241 8598 4C 62 E4				jmp XITVBV
  1242 					
  1243 859B 40				rti						; ret
  1244 				.endl
  1245
  1246 859C			.local	GAMEVBI						; PROCEDURE | ASSEMBLER | INTERRUPT
  1247
  1248
  1249 				; ---------------------  ASM Block 067  ---------------------
  1250
  1251
  1252 859C 40				rti						; ret
  1253 				.endl
  1254
  1255 859D			.local	PAUSEVBI					; PROCEDURE | ASSEMBLER | INTERRUPT
  1256
  1257
  1258 				; ---------------------  ASM Block 068  ---------------------
  1259
  1260
  1261 859D 40				rti						; ret
  1262 				.endl
  1263
  1264 859E			.local	TITLE00DLI					; PROCEDURE | ASSEMBLER | INTERRUPT
  1265
  1266
  1267 				; ---------------------  ASM Block 069  ---------------------
  1268
  1269
  1270 859E 48				pha	
  1271 859F A9 D8			lda #$D8
  1272 85A1 8D 0A D4			sta wsync
  1273 85A4 8D 16 D0			sta colpf0
  1274 85A7 A9 06			lda #$06
  1275 85A9 8D 17 D0			sta colpf1
  1276 85AC A9 AA			lda #$AA
  1277 85AE 8D 18 D0			sta colpf2
  1278 85B1 A9 A8			lda #>CHARSET_TITLE
  1279 85B3 8D 09 D4			sta chbase
  1280 85B6 A9 C3			lda #<title01dli
  1281 85B8 8D 00 02			sta vdslst+0
  1282 85BB A9 85			lda #>title01dli
  1283 85BD 8D 01 02			sta vdslst+1
  1284 85C0 68				pla
  1285 85C1 40				rti
  1286 85C2 40				rti						; ret
  1287 				.endl
  1288
  1289 85C3			.local	TITLE01DLI					; PROCEDURE | ASSEMBLER | INTERRUPT
  1290
  1291
  1292 				; ---------------------  ASM Block 070  ---------------------
  1293
  1294
  1295 85C3 48				pha	
  1296 85C4 A9 8E			lda #142
  1297 85C6 8D 0A D4			sta wsync
  1298 85C9 8D 16 D0			sta colpf0
  1299 85CC A9 0A			lda #10
  1300 85CE 8D 17 D0			sta colpf1
  1301 85D1 A9 BA			lda #186
  1302 85D3 8D 18 D0			sta colpf2
  1303 85D6 A9 A4			lda #>CHARSET_GAME
  1304 85D8 8D 09 D4		 	sta chbase
  1305 85DB A9 9E			lda #<title00dli
  1306 85DD 8D 00 02			sta vdslst+0
  1307 85E0 A9 85			lda #>title00dli
  1308 85E2 8D 01 02			sta vdslst+1
  1309 85E5 68				pla
  1310 85E6 40				rti
  1311 85E7 40				rti						; ret
  1312 				.endl
  1313
  1314 85E8			.local	TITLE02DLI					; PROCEDURE | ASSEMBLER | INTERRUPT
  1315
  1316
  1317 				; ---------------------  ASM Block 071  ---------------------
  1318
  1319 85E8			phr
  1320 85E8 68 A8 68 AA 68		plr
  1321 85ED 40				rti						; ret
  1322 				.endl
  1323
  1324 85EE			.local	TITLE03DLI					; PROCEDURE | ASSEMBLER | INTERRUPT
  1325
  1326
  1327 				; ---------------------  ASM Block 072  ---------------------
  1328
  1329 85EE			phr
  1330 85EE 68 A8 68 AA 68		plr
  1331 85F3 40				rti						; ret
  1332 				.endl
  1333
  1334 85F4			.local	GAME00DLI					; PROCEDURE | ASSEMBLER | INTERRUPT
  1335
  1336
  1337 				; ---------------------  ASM Block 073  ---------------------
  1338
  1339 85F4			phr
  1340 85F4 68 A8 68 AA 68		plr
  1341 85F9 40				rti						; ret
  1342 				.endl
  1343
  1344 85FA			.local	GAME01DLI					; PROCEDURE | ASSEMBLER | INTERRUPT
  1345
  1346
  1347 				; ---------------------  ASM Block 074  ---------------------
  1348
  1349 85FA			phr
  1350 85FA 68 A8 68 AA 68		plr
  1351 85FF 40				rti						; ret
  1352 				.endl
  1353
  1354 8600			.local	GAME02DLI					; PROCEDURE | ASSEMBLER | INTERRUPT
  1355
  1356
  1357 				; ---------------------  ASM Block 075  ---------------------
  1358
  1359 8600			phr
  1360 8600 68 A8 68 AA 68		plr
  1361 8605 40				rti						; ret
  1362 				.endl
  1363
  1364 8606			.local	GAME03DLI					; PROCEDURE | ASSEMBLER | INTERRUPT
  1365
  1366
  1367 				; ---------------------  ASM Block 076  ---------------------
  1368
  1369 8606			phr
  1370 8606 68 A8 68 AA 68		plr
  1371 860B 40				rti						; ret
  1372 				.endl
  1373
  1374 860C			.local	SHOWTITLESCREEN					; PROCEDURE
  1375
  1376 					ift l_032C-*>3
  1377 					jmp l_032C
  1378 					eif
  1379
  1380 				; IfThenEpilog
  1381 860C			l_032C
  1382
  1383 				; optimize OK (Mind Field.pas), line = 153
  1384
  1385 860C A9 00			lda #$00
  1386 860E 8D 51 A3			sta TOPMEM
  1387 8611 AD 53 A3			lda CHBASE1
  1388 8614 8D 52 A3			sta TOPMEM+1
  1389
  1390 				; ---------------------  ASM Block 077  ---------------------
  1391
  1392
  1393 				;	  ICL "Atari 8-bit Equates.asm"
  1394 						
  1395 8617 A9 00		    lda #0
  1396 8619 85 52		    sta 82
  1397 861B 8D C6 02		    sta 710
  1398 861E A9 0C		    lda #12
  1399 8620 8D C5 02		    sta 709
  1400 				    ; lda chbase1
  1401 				    ; sta 756
  1402 8623 A9 00		    LDA #0
  1403 8625 8D 0E D4		    STA NMIEN
  1404 8628 8D 00 D4		    STA DMACTL
  1405 862B 8D 1B D0		    STA PRIOR
  1406 862E 8D 1E D0		    STA HITCLR
  1407
  1408 				;    LDX #>RamSizeCode+1
  1409 8631 A0 00		    LDY #$00
  1410 8633 84 EA		    STY NDX0
  1411 8635 84 EC		    STY NDX2
  1412 8637 A9 38		    LDA #$38
  1413 8639 85 EB		    STA NDX1
  1414 863B A9 A8		    LDA #$A8
  1415 863D 85 ED		    STA NDX3
  1416 				    
  1417
  1418 				; optimize OK (Mind Field.pas), line = 179
  1419
  1420 863F A9 00 8D 00 D4		mva #$00 ATARI.DMACTL
  1421
  1422 				; optimize OK (Mind Field.pas), line = 180
  1423
  1424 8644 8D 0E D4			sta ATARI.NMIEN
  1425
  1426 				; optimize FAIL ('B_CRT.CRT_INIT_01FA', Mind Field.pas), line = 181
  1427 8647 E8				inx
  1428 8648 A9 00 95 80			mva #$00 :STACKORIGIN,x
  1429 864C A9 08 95 90			mva #$08 :STACKORIGIN+STACKWIDTH,x
  1430 8650 E8				inx
  1431 8651 A9 28 95 80			mva #$28 :STACKORIGIN,x
  1432 8655 E8				inx
  1433 8656 A9 19 95 80			mva #$19 :STACKORIGIN,x
  1434 865A 20 DA 83			jsr B_CRT.CRT_INIT_01FA
  1435
  1436 				; optimize OK (Mind Field.pas), line = 182
  1437
  1438 865D A9 9E 8D 00 02		mva <TITLE00DLI VDSLST
  1439 8662 A9 85 8D 01 02		mva >TITLE00DLI VDSLST+1
  1440
  1441 				; optimize OK (Mind Field.pas), line = 183
  1442
  1443 8667 A9 8E			lda <TITLEVBI
  1444 8669 A0 05			ldy #5
  1445 866B 8D 0A D4			sta wsync
  1446 866E 88				dey
  1447 866F D0 FD			rne
  1448 8671 8D 24 02			sta VVBLKD
  1449 8674 A9 85			lda >TITLEVBI
  1450 8676 8D 25 02			sta VVBLKD+1
  1451
  1452 				; optimize FAIL ('B_CRT.CRT_CLEAR_0248', Mind Field.pas), line = 184
  1453 8679 20 32 84			jsr B_CRT.CRT_CLEAR_0248
  1454
  1455 				; optimize OK (Mind Field.pas), line = 185
  1456
  1457 867C A9 1E 8D 02 D4		mva #$1E ATARI.DLISTW
  1458 8681 A9 82 8D 03 D4		mva #$82 ATARI.DLISTW+1
  1459
  1460 				; optimize OK (Mind Field.pas), line = 186
  1461
  1462 8686 A9 1E 8D 30 02		mva #$1E ATARI.SDLSTW
  1463 868B A9 82 8D 31 02		mva #$82 ATARI.SDLSTW+1
  1464
  1465 				; optimize OK (Mind Field.pas), line = 187
  1466
  1467 8690 A9 00 85 58			mva #$00 ATARI.SAVMSC
  1468 8694 A9 08 85 59			mva #$08 ATARI.SAVMSC+1
  1469
  1470 				; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 188
  1471 8698 E8				inx
  1472 8699 A9 A4 95 80			mva #$A4 :STACKORIGIN,x
  1473 869D 20 F2 82			jsr B_SYSTEM.SETCHARSET
  1474
  1475 				; optimize OK (Mind Field.pas), line = 189
  1476
  1477 86A0 A9 A4 8D F4 02		mva #$A4 ATARI.CHBAS
  1478
  1479 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 190
  1480 86A5 E8				inx
  1481 86A6 A9 00 95 80			mva #$00 :STACKORIGIN,x
  1482 86AA E8				inx
  1483 86AB 95 80			sta :STACKORIGIN,x
  1484 86AD 20 5A 84			jsr B_CRT.CRT_GOTOXY
  1485
  1486 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 191
  1487 86B0 E8				inx
  1488 86B1 A9 02 95 80			mva #$02 :STACKORIGIN,x
  1489 86B5 A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1490 86B9 20 93 84			jsr B_CRT.CRT_WRITE_0284
  1491
  1492 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 192
  1493 86BC E8				inx
  1494 86BD A9 2C 95 80			mva #$2C :STACKORIGIN,x
  1495 86C1 A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1496 86C5 20 93 84			jsr B_CRT.CRT_WRITE_0284
  1497
  1498 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 193
  1499 86C8 E8				inx
  1500 86C9 A9 56 95 80			mva #$56 :STACKORIGIN,x
  1501 86CD A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1502 86D1 20 93 84			jsr B_CRT.CRT_WRITE_0284
  1503
  1504 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 194
  1505 86D4 E8				inx
  1506 86D5 A9 80 95 80			mva #$80 :STACKORIGIN,x
  1507 86D9 A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1508 86DD 20 93 84			jsr B_CRT.CRT_WRITE_0284
  1509
  1510 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 195
  1511 86E0 E8				inx
  1512 86E1 A9 AA 95 80			mva #$AA :STACKORIGIN,x
  1513 86E5 A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1514 86E9 20 93 84			jsr B_CRT.CRT_WRITE_0284
  1515
  1516 				; optimize OK (Mind Field.pas), line = 196
  1517
  1518 86EC A9 00 85 E5			mva #$00 TMP5
  1519
  1520 				; optimize OK (Mind Field.pas), line = 198
  1521
  1522 86F0 A9 06 8D 35 A3		mva #$06 K
  1523
  1524 				; optimize OK (Mind Field.pas), line = 199
  1525
  1526 86F5 A9 05 8D 33 A3		mva #$05 I
  1527
  1528 				; optimize OK (Mind Field.pas), line = 201
  1529
  1530 86FA A9 D8 8D C4 02		mva #$D8 ATARI.COLOR0
  1531
  1532 				; optimize OK (Mind Field.pas), line = 202
  1533
  1534 86FF A9 06 8D C5 02		mva #$06 ATARI.COLOR1
  1535
  1536 				; optimize OK (Mind Field.pas), line = 203
  1537
  1538 8704 A9 AA 8D C6 02		mva #$AA ATARI.COLOR2
  1539
  1540 				; optimize OK (Mind Field.pas), line = 204
  1541
  1542 8709 A9 36 8D C7 02		mva #$36 ATARI.COLOR3
  1543
  1544 				; optimize OK (Mind Field.pas), line = 205
  1545
  1546 870E A9 22 8D C8 02		mva #$22 ATARI.COLOR4
  1547
  1548 				; optimize OK (Mind Field.pas), line = 206
  1549
  1550 8713 A9 C0 8D 0E D4		mva #$C0 ATARI.NMIEN
  1551
  1552 				; optimize OK (Mind Field.pas), line = 207
  1553
  1554 8718 A9 3E 8D 00 D4		mva #$3E ATARI.DMACTL
  1555
  1556 				; --- RepeatUntilProlog
  1557 871D			l_03BE
  1558
  1559 				; optimize OK (Mind Field.pas), line = 210
  1560
  1561 871D AD 33 A3			lda I
  1562 8720 0A				asl @
  1563 8721 A8				tay
  1564 8722 B9 3B A3			lda adr.HISCORE,y
  1565 8725 85 8A			sta :STACKORIGIN+10
  1566 8727 B9 3C A3			lda adr.HISCORE+1,y
  1567 872A 85 9A			sta :STACKORIGIN+STACKWIDTH+10
  1568 872C A0 01			ldy #1
  1569 872E AD 39 A3			lda SCORE+1
  1570 8731 C5 9A			cmp :STACKORIGIN+STACKWIDTH+10
  1571 8733 D0 05			bne @+
  1572 8735 AD 38 A3			lda SCORE
  1573 8738 C5 8A			cmp :STACKORIGIN+10
  1574 873A			@
  1575 873A F0 02			seq
  1576 873C B0 01			bcs @+
  1577 873E 88				dey
  1578 873F			@
  1579 					.ifdef IFTMP_32
  1580 					sty IFTMP_32
  1581 					eif
  1582 873F 98				tya
  1583 8740 D0 03			bne *+5
  1584 8742 4C 4B 87			jmp l_03D3
  1585
  1586 				; optimize OK (Mind Field.pas), line = 212
  1587
  1588 8745 AD 33 A3 8D 35 A3		mva I K
  1589
  1590 				; IfThenEpilog
  1591 874B			l_03D3
  1592
  1593 				; optimize OK (Mind Field.pas), line = 214
  1594
  1595 874B CE 33 A3			dec I
  1596
  1597 				; optimize OK (Mind Field.pas), line = 215
  1598
  1599 874E A0 01			ldy #1
  1600 8750 AD 33 A3			lda I
  1601 8753 F0 01			beq @+
  1602 8755 88				dey
  1603 8756			@
  1604 8756 98				tya
  1605 8757 D0 03			bne *+5
  1606 8759			c_03BE
  1607 8759 4C 1D 87			jmp l_03BE
  1608 875C			b_03BE
  1609
  1610 				; optimize OK (Mind Field.pas), line = 216
  1611
  1612 875C A0 01			ldy #1
  1613 875E AD 35 A3			lda K
  1614 8761 C9 05			cmp #$05
  1615 8763 90 01			bcc @+
  1616 8765 88				dey
  1617 8766			@
  1618 					.ifdef IFTMP_33
  1619 					sty IFTMP_33
  1620 					eif
  1621 8766 98				tya
  1622 8767 D0 03			bne *+5
  1623 8769 4C BA 87			jmp l_040B
  1624
  1625 				; optimize OK (Mind Field.pas), line = 218
  1626
  1627 876C A9 05 8D 33 A3		mva #$05 I
  1628
  1629 				; --- RepeatUntilProlog
  1630 8771			l_0414
  1631
  1632 				; optimize OK (Mind Field.pas), line = 220
  1633
  1634 8771 AD 33 A3			lda I
  1635 8774 0A				asl @
  1636 8775 85 89			sta :STACKORIGIN+9
  1637 8777 AD 33 A3			lda I
  1638 877A 38 E9 01			sub #$01
  1639 877D 0A				asl @
  1640 877E A8				tay
  1641 877F B9 3B A3			lda adr.HISCORE,y
  1642 8782 85 8A			sta :STACKORIGIN+10
  1643 8784 B9 3C A3			lda adr.HISCORE+1,y
  1644 8787 85 9A			sta :STACKORIGIN+STACKWIDTH+10
  1645 8789 A4 89			ldy :STACKORIGIN+9
  1646 878B A5 8A			lda :STACKORIGIN+10
  1647 878D 99 3B A3			sta adr.HISCORE,y
  1648 8790 A5 9A			lda :STACKORIGIN+STACKWIDTH+10
  1649 8792 99 3C A3			sta adr.HISCORE+1,y
  1650
  1651 				; optimize OK (Mind Field.pas), line = 221
  1652
  1653 8795 CE 33 A3			dec I
  1654
  1655 				; optimize OK (Mind Field.pas), line = 222
  1656
  1657 8798 A0 01			ldy #1
  1658 879A AD 33 A3			lda I
  1659 879D CD 35 A3			cmp K
  1660 87A0 F0 01			beq @+
  1661 87A2 88				dey
  1662 87A3			@
  1663 87A3 98				tya
  1664 87A4 D0 03			bne *+5
  1665 87A6			c_0414
  1666 87A6 4C 71 87			jmp l_0414
  1667 87A9			b_0414
  1668
  1669 				; optimize OK (Mind Field.pas), line = 223
  1670
  1671 87A9 AD 35 A3			lda K
  1672 87AC 0A				asl @
  1673 87AD A8				tay
  1674 87AE AD 38 A3			lda SCORE
  1675 87B1 99 3B A3			sta adr.HISCORE,y
  1676 87B4 AD 39 A3			lda SCORE+1
  1677 87B7 99 3C A3			sta adr.HISCORE+1,y
  1678
  1679 				; IfThenEpilog
  1680 87BA			l_040B
  1681
  1682 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 225
  1683 87BA E8				inx
  1684 87BB A9 0A 95 80			mva #$0A :STACKORIGIN,x
  1685 87BF E8				inx
  1686 87C0 A9 06 95 80			mva #$06 :STACKORIGIN,x
  1687 87C4 20 5A 84			jsr B_CRT.CRT_GOTOXY
  1688
  1689 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 226
  1690 87C7 E8				inx
  1691 87C8 A9 D4 95 80			mva #$D4 :STACKORIGIN,x
  1692 87CC A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1693 87D0 20 93 84			jsr B_CRT.CRT_WRITE_0284
  1694
  1695 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 227
  1696 87D3 E8				inx
  1697 87D4 A9 12 95 80			mva #$12 :STACKORIGIN,x
  1698 87D8 E8				inx
  1699 87D9 A9 06 95 80			mva #$06 :STACKORIGIN,x
  1700 87DD 20 5A 84			jsr B_CRT.CRT_GOTOXY
  1701
  1702 				; optimize FAIL ('B_CRT.CRT_WRITE_02BE', Mind Field.pas), line = 228
  1703 87E0 E8				inx
  1704 87E1 AD 38 A3 95 80		mva SCORE :STACKORIGIN,x
  1705 87E6 AD 39 A3 95 90		mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
  1706 87EB 20 34 85			jsr B_CRT.CRT_WRITE_02BE
  1707
  1708 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 229
  1709 87EE E8				inx
  1710 87EF A9 08 95 80			mva #$08 :STACKORIGIN,x
  1711 87F3 E8				inx
  1712 87F4 A9 07 95 80			mva #$07 :STACKORIGIN,x
  1713 87F8 20 5A 84			jsr B_CRT.CRT_GOTOXY
  1714
  1715 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 230
  1716 87FB E8				inx
  1717 87FC A9 DE 95 80			mva #$DE :STACKORIGIN,x
  1718 8800 A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1719 8804 20 93 84			jsr B_CRT.CRT_WRITE_0284
  1720 				; For
  1721
  1722 				; optimize OK (Mind Field.pas), line = 231
  1723
  1724 8807 A9 01 8D 33 A3		mva #$01 I
  1725
  1726 				; optimize OK (Mind Field.pas), line = 231
  1727
  1728 				; To
  1729 880C			l_0468
  1730
  1731 				; ForToDoCondition
  1732
  1733 				; optimize OK (Mind Field.pas), line = 231
  1734
  1735 880C AD 33 A3			lda I
  1736 880F C9 05			cmp #$05
  1737 8811 90 05			bcc *+7
  1738 8813 F0 03			beq *+5
  1739
  1740 				; ForToDoProlog
  1741 8815 4C B0 88			jmp l_0476
  1742
  1743 				; optimize OK (Mind Field.pas), line = 233
  1744
  1745 8818 A0 01			ldy #1
  1746 881A AD 35 A3			lda K
  1747 881D CD 33 A3			cmp I
  1748 8820 F0 01			beq @+
  1749 8822 88				dey
  1750 8823			@
  1751 					.ifdef IFTMP_34
  1752 					sty IFTMP_34
  1753 					eif
  1754 8823 98				tya
  1755 8824 D0 03			bne *+5
  1756 8826 4C 48 88			jmp l_048A
  1757
  1758 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 235
  1759 8829 E8				inx
  1760 882A A9 0C 95 80			mva #$0C :STACKORIGIN,x
  1761 882E E8				inx
  1762 882F A9 08 95 80			mva #$08 :STACKORIGIN,x
  1763 8833 E8				inx
  1764 8834 AD 33 A3 95 80		mva I :STACKORIGIN,x
  1765 8839 20 79 8A			jsr addAL_CL
  1766 883C CA				dex
  1767 883D 20 5A 84			jsr B_CRT.CRT_GOTOXY
  1768
  1769 				; optimize FAIL ('B_CRT.CRT_WRITE_029A', Mind Field.pas), line = 236
  1770 8840 E8				inx
  1771 8841 A9 0A 95 80			mva #$0A :STACKORIGIN,x
  1772 8845 20 FF 84			jsr B_CRT.CRT_WRITE_029A
  1773
  1774 				; IfThenEpilog
  1775 8848			l_048A
  1776
  1777 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 238
  1778 8848 E8				inx
  1779 8849 A9 0E 95 80			mva #$0E :STACKORIGIN,x
  1780 884D E8				inx
  1781 884E A9 08 95 80			mva #$08 :STACKORIGIN,x
  1782 8852 E8				inx
  1783 8853 AD 33 A3 95 80		mva I :STACKORIGIN,x
  1784 8858 20 79 8A			jsr addAL_CL
  1785 885B CA				dex
  1786 885C 20 5A 84			jsr B_CRT.CRT_GOTOXY
  1787
  1788 				; optimize FAIL ('B_CRT.CRT_WRITE_02AE', Mind Field.pas), line = 239
  1789 885F E8				inx
  1790 8860 AD 33 A3 95 80		mva I :STACKORIGIN,x
  1791 8865 20 1B 85			jsr B_CRT.CRT_WRITE_02AE
  1792
  1793 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 240
  1794 8868 E8				inx
  1795 8869 A9 F3 95 80			mva #$F3 :STACKORIGIN,x
  1796 886D A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1797 8871 20 93 84			jsr B_CRT.CRT_WRITE_0284
  1798
  1799 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 241
  1800 8874 E8				inx
  1801 8875 A9 12 95 80			mva #$12 :STACKORIGIN,x
  1802 8879 E8				inx
  1803 887A A9 08 95 80			mva #$08 :STACKORIGIN,x
  1804 887E E8				inx
  1805 887F AD 33 A3 95 80		mva I :STACKORIGIN,x
  1806 8884 20 79 8A			jsr addAL_CL
  1807 8887 CA				dex
  1808 8888 20 5A 84			jsr B_CRT.CRT_GOTOXY
  1809
  1810 				; optimize FAIL ('B_CRT.CRT_WRITE_02BE', Mind Field.pas), line = 242
  1811 888B E8				inx
  1812 888C AD 33 A3 95 80		mva I :STACKORIGIN,x
  1813 8891 A9 00 95 90			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1814 8895				m@index2 0
Macro: M@INDEX2 [Source: cpu6502.asm]
     1 8895 16 80			asl :STACKORIGIN-0,x
     2 8897 36 90			rol :STACKORIGIN-0+STACKWIDTH,x
Source: Mind Field.a65
  1815 8899 B4 80			ldy :STACKORIGIN,x
  1816 889B B9 3B A3 95 80		mva adr.HISCORE,y :STACKORIGIN,x
  1817 88A0 B9 3C A3 95 90		mva adr.HISCORE+1,y :STACKORIGIN+STACKWIDTH,x
  1818 88A5 20 34 85			jsr B_CRT.CRT_WRITE_02BE
  1819
  1820 				; ForToDoEpilog
  1821 88A8			c_0468
  1822 88A8 EE 33 A3			inc I						; inc ptr byte [CounterAddress]
  1823
  1824 88AB F0 03			seq
  1825
  1826 				; WhileDoEpilog
  1827 88AD 4C 0C 88			jmp l_0468
  1828 88B0			l_0476
  1829 88B0			b_0468
  1830
  1831 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 244
  1832 88B0 E8				inx
  1833 88B1 A9 07 95 80			mva #$07 :STACKORIGIN,x
  1834 88B5 E8				inx
  1835 88B6 A9 0F 95 80			mva #$0F :STACKORIGIN,x
  1836 88BA 20 5A 84			jsr B_CRT.CRT_GOTOXY
  1837
  1838 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 245
  1839 88BD E8				inx
  1840 88BE A9 F7 95 80			mva #$F7 :STACKORIGIN,x
  1841 88C2 A9 80 95 90			mva #$80 :STACKORIGIN+STACKWIDTH,x
  1842 88C6 20 93 84			jsr B_CRT.CRT_WRITE_0284
  1843
  1844 				; optimize OK (Mind Field.pas), line = 246
  1845
  1846 88C9 A9 00			lda #$00
  1847 88CB 85 CF			sta :bp+1
  1848 88CD AC 00 D0			ldy ATARI.HPOSP0
  1849 88D0 A9 7C			lda #$7C
  1850 88D2 91 CE			sta (:bp),y
  1851
  1852 				; --- RepeatUntilProlog
  1853 88D4			l_04C6
  1854
  1855 				; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 257
  1856 88D4 20 78 85			jsr B_CRT.CRT_STARTPRESSED
  1857 					.ifdef IFTMP_35
  1858 					lda :STACKORIGIN,x
  1859 					sta IFTMP_35
  1860 					eif
  1861 88D7 CA				dex
  1862 88D8 B5 81			lda :STACKORIGIN+1,x
  1863 88DA D0 03			bne *+5
  1864 88DC 4C E3 88			jmp l_04D0
  1865
  1866 				; optimize OK (Mind Field.pas), line = 257
  1867
  1868 88DF A9 FF 85 E5			mva #$FF TMP5
  1869
  1870 				; IfThenEpilog
  1871 88E3			l_04D0
  1872
  1873 				; optimize OK (Mind Field.pas), line = 261
  1874
  1875 88E3 A0 01			ldy #1
  1876 88E5 A5 E5			lda TMP5
  1877 88E7 C9 FF			cmp #$FF
  1878 88E9 F0 01			beq @+
  1879 88EB 88				dey
  1880 88EC			@
  1881 88EC 98				tya
  1882 88ED D0 03			bne *+5
  1883 88EF			c_04C6
  1884 88EF 4C D4 88			jmp l_04C6
  1885 88F2			b_04C6
  1886
  1887 				; optimize OK (Mind Field.pas), line = 263
  1888
  1889 88F2 A9 40 8D 0E D4		mva #$40 ATARI.NMIEN
  1890
  1891 				; --- RepeatUntilProlog
  1892 88F7			l_04EF
  1893
  1894 				; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 265
  1895 88F7 20 78 85			jsr B_CRT.CRT_STARTPRESSED
  1896 88FA E8				inx
  1897 88FB A9 00 95 80			mva #$00 :STACKORIGIN,x
  1898 88FF A0 01			ldy #1
  1899 8901 B5 7F			lda :STACKORIGIN-1,x
  1900 8903 D5 80			cmp :STACKORIGIN,x
  1901 8905 F0 01			beq @+
  1902 8907 88				dey
  1903 8908			@
  1904 8908 94 7F			sty :STACKORIGIN-1,x
  1905 890A CA				dex
  1906 890B CA				dex
  1907 890C B5 81			lda :STACKORIGIN+1,x
  1908 890E D0 03			bne *+5
  1909 8910			c_04EF
  1910 8910 4C F7 88			jmp l_04EF
  1911 8913			b_04EF
  1912
  1913 				; ---------------------  ASM Block 078  ---------------------
  1914
  1915
  1916 				//    ORG 32768
  1917 				//    ICL "inflate_2017_ver4.asm"
  1918 				//    ORG 46080
  1919 				//    INS "roman10.fnt" 
  1920
  1921
  1922 				; -----------------------------------------------------------
  1923
  1924 = 0005			@FORTMP_1122	= $0005
  1925
  1926 8913			@exit
  1927 					.ifdef @new
  1928 					@FreeMem #@VarData #@VarDataSize
  1929 					eif
  1930 8913 60				rts						; ret
  1931 				.endl
  1932
  1933 8914			.local	INITIALIZE_LEVEL				; PROCEDURE
  1934
  1935 					ift l_04FE-*>3
  1936 					jmp l_04FE
  1937 					eif
  1938
  1939 				; IfThenEpilog
  1940 8914			l_04FE
  1941 				; For
  1942
  1943 				; optimize OK (Mind Field.pas), line = 280
  1944
  1945 8914 A9 00 8D 33 A3		mva #$00 I
  1946
  1947 				; optimize OK (Mind Field.pas), line = 280
  1948
  1949 				; To
  1950 8919			l_050D
  1951
  1952 				; ForToDoCondition
  1953
  1954 				; optimize OK (Mind Field.pas), line = 280
  1955
  1956 8919 AD 33 A3			lda I
  1957 891C C9 FF			cmp #$FF
  1958 891E 90 05			bcc *+7
  1959 8920 F0 03			beq *+5
  1960
  1961 				; ForToDoProlog
  1962 8922 4C 49 89			jmp l_051B
  1963
  1964 				; ---------------------  ASM Block 079  ---------------------
  1965
  1966
  1967 8925 AD 0A D2			LDA RANDOM
  1968 8928 18				CLC
  1969 8929 69 28			ADC #<game_screen
  1970 892B 85 EA			STA NDX0
  1971 892D AD 0A D2			LDA RANDOM
  1972 8930 29 03			AND #3
  1973 8932 69 08			ADC #>game_screen
  1974 8934 85 EB			STA NDX1
  1975 8936 AD 0A D2			LDA RANDOM
  1976 8939 29 03			AND #3
  1977 893B 09 44			ORA #68
  1978 893D A0 00			LDY #0
  1979 893F 91 EA			STA (NDX0),Y
  1980
  1981
  1982 				; ForToDoEpilog
  1983 8941			c_050D
  1984 8941 EE 33 A3			inc I						; inc ptr byte [CounterAddress]
  1985
  1986 8944 F0 03			seq
  1987
  1988 				; WhileDoEpilog
  1989 8946 4C 19 89			jmp l_050D
  1990 8949			l_051B
  1991 8949			b_050D
  1992 				; For
  1993
  1994 				; optimize OK (Mind Field.pas), line = 300
  1995
  1996 8949 A9 00 8D 33 A3		mva #$00 I
  1997
  1998 				; optimize OK (Mind Field.pas), line = 300
  1999
  2000 				; To
  2001 894E			l_052F
  2002
  2003 				; ForToDoCondition
  2004
  2005 				; optimize OK (Mind Field.pas), line = 300
  2006
  2007 894E AD 33 A3			lda I
  2008 8951 C9 3F			cmp #$3F
  2009 8953 90 05			bcc *+7
  2010 8955 F0 03			beq *+5
  2011
  2012 				; ForToDoProlog
  2013 8957 4C 79 89			jmp l_053D
  2014
  2015 				; ---------------------  ASM Block 080  ---------------------
  2016
  2017
  2018 895A AD 0A D2			LDA RANDOM
  2019 895D 18				CLC
  2020 895E 69 28			ADC #<game_screen
  2021 8960 85 EA			STA NDX0
  2022 8962 AD 0A D2			LDA RANDOM
  2023 8965 29 03			AND #3
  2024 8967 69 08			ADC #>game_screen
  2025 8969 85 EB			STA NDX1
  2026 896B A9 C1			LDA #193
  2027 896D A0 00			LDY #0
  2028 896F 91 EA			STA (NDX0),Y
  2029
  2030
  2031 				; ForToDoEpilog
  2032 8971			c_052F
  2033 8971 EE 33 A3			inc I						; inc ptr byte [CounterAddress]
  2034
  2035 8974 F0 03			seq
  2036
  2037 				; WhileDoEpilog
  2038 8976 4C 4E 89			jmp l_052F
  2039 8979			l_053D
  2040 8979			b_052F
  2041
  2042 				; -----------------------------------------------------------
  2043
  2044 = 00FF			@FORTMP_1287	= $00FF
  2045 = 003F			@FORTMP_1321	= $003F
  2046
  2047 8979			@exit
  2048 					.ifdef @new
  2049 					@FreeMem #@VarData #@VarDataSize
  2050 					eif
  2051 8979 60				rts						; ret
  2052 				.endl
  2053
  2054 897A			.local	DISPLAY_INFORMATION_LINE			; PROCEDURE
  2055
  2056 					ift l_0546-*>3
  2057 					jmp l_0546
  2058 					eif
  2059
  2060 				; IfThenEpilog
  2061 897A			l_0546
  2062
  2063 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 320
  2064 897A E8				inx
  2065 897B A9 00 95 80			mva #$00 :STACKORIGIN,x
  2066 897F E8				inx
  2067 8980 95 80			sta :STACKORIGIN,x
  2068 8982 20 5A 84			jsr B_CRT.CRT_GOTOXY
  2069
  2070 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 321
  2071 8985 E8				inx
  2072 8986 A9 0E 95 80			mva #$0E :STACKORIGIN,x
  2073 898A A9 81 95 90			mva #$81 :STACKORIGIN+STACKWIDTH,x
  2074 898E 20 93 84			jsr B_CRT.CRT_WRITE_0284
  2075
  2076 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 322
  2077 8991 E8				inx
  2078 8992 A9 06 95 80			mva #$06 :STACKORIGIN,x
  2079 8996 E8				inx
  2080 8997 A9 00 95 80			mva #$00 :STACKORIGIN,x
  2081 899B 20 5A 84			jsr B_CRT.CRT_GOTOXY
  2082
  2083 				; optimize FAIL ('B_CRT.CRT_WRITE_02BE', Mind Field.pas), line = 323
  2084 899E E8				inx
  2085 899F AD 38 A3 95 80		mva SCORE :STACKORIGIN,x
  2086 89A4 AD 39 A3 95 90		mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
  2087 89A9 20 34 85			jsr B_CRT.CRT_WRITE_02BE
  2088
  2089 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 325
  2090 89AC E8				inx
  2091 89AD A9 0E 95 80			mva #$0E :STACKORIGIN,x
  2092 89B1 E8				inx
  2093 89B2 A9 00 95 80			mva #$00 :STACKORIGIN,x
  2094 89B6 20 5A 84			jsr B_CRT.CRT_GOTOXY
  2095
  2096 				; optimize FAIL ('B_CRT.CRT_WRITE_0284', Mind Field.pas), line = 326
  2097 89B9 E8				inx
  2098 89BA A9 16 95 80			mva #$16 :STACKORIGIN,x
  2099 89BE A9 81 95 90			mva #$81 :STACKORIGIN+STACKWIDTH,x
  2100 89C2 20 93 84			jsr B_CRT.CRT_WRITE_0284
  2101
  2102 				; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 327
  2103 89C5 E8				inx
  2104 89C6 A9 14 95 80			mva #$14 :STACKORIGIN,x
  2105 89CA E8				inx
  2106 89CB A9 00 95 80			mva #$00 :STACKORIGIN,x
  2107 89CF 20 5A 84			jsr B_CRT.CRT_GOTOXY
  2108
  2109 				; optimize FAIL ('B_CRT.CRT_WRITE_02AE', Mind Field.pas), line = 328
  2110 89D2 E8				inx
  2111 89D3 AD 3A A3 95 80		mva LIVES :STACKORIGIN,x
  2112 89D8 20 1B 85			jsr B_CRT.CRT_WRITE_02AE
  2113
  2114 89DB			@exit
  2115 					.ifdef @new
  2116 					@FreeMem #@VarData #@VarDataSize
  2117 					eif
  2118 89DB 60				rts						; ret
  2119 				.endl
  2120
  2121 				; IfThenEpilog
  2122 89DC			l_0125
  2123
  2124 				; --- RepeatUntilProlog
  2125 89DC			l_055F
  2126
  2127 				; optimize FAIL ('SHOWTITLESCREEN', Mind Field.pas), line = 341
  2128 89DC 20 0C 86			jsr SHOWTITLESCREEN
  2129
  2130 				; optimize OK (Mind Field.pas), line = 344
  2131
  2132 89DF A9 00 8D 38 A3		mva #$00 SCORE
  2133 89E4 8D 39 A3			sta SCORE+1
  2134
  2135 				; optimize OK (Mind Field.pas), line = 345
  2136
  2137 89E7 A9 05 8D 3A A3		mva #$05 LIVES
  2138
  2139 				; optimize FAIL ('B_CRT.CRT_INIT_01FA', Mind Field.pas), line = 346
  2140 89EC E8				inx
  2141 89ED A9 00 95 80			mva #$00 :STACKORIGIN,x
  2142 89F1 A9 08 95 90			mva #$08 :STACKORIGIN+STACKWIDTH,x
  2143 89F5 E8				inx
  2144 89F6 A9 28 95 80			mva #$28 :STACKORIGIN,x
  2145 89FA E8				inx
  2146 89FB A9 1A 95 80			mva #$1A :STACKORIGIN,x
  2147 89FF 20 DA 83			jsr B_CRT.CRT_INIT_01FA
  2148
  2149 				; optimize FAIL ('B_CRT.CRT_CLEAR_0248', Mind Field.pas), line = 347
  2150 8A02 20 32 84			jsr B_CRT.CRT_CLEAR_0248
  2151
  2152 				; optimize FAIL ('DISPLAY_INFORMATION_LINE', Mind Field.pas), line = 348
  2153 8A05 20 7A 89			jsr DISPLAY_INFORMATION_LINE
  2154
  2155 				; optimize OK (Mind Field.pas), line = 349
  2156
  2157 8A08 A9 53 8D 02 D4		mva #$53 ATARI.DLISTW
  2158 8A0D A9 82 8D 03 D4		mva #$82 ATARI.DLISTW+1
  2159
  2160 				; optimize OK (Mind Field.pas), line = 350
  2161
  2162 8A12 A9 53 8D 30 02		mva #$53 ATARI.SDLSTW
  2163 8A17 A9 82 8D 31 02		mva #$82 ATARI.SDLSTW+1
  2164
  2165 				; optimize OK (Mind Field.pas), line = 351
  2166
  2167 8A1C A9 00 85 58			mva #$00 ATARI.SAVMSC
  2168 8A20 A9 08 85 59			mva #$08 ATARI.SAVMSC+1
  2169
  2170 				; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 352
  2171 8A24 E8				inx
  2172 8A25 A9 A4 95 80			mva #$A4 :STACKORIGIN,x
  2173 8A29 20 F2 82			jsr B_SYSTEM.SETCHARSET
  2174
  2175 				; optimize OK (Mind Field.pas), line = 353
  2176
  2177 8A2C A9 A4 8D F4 02		mva #$A4 ATARI.CHBAS
  2178
  2179 				; optimize FAIL ('INITIALIZE_LEVEL', Mind Field.pas), line = 354
  2180 8A31 20 14 89			jsr INITIALIZE_LEVEL
  2181
  2182 				; optimize OK (Mind Field.pas), line = 355
  2183
  2184 8A34 A9 8E 8D C4 02		mva #$8E ATARI.COLOR0
  2185
  2186 				; optimize OK (Mind Field.pas), line = 356
  2187
  2188 8A39 A9 D4 8D C5 02		mva #$D4 ATARI.COLOR1
  2189
  2190 				; optimize OK (Mind Field.pas), line = 357
  2191
  2192 8A3E A9 46 8D C6 02		mva #$46 ATARI.COLOR2
  2193
  2194 				; optimize OK (Mind Field.pas), line = 358
  2195
  2196 8A43 A9 96 8D C7 02		mva #$96 ATARI.COLOR3
  2197
  2198 				; optimize OK (Mind Field.pas), line = 359
  2199
  2200 8A48 A9 22 8D C8 02		mva #$22 ATARI.COLOR4
  2201
  2202 				; --- RepeatUntilProlog
  2203 8A4D			l_05B7
  2204
  2205 				; optimize FAIL ('B_CRT.CRT_KEYPRESSED', Mind Field.pas), line = 366
  2206 8A4D 20 57 85			jsr B_CRT.CRT_KEYPRESSED
  2207 8A50 CA				dex
  2208 8A51 B5 81			lda :STACKORIGIN+1,x
  2209 8A53 D0 03			bne *+5
  2210 8A55			c_05B7
  2211 8A55 4C 4D 8A			jmp l_05B7
  2212 8A58			b_05B7
  2213
  2214 				; optimize OK (Mind Field.pas), line = 368
  2215
  2216 8A58 A9 00			lda #$00
  2217 8A5A D0 03			bne *+5
  2218 8A5C			c_055F
  2219 8A5C 4C DC 89			jmp l_055F
  2220 8A5F			b_055F
  2221
  2222 				; -----------------------------------------------------------
  2223
  2224 = 0800			SCREEN_ADDR	= $0800
  2225 = 0828			GAME_SCREEN	= $0828
  2226 = 1000			PMBANK	= $1000
  2227 = 1800			VARBANK	= $1800
  2228 = A400			CHARSET_GAME	= $A400
  2229 = A800			CHARSET_TITLE	= $A800
  2230 = AC00			TITLE_DATA	= $AC00
  2231 = 00A4			CHARSET_BASE	= $00A4
  2232 = 821E			adr.DISPLAY_LIST_TITLE	= CODEORIGIN+$021E
  2233 8A5F			.var DISPLAY_LIST_TITLE	= adr.DISPLAY_LIST_TITLE .word
  2234 = 8253			adr.DISPLAY_LIST_GAME	= CODEORIGIN+$0253
  2235 8A5F			.var DISPLAY_LIST_GAME	= adr.DISPLAY_LIST_GAME .word
  2236 = D01B			PRIOR	= $D01B
  2237 = 00E0			TMP0	= $00E0
  2238 = 00E1			TMP1	= $00E1
  2239 = 00E2			TMP2	= $00E2
  2240 = 00E3			TMP3	= $00E3
  2241 = 00E4			TMP4	= $00E4
  2242 = 00E5			TMP5	= $00E5
  2243 = 00E6			TMP6	= $00E6
  2244 = 00E7			TMP7	= $00E7
  2245 = 00E8			TMP8	= $00E8
  2246 = 00E9			TMP9	= $00E9
  2247 = 00EA			NDX0	= $00EA
  2248 = 00EB			NDX1	= $00EB
  2249 = 00EC			NDX2	= $00EC
  2250 = 00ED			NDX3	= $00ED
  2251 = 00EE			HOLDX	= $00EE
  2252 = 00EF			HOLDY	= $00EF
  2253 = 1180			SPRITENUM	= $1180
  2254 = 1190			SETSP0COLOR	= $1190
  2255 = 11A0			SETSP1COLOR	= $11A0
  2256 = 11B0			SETSPWIDTH	= $11B0
  2257 = 11C0			SPRITENHOZ	= $11C0
  2258 = 11E0			SPRITENVRT	= $11E0
  2259 = 11F0			SPHOZNEXT	= $11F0
  2260 = 1000			SCREEN_LINE_ADDR_LOW	= $1000
  2261 = 1020			SCREEN_LINE_ADDR_HIGH	= $1020
  2262 = 1200			SPRHZ0	= $1200
  2263 = 1210			SPRHZ1	= $1210
  2264 = 1220			SPRHZ2	= $1220
  2265 = 1230			SPRHZ3	= $1230
  2266 = 1240			SPZONT	= $1240
  2267 = 1250			SPZONB	= $1250
  2268 = 1260			SPSRC0	= $1260
  2269 = 1278			SPSRC1	= $1278
  2270 = 1290			SPSRC2	= $1290
  2271 = 12A8			SPSRC3	= $12A8
  2272 = 12C0			SPSRC4	= $12C0
  2273 = 12D8			SPRITEUSE	= $12D8
  2274 = 1300			MIBANK	= $1300
  2275 = 1400			PMBNK0	= $1400
  2276 = 1500			PMBNK1	= $1500
  2277 = 1600			PMBNK2	= $1600
  2278 = 1700			PMBNK3	= $1700
  2279 = A32B			A	= DATAORIGIN+$032B
  2280 = A32C			B	= DATAORIGIN+$032C
  2281 = A32D			C	= DATAORIGIN+$032D
  2282 = A32E			D	= DATAORIGIN+$032E
  2283 = A32F			E	= DATAORIGIN+$032F
  2284 = A330			F	= DATAORIGIN+$0330
  2285 = A331			G	= DATAORIGIN+$0331
  2286 = A332			H	= DATAORIGIN+$0332
  2287 = A333			I	= DATAORIGIN+$0333
  2288 = A334			J	= DATAORIGIN+$0334
  2289 = A335			K	= DATAORIGIN+$0335
  2290 = A336			L	= DATAORIGIN+$0336
  2291 = A337			TITLEPHASE	= DATAORIGIN+$0337
  2292 = A338			SCORE	= DATAORIGIN+$0338
  2293 = A33A			LIVES	= DATAORIGIN+$033A
  2294 = A33B			adr.HISCORE	= DATAORIGIN+$033B
  2295 8A5F			.var HISCORE	= adr.HISCORE .word
  2296 = A351			TOPMEM	= DATAORIGIN+$0351
  2297 = A353			CHBASE1	= DATAORIGIN+$0353
  2298
  2299 8A5F			@exit
  2300
  2301 8A5F A2 00		@halt	ldx #0
  2302 8A61 9A				txs
  2303
  2304 8A62 60				rts
  2305
  2306 8A63 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  2307
  2308 8A73			.local	@DEFINES
  2309 8A73			ATARI
  2310 8A73			PLATFORM_ATARI_ANTIC
  2311 8A73			PLATFORM_ATARI_8_BIT
  2312 				.endl
  2313
  2314 = 8A73 1E 82		DISPLAY_LIST_TITLE
  2314 = 8A75 53 82		DISPLAY_LIST_GAME
  2314 = 8A77 3B A3		HISCORE
  2314 				.endl
  2315
  2316 				; -----------------------------------------------------------
  2317
  2318 8A79				icl 'cpu6502.asm'
Source: cpu6502.asm
   296 					opt l+
   239 					opt l+
   240
   241
   242
   243 				/* ----------------------------------------------------------------------- */
   244
   245
   246
   247 8A79			.proc	hiBYTE
   248 					lda :STACKORIGIN,x
   249 8A79				:4 lsr @
   250 					sta :STACKORIGIN,x
   251 					rts
   252 				.endp
   253
   254 8A79			.proc	hiWORD
   255 					lda :STACKORIGIN+STACKWIDTH,x
   256 					sta :STACKORIGIN,x
   257 					rts
   258 				.endp
   259
   260 8A79			.proc	hiCARD
   261 					lda :STACKORIGIN+STACKWIDTH*3,x
   262 					sta :STACKORIGIN+STACKWIDTH,x
   263
   264 					lda :STACKORIGIN+STACKWIDTH*2,x
   265 					sta :STACKORIGIN,x
   266 					rts
   267 				.endp
   268
   269
   270 8A79			.proc	movaBX_EAX		; mov [BX], EAX
   271 8A79				:MAXSIZE mva eax+# :STACKORIGIN-1+#*STACKWIDTH,x
   272 					rts
   273 				.endp
   274
   275 				/*
   276 				.proc	@pushBYTE
   277 					adc :STACKORIGIN+STACKWIDTH,x
   278 					sta bp+1
   279
   280 					mva (bp),y :STACKORIGIN,x
   281
   282 				;	lda #$00
   283 				;	sta :STACKORIGIN+STACKWIDTH,x
   284 				;	sta :STACKORIGIN+STACKWIDTH*2,x
   285 				;	sta :STACKORIGIN+STACKWIDTH*3,x
   286
   287 					rts
   288 				.endp
   289
   290
   291 				.proc	@pullWORD (.word ya) .reg
   292 					add :STACKORIGIN-1,x
   293 					sta bp2
   294 					tya
   295 					adc :STACKORIGIN-1+STACKWIDTH,x
   296 					sta bp2+1
   297
   298 					ldy #$00
   299
   300 					mva :STACKORIGIN,x (bp2),y
   301 					iny
   302 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   303
   304 					rts
   305 				.endp
   306
   307
   308 				.proc	@pullCARD (.word ya) .reg
   309 					add :STACKORIGIN-1,x
   310 					sta bp2
   311 					tya
   312 					adc :STACKORIGIN-1+STACKWIDTH,x
   313 					sta bp2+1
   314
   315 					ldy #$00
   316
   317 					mva :STACKORIGIN,x (bp2),y
   318 					iny
   319 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   320 					iny
   321 					mva :STACKORIGIN+STACKWIDTH*2,x (bp2),y
   322 					iny
   323 					mva :STACKORIGIN+STACKWIDTH*3,x (bp2),y
   324
   325 					rts
   326 				.endp
   327
   328
   329 				.proc	@pushWORD (.word ya) .reg
   330 					add :STACKORIGIN,x
   331 					sta bp2
   332 					tya
   333 					adc :STACKORIGIN+STACKWIDTH,x
   334 					sta bp2+1
   335
   336 					ldy #$00
   337
   338 					mva (bp2),y :STACKORIGIN,x
   339 					iny
   340 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   341
   342 					rts
   343 				.endp
   344
   345
   346 				.proc	@pushCARD (.word ya) .reg
   347 					add :STACKORIGIN,x
   348 					sta bp2
   349 					tya
   350 					adc :STACKORIGIN+STACKWIDTH,x
   351 					sta bp2+1
   352
   353 					ldy #$00
   354
   355 					mva (bp2),y :STACKORIGIN,x
   356 					iny
   357 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   358 					iny
   359 					mva (bp2),y :STACKORIGIN+STACKWIDTH*2,x
   360 					iny
   361 					mva (bp2),y :STACKORIGIN+STACKWIDTH*3,x
   362
   363 					rts
   364 				.endp
   365 				*/
   365
   366
   367 8A79			.proc	shlEAX_CL
   368
   369 				;SHORT	jsr @expandToCARD1.SHORT
   370 				;	jmp CARD
   371
   372 				;SMALL	jsr @expandToCARD1.SMALL
   373 				;	jmp CARD
   374
   375 8A79			BYTE	lda #0
   376 					sta :STACKORIGIN-1+STACKWIDTH,x
   377
   378 8A79			WORD	lda #0
   379 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   380 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   381
   382 8A79			CARD	clc
   383 					ldy :STACKORIGIN,x	; cl
   384 					beq stop
   385 8A79			@	asl :STACKORIGIN-1,x	; eax
   386 					rol :STACKORIGIN-1+STACKWIDTH,x
   387 					rol :STACKORIGIN-1+STACKWIDTH*2,x
   388 					rol :STACKORIGIN-1+STACKWIDTH*3,x
   389 					dey
   390 					bne @-
   391
   392 8A79			stop	rts
   393 				.endp
   394
   395
   396 8A79			.proc	shrAL_CL
   397
   398 				;SHORT	jsr @expandToCARD1.SHORT
   399 				;	jmp shrEAX_CL
   400
   401 8A79			BYTE	ldy :STACKORIGIN,x	; cl
   402 					beq stop
   403 8A79			@	lsr :STACKORIGIN-1,x
   404 					dey
   405 					bne @-
   406
   407 8A79			stop	lda #0
   408 					sta :STACKORIGIN-1+STACKWIDTH,x
   409 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   410 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   411
   412 					rts
   413 				.endp
   414
   415 8A79			.proc	shrAX_CL
   416
   417 				;SMALL	jsr @expandToCARD1.SMALL
   418 				;	jmp shrEAX_CL
   419
   420 8A79			WORD	ldy :STACKORIGIN,x	; cl
   421 					beq stop
   422 8A79			@	lsr :STACKORIGIN-1+STACKWIDTH,x
   423 					ror :STACKORIGIN-1,x
   424 					dey
   425 					bne @-
   426
   427 8A79			stop	lda #0
   428 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   429 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   430
   431 					rts
   432 				.endp
   433
   434 8A79			.proc	shrEAX_CL
   435
   436 					ldy :STACKORIGIN,x	; cl
   437 					beq stop
   438 8A79			@	lsr :STACKORIGIN-1+STACKWIDTH*3,x
   439 					ror :STACKORIGIN-1+STACKWIDTH*2,x
   440 					ror :STACKORIGIN-1+STACKWIDTH,x
   441 					ror :STACKORIGIN-1,x
   442 					dey
   443 					bne @-
   444
   445 8A79			stop	rts
   446 				.endp
   447
   448 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   449 				; wynik operacji ADD zostanie potraktowany jako INTEGER / CARDINAL
   450 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   451
   452 8A79			.proc	addAL_CL
   453
   454 8A79 A0 00			ldy #0
   455 8A7B 98				tya
   456 8A7C 95 9F			sta :STACKORIGIN-1+STACKWIDTH*2,x
   457 8A7E 95 AF			sta :STACKORIGIN-1+STACKWIDTH*3,x
   458
   459 8A80 B5 7F			lda :STACKORIGIN-1,x
   460 8A82 18 75 80			add :STACKORIGIN,x
   461 8A85 95 7F			sta :STACKORIGIN-1,x
   462 8A87 90 01			scc
   463 8A89 C8				iny
   464 8A8A 98			  tya
   465 8A8B 95 8F			sta :STACKORIGIN-1+STACKWIDTH,x
   466
   467 8A8D 60				rts
   468 				.endp
   469
   470 8A8E			.proc	addAX_CX
   471
   472 					ldy #0
   473
   474 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   475
   476 					lda :STACKORIGIN-1,x
   477 					add :STACKORIGIN,x
   478 					sta :STACKORIGIN-1,x
   479
   480 					lda :STACKORIGIN-1+STACKWIDTH,x
   481 					adc :STACKORIGIN+STACKWIDTH,x
   482 					sta :STACKORIGIN-1+STACKWIDTH,x
   483 					scc
   484 					iny
   485
   486 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   487
   488 					rts
   489 				.endp
   490
   491
   492 8A8E			.proc	addEAX_ECX
   493 				/*
   494 				SHORT	jsr @expandToCARD.SHORT
   495 					jsr @expandToCARD1.SHORT
   496 					jmp CARD
   497
   498 				SMALL	jsr @expandToCARD.SMALL
   499 					jsr @expandToCARD1.SMALL
   500 				*/
   500
   501 8A8E			CARD	lda :STACKORIGIN-1,x
   502 					add :STACKORIGIN,x
   503 					sta :STACKORIGIN-1,x
   504
   505 					lda :STACKORIGIN-1+STACKWIDTH,x
   506 					adc :STACKORIGIN+STACKWIDTH,x
   507 					sta :STACKORIGIN-1+STACKWIDTH,x
   508
   509 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   510 					adc :STACKORIGIN+STACKWIDTH*2,x
   511 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   512
   513 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   514 					adc :STACKORIGIN+STACKWIDTH*3,x
   515 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   516
   517 					rts
   518 				.endp
   519
   520
   521 8A8E			.proc	subAL_CL
   522
   523 					ldy #0
   524
   525 					lda :STACKORIGIN-1,x
   526 					sub :STACKORIGIN,x
   527 					sta :STACKORIGIN-1,x
   528 					scs
   529 					dey
   530
   531 					sty :STACKORIGIN-1+STACKWIDTH,x
   532 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   533 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   534
   535 					rts
   536 				.endp
   537
   538 8A8E			.proc	subAX_CX
   539
   540 					ldy #0
   541
   542 					lda :STACKORIGIN-1,x		; ax
   543 					sub :STACKORIGIN,x		; cx
   544 					sta :STACKORIGIN-1,x
   545
   546 					lda :STACKORIGIN-1+STACKWIDTH,x
   547 					sbc :STACKORIGIN+STACKWIDTH,x
   548 					sta :STACKORIGIN-1+STACKWIDTH,x
   549 					scs
   550 					dey
   551
   552 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   553 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   554
   555 					rts
   556 				.endp
   557
   558 8A8E			.proc	subEAX_ECX
   559
   560 					lda :STACKORIGIN-1,x
   561 					sub :STACKORIGIN,x
   562 					sta :STACKORIGIN-1,x
   563
   564 					lda :STACKORIGIN-1+STACKWIDTH,x
   565 					sbc :STACKORIGIN+STACKWIDTH,x
   566 					sta :STACKORIGIN-1+STACKWIDTH,x
   567
   568 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   569 					sbc :STACKORIGIN+STACKWIDTH*2,x
   570 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   571
   572 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   573 					sbc :STACKORIGIN+STACKWIDTH*3,x
   574 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   575
   576 					rts
   577 				.endp
   578
   579
   580 8A8E			.proc	@expandSHORT2SMALL
   581 					ldy #$00
   582 					lda :STACKORIGIN,x
   583 					spl
   584 					dey
   585 					sty :STACKORIGIN+STACKWIDTH,x
   586
   587 					rts
   588 				.endp
   589
   590 8A8E			.proc	@expandSHORT2SMALL1
   591 					ldy #$00
   592 					lda :STACKORIGIN-1,x
   593 					spl
   594 					dey
   595 					sty :STACKORIGIN-1+STACKWIDTH,x
   596
   597 					rts
   598 				.endp
   599
   600
   601 8A8E			.proc	@expandToCARD
   602
   603 8A8E B5 90		SMALL	lda :STACKORIGIN+STACKWIDTH,x
   604 8A90 10 04			bpl WORD
   605
   606 8A92 A9 FF			lda #$ff
   607 8A94 D0 10			bne _wo
   608
   609 8A96 A9 00		WORD	lda #$00
   610 8A98 F0 0C			beq _wo
   611
   612 8A9A B5 80		SHORT	lda :STACKORIGIN,x
   613 8A9C 10 04			bpl BYTE
   614
   615 8A9E A9 FF			lda #$ff
   616 8AA0 D0 02			bne _by
   617
   618 8AA2 A9 00		BYTE	lda #$00
   619
   620 8AA4 95 90		_by	sta :STACKORIGIN+STACKWIDTH,x
   621 8AA6 95 A0		_wo	sta :STACKORIGIN+STACKWIDTH*2,x
   622 8AA8 95 B0		_lo	sta :STACKORIGIN+STACKWIDTH*3,x
   623 8AAA 60				rts
   624 				.endp
   625
   626
   627 8AAB			.proc	@expandToCARD1
   628
   629 8AAB			SMALL	lda :STACKORIGIN-1+STACKWIDTH,x
   630 					bpl WORD
   631
   632 					lda #$ff
   633 					bne _wo
   634
   635 8AAB			WORD	lda #$00
   636 					beq _wo
   637
   638 8AAB			SHORT	lda :STACKORIGIN-1,x
   639 					bpl BYTE
   640
   641 					lda #$ff
   642 					bne _by
   643
   644 8AAB			BYTE	lda #$00
   645
   646 8AAB			_by	sta :STACKORIGIN-1+STACKWIDTH,x
   647 8AAB			_wo	sta :STACKORIGIN-1+STACKWIDTH*2,x
   648 8AAB			_lo	sta :STACKORIGIN-1+STACKWIDTH*3,x
   649 					rts
   650 				.endp
   651
   652 				/*
   653 				.proc	@cmpFor_WORD (.word ya) .reg
   654 					sta ztmp
   655 					sty ztmp+1
   656
   657 					ldy #1
   658 					lda (ztmp),y
   659 					cmp :STACKORIGIN+1+STACKWIDTH,x
   660 					bne stop
   661 					dey
   662 					lda (ztmp),y
   663 					cmp :STACKORIGIN+1,x
   664 				stop	rts
   665 				.endp
   666
   667
   668 				.proc	@cmpFor_CARD (.word ya) .reg
   669 					sta ztmp
   670 					sty ztmp+1
   671
   672 					ldy #3
   673 					lda (ztmp),y
   674 					cmp :STACKORIGIN+1+STACKWIDTH*3,x
   675 					bne stop
   676 					dey
   677 					lda (ztmp),y
   678 					cmp :STACKORIGIN+1+STACKWIDTH*2,x
   679 					bne stop
   680 					dey
   681 					lda (ztmp),y
   682 					cmp :STACKORIGIN+1+STACKWIDTH,x
   683 					bne stop
   684 					dey
   685 					lda (ztmp),y
   686 					cmp :STACKORIGIN+1,x
   687
   688 				stop	rts
   689 				.endp
   690
   691
   692 				.proc	@cmpFor_SHORTINT(.word ya) .reg
   693 					sta ztmp
   694 					sty ztmp+1
   695
   696 					ldy	#0
   697 					lda	(ztmp),y
   698 					sec
   699 					sbc	:STACKORIGIN+1,x
   700 					bne	@cmpFor_INT.L4
   701
   702 					jmp	@cmpFor_INT.L1
   703 				.endp
   704
   705
   706 				.proc	@cmpFor_SMALLINT(.word ya) .reg
   707 					sta ztmp
   708 					sty ztmp+1
   709
   710 					ldy	#1
   711 					lda	(ztmp),y
   712 					sec
   713 					sbc	:STACKORIGIN+1+STACKWIDTH,x
   714 					bne	@cmpFor_INT.L4
   715
   716 					dey
   717 					lda	(ztmp),y
   718 					cmp	:STACKORIGIN+1,x
   719
   720 					jmp	@cmpFor_INT.L1
   721 				.endp
   722
   723
   724 				.proc	@cmpFor_INT(.word ya) .reg
   725 					sta ztmp
   726 					sty ztmp+1
   727
   728 					ldy	#3
   729 					lda	(ztmp),y
   730 					sec
   731 					sbc	:STACKORIGIN+1+STACKWIDTH*3,x
   732 					bne	L4
   733
   734 					dey
   735 					lda	(ztmp),y
   736 					cmp	:STACKORIGIN+1+STACKWIDTH*2,x
   737 					bne	L1
   738
   739 					dey
   740 					lda	(ztmp),y
   741 					cmp	:STACKORIGIN+1+STACKWIDTH,x
   742 					bne	L1
   743
   744 					dey
   745 					lda	(ztmp),y
   746 					cmp	:STACKORIGIN+1,x
   747
   748 				L1	beq	L2
   749 					bcs	L3
   750
   751 					lda	#$FF	; Set the N flag
   752 				L2	rts
   753
   754 				L3	lda	#$01	; Clear the N flag
   755 					rts
   756
   757 				L4	bvc	L5
   758 					eor	#$FF	; Fix the N flag if overflow
   759 					ora	#$01	; Clear the Z flag
   760 				L5	rts
   761 				.endp
   762 				*/
   762
   763
   764 				; Piotr Fusik, 15.04.2002
   765 				; originally by Ullrich von Bassewitz
   766
   767 8AAB			.proc	cmpSHORTINT
   768 					lda	:STACKORIGIN-1,x
   769 					clv:sec
   770 					sbc	:STACKORIGIN,x
   771 					bne	cmpINT.L4
   772
   773 					jmp	cmpINT.L1
   774 				.endp
   775
   776
   777 8AAB			.proc	cmpSMALLINT
   778 					lda	:STACKORIGIN-1+STACKWIDTH,x
   779 					clv:sec
   780 					sbc	:STACKORIGIN+STACKWIDTH,x
   781 					bne	cmpINT.L4
   782
   783 					lda	:STACKORIGIN-1,x
   784 					cmp	:STACKORIGIN,x
   785
   786 					jmp	cmpINT.L1
   787 				.endp
   788
   789
   790 8AAB			.proc	cmpINT
   791 					lda	:STACKORIGIN-1+STACKWIDTH*3,x
   792 					clv:sec
   793 					sbc	:STACKORIGIN+STACKWIDTH*3,x
   794 					bne	L4
   795
   796 					lda	:STACKORIGIN-1+STACKWIDTH*2,x
   797 					cmp	:STACKORIGIN+STACKWIDTH*2,x
   798 					bne	L1
   799
   800 					lda	:STACKORIGIN-1+STACKWIDTH,x
   801 					cmp	:STACKORIGIN+STACKWIDTH,x
   802 					bne	L1
   803
   804 					lda	:STACKORIGIN-1,x
   805 					cmp	:STACKORIGIN,x
   806
   807 8AAB			L1	beq	L2
   808 					bcs	L3
   809
   810 					lda	#$FF	; Set the N flag
   811 8AAB			L2	rts
   812
   813 8AAB			L3	lda	#$01	; Clear the N flag
   814 					rts
   815
   816 8AAB			L4	bvc	L5
   817 					eor	#$FF	; Fix the N flag if overflow
   818 					ora	#$01	; Clear the Z flag
   819 8AAB			L5	rts
   820 				.endp
   821
   822
   823 8AAB			.proc	cmpEAX_ECX
   824 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   825 					cmp :STACKORIGIN+STACKWIDTH*3,x
   826 					bne _done
   827 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   828 					cmp :STACKORIGIN+STACKWIDTH*2,x
   829 					bne _done
   830 8AAB			AX_CX
   831 					lda :STACKORIGIN-1+STACKWIDTH,x
   832 					cmp :STACKORIGIN+STACKWIDTH,x
   833 					bne _done
   834 					lda :STACKORIGIN-1,x
   835 					cmp :STACKORIGIN,x
   836
   837 8AAB			_done	rts
   838 				.endp
   839
   840
   841 8AAB			.proc	cmpSTRING2CHAR
   842
   843 					lda :STACKORIGIN-1,x
   844 					sta ztmp8
   845 					lda :STACKORIGIN-1+STACKWIDTH,x
   846 					sta ztmp8+1
   847
   848 					lda :STACKORIGIN,x
   849 					sta ztmp10
   850
   851 					ldy #0
   852
   853 					lda (ztmp8),y		; if length <> 1
   854 					cmp #1
   855 					bne fail
   856
   857 					iny
   858
   859 8AAB			loop	lda (ztmp8),y
   860 					cmp ztmp10
   861 					bne fail
   862
   863 					lda #0
   864 					seq
   865
   866 8AAB			fail	lda #$ff
   867
   868 					ldy #1
   869
   870 					cmp #0
   871 					rts
   872 				.endp
   873
   874
   875
   876 8AAB			.proc	cmpCHAR2STRING
   877
   878 					lda :STACKORIGIN-1,x
   879 					sta ztmp8
   880
   881 					lda :STACKORIGIN,x
   882 					sta ztmp10
   883 					lda :STACKORIGIN+STACKWIDTH,x
   884 					sta ztmp10+1
   885
   886 					ldy #0
   887
   888 					lda (ztmp10),y		; if length <> 1
   889 					cmp #1
   890 					bne fail
   891
   892 					iny
   893
   894 8AAB			loop	lda (ztmp10),y
   895 					cmp ztmp8
   896 					bne fail
   897
   898 					lda #0
   899 					seq
   900
   901 8AAB			fail	lda #$ff
   902
   903 					ldy #1
   904
   905 					cmp #0
   906 					rts
   907 				.endp
   908
   909
   910 8AAB			.proc	cmpSTRING
   911 				  max = ctmp0
   912 					lda :STACKORIGIN-1,x
   913 					sta ztmp8
   914 					lda :STACKORIGIN-1+STACKWIDTH,x
   915 					sta ztmp8+1
   916
   917 					lda :STACKORIGIN,x
   918 					sta ztmp10
   919 					lda :STACKORIGIN+STACKWIDTH,x
   920 					sta ztmp10+1
   921
   922 					l?? #0 ???  	rts    ???o  ? Y  ?   ???  .endp   ???B  ?       ???  	iny    ???  	iny    ???  	bne l3 ???  	bne l3 ???  .endp Y ???  	bne l3 ???  .endp   ???  .endp   ???  .endp  ????  	spl   ????  .endp Y ??? 
   923
   924 					lda (ztmp8),y		; if length1 = 0
   925 					beq fail
   926 					lda (ztmp10),y		; if length2 = 0
   927 					beq fail
   928
   929 					lda (ztmp8),y		; if length1 <> length2
   930 					cmp (ztmp10),y
   931 					bne fail
   932
   933 					sta max
   934
   935 					inw ztmp8
   936 					inw ztmp10
   937
   938 8AAB			loop	
   939 				  lda (ztmp8),y
   940 					cmp (ztmp10),y
   941 					bne fail
   942
   943 					iny
   944
   945
   946 					cpy max
   947 					bne loop
   948
   949 					lda #0
   950 					seq
   951
   952 8AAB			fail
   953 					lda #$ff
   954 					ldy #1
   955
   956 					cmp #0
   957 					rts
   958 				.endp
   959
   960
   961 8AAB			.proc	notaBX
   962
   963 					.rept MAXSIZE
   964 					LDA :STACKORIGIN+#*STACKWIDTH,X
   965 					EOR #$FF
   966 					STA :STACKORIGIN+#*STACKWIDTH,X
   967 					.ENDR
   967 					.endr
Source: REPT
   964 					LDA :STACKORIGIN+#*STACKWIDTH,X
   964 					EOR #$FF
   964 					STA :STACKORIGIN+#*STACKWIDTH,X
   964 					LDA :STACKORIGIN+#*STACKWIDTH,X
   964 					EOR #$FF
   964 					STA :STACKORIGIN+#*STACKWIDTH,X
   964 					LDA :STACKORIGIN+#*STACKWIDTH,X
   964 					EOR #$FF
   964 					STA :STACKORIGIN+#*STACKWIDTH,X
   964 					LDA :STACKORIGIN+#*STACKWIDTH,X
   964 					EOR #$FF
   964 					STA :STACKORIGIN+#*STACKWIDTH,X
Source: cpu6502.asm
   968
   969 					rts
   970 				.endp
   971
   972
   973 8AAB			.proc	notBOOLEAN
   974 					lda :STACKORIGIN,x
   975 					bne _0
   976
   977 					lda #true
   978 					sne
   979
   980 8AAB			_0	lda #false
   981 					sta :STACKORIGIN,x
   982
   983 					rts
   984 				.endp
   985
   986
   987 8AAB			.proc	negBYTE
   988 					lda #$00
   989 					sub :STACKORIGIN,x
   990 					sta :STACKORIGIN,x
   991
   992 					lda #$00
   993 					sbc #$00
   994 					sta :STACKORIGIN+STACKWIDTH,x
   995
   996 					lda #$00
   997 					sbc #$00
   998 					sta :STACKORIGIN+STACKWIDTH*2,x
   999
  1000 					lda #$00
  1001 					sbc #$00
  1002 					sta :STACKORIGIN+STACKWIDTH*3,x
  1003
  1004 					rts
  1005 				.endp
  1006
  1007 8AAB			.proc	negWORD
  1008 					lda #$00
  1009 					sub :STACKORIGIN,x
  1010 					sta :STACKORIGIN,x
  1011
  1012 					lda #$00
  1013 					sbc :STACKORIGIN+STACKWIDTH,x
  1014 					sta :STACKORIGIN+STACKWIDTH,x
  1015
  1016 					lda #$00
  1017 					sbc #$00
  1018 					sta :STACKORIGIN+STACKWIDTH*2,x
  1019
  1020 					lda #$00
  1021 					sbc #$00
  1022 					sta :STACKORIGIN+STACKWIDTH*3,x
  1023
  1024 					rts
  1025 				.endp
  1026
  1027 8AAB			.proc	negCARD
  1028 8AAB A9 00			lda #$00
  1029 8AAD 38 F5 80			sub :STACKORIGIN,x
  1030 8AB0 95 80			sta :STACKORIGIN,x
  1031
  1032 8AB2 A9 00			lda #$00
  1033 8AB4 F5 90			sbc :STACKORIGIN+STACKWIDTH,x
  1034 8AB6 95 90			sta :STACKORIGIN+STACKWIDTH,x
  1035
  1036 8AB8 A9 00			lda #$00
  1037 8ABA F5 A0			sbc :STACKORIGIN+STACKWIDTH*2,x
  1038 8ABC 95 A0			sta :STACKORIGIN+STACKWIDTH*2,x
  1039
  1040 8ABE A9 00			lda #$00
  1041 8AC0 F5 B0			sbc :STACKORIGIN+STACKWIDTH*3,x
  1042 8AC2 95 B0			sta :STACKORIGIN+STACKWIDTH*3,x
  1043
  1044 8AC4 60				rts
  1045 				.endp
  1046
  1047
  1048 8AC5			.proc	negBYTE1
  1049 					lda #$00
  1050 					sub :STACKORIGIN-1,x
  1051 					sta :STACKORIGIN-1,x
  1052
  1053 					lda #$00
  1054 					sbc #$00
  1055 					sta :STACKORIGIN-1+STACKWIDTH,x
  1056
  1057 					lda #$00
  1058 					sbc #$00
  1059 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1060
  1061 					lda #$00
  1062 					sbc #$00
  1063 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1064
  1065 					rts
  1066 				.endp
  1067
  1068 8AC5			.proc	negWORD1
  1069 					lda #$00
  1070 					sub :STACKORIGIN-1,x
  1071 					sta :STACKORIGIN-1,x
  1072
  1073 					lda #$00
  1074 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1075 					sta :STACKORIGIN-1+STACKWIDTH,x
  1076
  1077 					lda #$00
  1078 					sbc #$00
  1079 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1080
  1081 					lda #$00
  1082 					sbc #$00
  1083 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1084
  1085 					rts
  1086 				.endp
  1087
  1088 8AC5			.proc	negCARD1
  1089 					lda #$00
  1090 					sub :STACKORIGIN-1,x
  1091 					sta :STACKORIGIN-1,x
  1092
  1093 					lda #$00
  1094 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1095 					sta :STACKORIGIN-1+STACKWIDTH,x
  1096
  1097 					lda #$00
  1098 					sbc :STACKORIGIN-1+STACKWIDTH*2,x
  1099 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1100
  1101 					lda #$00
  1102 					sbc :STACKORIGIN-1+STACKWIDTH*3,x
  1103 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1104
  1105 					rts
  1106 				.endp
  1107
  1108
  1109 8AC5			.proc	andAL_CL
  1110
  1111 					lda :STACKORIGIN-1,x
  1112 					and :STACKORIGIN,x
  1113 					sta :STACKORIGIN-1,x
  1114
  1115 					rts
  1116 				.endp
  1117
  1118 8AC5			.proc	andAX_CX
  1119
  1120 					.rept 2
  1121 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1122 					AND :STACKORIGIN+#*STACKWIDTH,X
  1123 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1124 					.ENDR
  1124 					.endr
Source: REPT
  1121 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1121 					AND :STACKORIGIN+#*STACKWIDTH,X
  1121 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1121 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1121 					AND :STACKORIGIN+#*STACKWIDTH,X
  1121 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1125
  1126 					rts
  1127 				.endp
  1128
  1129 8AC5			.proc	andEAX_ECX
  1130
  1131 					.rept MAXSIZE
  1132 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1133 					AND :STACKORIGIN+#*STACKWIDTH,X
  1134 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1135 					.ENDR
  1135 					.endr
Source: REPT
  1132 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					AND :STACKORIGIN+#*STACKWIDTH,X
  1132 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					AND :STACKORIGIN+#*STACKWIDTH,X
  1132 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					AND :STACKORIGIN+#*STACKWIDTH,X
  1132 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1132 					AND :STACKORIGIN+#*STACKWIDTH,X
  1132 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1136
  1137 					rts
  1138 				.endp
  1139
  1140
  1141 8AC5			.proc	orAL_CL
  1142
  1143 					lda :STACKORIGIN-1,x
  1144 					ora :STACKORIGIN,x
  1145 					sta :STACKORIGIN-1,x
  1146
  1147 					rts
  1148 				.endp
  1149
  1150 8AC5			.proc	orAX_CX
  1151
  1152 					.rept 2
  1153 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1154 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1155 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1156 					.ENDR
  1156 					.endr
Source: REPT
  1153 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1153 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1153 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1153 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1153 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1153 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1157
  1158 					rts
  1159 				.endp
  1160
  1161 8AC5			.proc	orEAX_ECX
  1162
  1163 					.rept MAXSIZE
  1164 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1165 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1166 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1167 					.ENDR
  1167 					.endr
Source: REPT
  1164 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1164 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1164 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1164 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1164 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1164 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1168
  1169 					rts
  1170 				.endp
  1171
  1172
  1173 8AC5			.proc	xorAL_CL
  1174
  1175 					lda :STACKORIGIN-1,x
  1176 					eor :STACKORIGIN,x
  1177 					sta :STACKORIGIN-1,x
  1178
  1179 					rts
  1180 				.endp
  1181
  1182 8AC5			.proc	xorAX_CX
  1183
  1184 					.rept 2
  1185 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1186 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1187 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1188 					.ENDR
  1188 					.endr
Source: REPT
  1185 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1185 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1185 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1185 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1185 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1185 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1189
  1190 					rts
  1191 				.endp
  1192
  1193 8AC5			.proc	xorEAX_ECX
  1194
  1195 					.rept MAXSIZE
  1196 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1197 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1198 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1199 					.ENDR
  1199 					.endr
Source: REPT
  1196 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1196 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1196 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1196 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1196 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1196 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1200
  1201 					rts
  1202 				.endp
  1203
  1204
  1205 				/*
  1206 				.proc	iniEAX_ECX_BYTE
  1207
  1208 					mva :STACKORIGIN,x ecx
  1209 					mva :STACKORIGIN-1,x eax
  1210
  1211 					rts
  1212 				.endp
  1213 				*/
  1213
  1214
  1215
  1216 8AC5			.proc	iniEAX_ECX_WORD
  1217
  1218 					mva :STACKORIGIN,x ecx
  1219 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1220
  1221 					mva :STACKORIGIN-1,x eax
  1222 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1223
  1224 					mva #$00 ecx+2
  1225 					sta ecx+3
  1226
  1227 					sta eax+2
  1228 					sta eax+3
  1229
  1230 					rts
  1231 				.endp
  1232
  1233
  1234 8AC5			.proc	iniEAX_ECX_CARD
  1235 					mva :STACKORIGIN,x ecx
  1236 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1237 					mva :STACKORIGIN+STACKWIDTH*2,x ecx+2
  1238 					mva :STACKORIGIN+STACKWIDTH*3,x ecx+3
  1239
  1240 					mva :STACKORIGIN-1,x eax
  1241 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1242 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
  1243 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
  1244
  1245 					rts
  1246 				.endp
  1247
  1248 8AC5			.proc	movZTMP_aBX
  1249 					mva ZTMP8 :STACKORIGIN-1,x
  1250 					mva ZTMP9 :STACKORIGIN-1+STACKWIDTH,x
  1251 					mva ZTMP10 :STACKORIGIN-1+STACKWIDTH*2,x
  1252 					mva ZTMP11 :STACKORIGIN-1+STACKWIDTH*3,x
  1253
  1254 					rts
  1255 				.endp
  1256
  1257
  1258 8AC5				icl '6502\cpu6502_sio.asm'
Source: cpu6502_sio.asm
     1
     2 8AC5			.proc	@sio
     3
     4 					stx dbufa		;< adres bufora
     5 					sty dbufa+1		;> adres bufora
     6 					sta dcmnd		; 'R' read sector / 'P' write sector
     7
     8 					ldy dunit
     9 					lda lsector-1,y
    10 					sta dsctln		; < dlugosc sektora
    11 				;	sta dbyt		;< dlugosc bufora
    12
    13 					lda hsector-1,y
    14 					sta dsctln+1		; > dlugosc sektora 
    15 				;	sta dbyt+1		;> dlugosc bufora
    16
    17 					lda #$c0		; $40 read / $80 write
    18 					sta dstats
    19
    20 					lda #0
    21 					sta casflg		; = 00 to indicate that it isn't a cassette operation
    22
    23 					jmp jdskint
    24
    25 				// A = [1..8]
    26 8AC5			devnrm	tax
    27
    28 					CLC			; clear carry for add
    29 					ADC #$FF-8		; make m = $FF
    30 					ADC #8-1+1		; carry set if in range n to m
    31 					bcs ok
    32
    33 					ldy #-123		; kod bledu "DEVICE OR FILE NOT OPEN"
    34 					rts
    35 					
    36 8AC5			ok	txa
    37 					sta dunit		; nr stacji
    38 					ora #$30
    39 					sta ddevic		; nr stacji + $30
    40
    41 					lda #7
    42 					sta dtimlo		; timeout
    43
    44 					ldy #0
    45 					rts
    46
    47 8AC5			devsec	tya			; zapisz rozmiar sektora
    48 					ldy dunit
    49 					sta hsector-1,y
    50 					txa
    51 					sta lsector-1,y
    52 					rts
    53
    54 8AC5			lsector	:8 dta l(256)
    55 8AC5			hsector	:8 dta h(256)
    56
    57 				.endp
  1259 8AC5				icl '6502\cpu6502_cio.asm'
Source: cpu6502_cio.asm
     1
     2 				/*
     3 					Reset(f, record)
     4 					Rewrite(f, record)
     5
     6 					C = 1	SEC	IOCHECK TRUE
     7 					C = 0	CLC	IOCHECK FALSE
     8 				*/
     8
     9
    10 8AC5			.proc	@openfile (.word ya .byte x) .reg
    11
    12 = 00EA			lfname		= ctmp0
    13 = 00EB			hfname		= ctmp1
    14 = 00EC			code			= ctmp2
    15 = 00ED			iocheck		= ctmp3
    16
    17 					sta bp2
    18 					sty bp2+1
    19
    20 					stx code
    21
    22 					lda #0
    23 					rol @
    24 					sta iocheck
    25
    26 					ldy #s@file.status
    27 					lda (bp2),y
    28 					and #e@file.eof^$ff
    29 					sta (bp2),y
    30
    31 					ldy #s@file.pfname
    32 					lda (bp2),y
    33 					add #1
    34 					sta lfname
    35 					iny
    36 					lda (bp2),y
    37 					adc #0
    38 					sta hfname
    39
    40 					jsr lookup
    41 					bmi error
    42
    43 					ldy #s@file.chanel
    44 					txa
    45 					sta (bp2),y		;CHANNEL
    46
    47 				; -----------------------------------------
    48
    49 					lda #$03		;komenda: OPEN
    50 					sta iccmd,x
    51 					lda lfname
    52 					sta icbufa,x
    53 					lda hfname
    54 					sta icbufa+1,x
    55 					lda code
    56 					sta icax1,x
    57 					lda #$00		;dodatkowy parametr, $00 jest zawsze dobre
    58 					sta icax2,x
    59 					jsr ciov
    60
    61 8AC5			error	sty MAIN.SYSTEM.IOResult
    62
    63 					bpl ok
    64
    65 8AC5			msg	lda iocheck
    66 					beq skp
    67
    68 					sty dx
    69 				;	sty FX_CORE_RESET
    70
    71 					@clrscr
    72
    73 					lda <_error
    74 					ldy >_error
    75 					jsr @printSTRING
    76
    77 					lda #$00
    78 					sta dx+1
    79 					sta dx+2
    80 					sta dx+3
    81
    82 					jsr @printVALUE
    83
    84 					jmp MAIN.@halt
    85
    86 8AC5			skp	ldy #s@file.status
    87 					lda (bp2),y
    88 					ora #e@file.eof
    89 					sta (bp2),y
    90
    91 					ldy #s@file.record
    92 					lda #$00
    93 					sta (bp2),y
    94 					iny
    95 					sta (bp2),y
    96
    97 					rts
    98
    99 8AC5			ok	ldy #s@file.status
   100 					lda (bp2),y
   101 					ora #e@file.open
   102 					sta (bp2),y
   103
   104 					rts
   105
   106 8AC5			_error	dta 6,c'ERROR '
   107
   108 				; -----------------------------------------
   109
   110 8AC5			lookup	ldx #$00
   111 					ldy #$01
   112 8AC5			loop	lda icchid,x
   113 					cmp #$ff
   114 					beq found
   115 					txa
   116 					clc
   117 					adc #$10
   118 					tax
   119 					bpl loop
   120 					ldy #-95       		; kod bledu "TOO MANY CHANNELS OPEN"
   121 8AC5			found	rts
   122 				.endp
   123
   124
   125 				/*
   126 					Close(f)
   127
   128 					C = 1	SEC	IOCHECK TRUE
   129 					C = 0	CLC	IOCHECK FALSE
   130 				*/
   130
   131
   132 8AC5			.proc	@closefile (.word ya) .reg
   133 					sta	bp2
   134 					sty	bp2+1
   135
   136 					ldy	#s@file.status
   137
   138 					lda	#0
   139 					rol	@
   140 					sta	@openfile.iocheck
   141 				;	beq	ok_open
   142
   143 					lda	(bp2),y
   144 					and 	#e@file.open
   145 					bne	ok_open
   146
   147 					ldy	#-123		; kod bledu "DEVICE OR FILE NOT OPEN"
   148 					jmp	@openfile.error
   149
   150 8AC5			ok_open	lda	(bp2),y
   151 					ora	#e@file.eof
   152 					sta	(bp2),y
   153
   154 					ldy	#s@file.chanel
   155 					lda	(bp2),y
   156 					tax
   157
   158 					lda	#$0c		;komenda: CLOSE
   159 					sta	iccmd,x
   160 					jsr	ciov
   161
   162 				;	lda	#0		; iocheck off
   163 				;	sta	@openfile.iocheck
   164
   165 					jmp	@openfile.error
   166
   167 				.endp
   168
   169
   170 				/*
   171 					BlockRead(f, buf, num_records, numread)
   172 					BlockWrite(f, buf, num_records, numwrite)
   173
   174 					C = 1	SEC	IOCHECK TRUE
   175 					C = 0	CLC	IOCHECK FALSE
   176 				*/
   176
   177
   178 8AC5			.proc	@readfile (.word ya .byte x) .reg
   179 					code			= ctmp2
   180 					sta	bp2
   181 					sty	bp2+1
   182
   183 					stx	code
   184
   185 					lda	#$00
   186 					sta	eax+2
   187 					sta	eax+3
   188 					sta	ecx+2
   189 					sta	ecx+3
   190
   191 					sta	MAIN.SYSTEM.IOResult
   192
   193 					rol	@
   194 					sta	@openfile.iocheck
   195
   196 					ldy	#s@file.status
   197 					lda	(bp2),y
   198 					and	#e@file.open
   199 					bne	ok_open
   200
   201 					ldy	#-123			; kod bledu "DEVICE OR FILE NOT OPEN"
   202 					jmp	@openfile.error
   203
   204 8AC5			ok_open	ldy	#s@file.record
   205 					mwa	(bp2),y	ecx
   206
   207 					ldy	#s@file.nrecord
   208 					mwa	(bp2),y	eax
   209
   210 				;	lda	#0
   211 					jsr	imulCX			; record * nrecord = file length to load
   212
   213 					cpw	eax #0
   214 					beq	nothing
   215
   216 					ldy	#s@file.chanel
   217 					lda	(bp2),y
   218 					tax
   219
   220 					mwa	eax	icbufl,x
   221
   222 					ldy	#s@file.buffer
   223 					mwa	(bp2),y	icbufa,x
   224
   225 					lda	code
   226 					and	#$7f
   227 					sta	iccmd,x
   228
   229 					jsr	ciov
   230
   231 					sty	MAIN.SYSTEM.IOResult
   232
   233 					bpl ok
   234
   235 					cpy #136
   236 					beq done
   237
   238 					jsr eof
   239
   240 					lda #$00
   241 					sta eax
   242 					sta eax+1
   243
   244 					jmp	@openfile.msg
   245
   246 8AC5			done	jsr eof
   247
   248 8AC5			ok	mwa icbufl,x	eax
   249 					ldy #s@file.record
   250 					mwa (bp2),y	ecx
   251
   252 					lda #$00
   253 					jsr idivAX_CX.main
   254
   255 8AC5			nothing	lda code
   256 					bpl quit			; blockread(f, buf, len)   short version
   257
   258 					ldy #s@file.numread
   259 					mwa (bp2),y ztmp
   260
   261 					ldy #0
   262 					mwa eax (ztmp),y		; length of loaded data / record = number of records
   263
   264 8AC5			quit	rts
   265
   266 8AC5			eof	ldy #s@file.status
   267 					lda (bp2),y
   268 					ora #e@file.eof
   269 					sta (bp2),y
   270
   271 					rts
   272 				.endp
   273
   274
   275 8AC5			.proc	@ReadDirFileName (.word ya) .reg
   276
   277 					ldx #5
   278 					clc		; iocheck off
   279 					jsr @readfile	; (ya, x)
   280
   281 					ldy eax
   282
   283 					lda MAIN.SYSTEM.IOResult
   284 					smi
   285 					lda #0		; ok
   286
   287 					rts
   288 				.endp
   289
   290
   291 8AC5			.proc	@DirFileName
   292
   293
   294 = 00EA			attr = ctmp0
   295 = 00EB			ln	= ctmp1
   296
   297 					lda #0
   298 					sta attr
   299
   300 					cpy #$12
   301 					bne stop
   302
   303 					lda @buf
   304 					cmp #'*'
   305 					bne skp
   306
   307 					lda #MAIN.SYSUTILS.faReadOnly
   308 					sta attr
   309
   310 8AC5			skp	ldy #1
   311 					ldx #2
   312 					lda #10
   313 					jsr cpName
   314
   315 					ldx #10
   316 					lda @buf,x
   317 					pha
   318 					bpl files
   319
   320 					lda attr
   321 					ora #MAIN.SYSUTILS.faDirectory
   322 					sta attr
   323
   324 					jmp skp2
   325
   326 8AC5			files	lda attr
   327 					ora #MAIN.SYSUTILS.faArchive
   328 					sta attr
   329
   330 8AC5			skp2	pla
   331 					beq stp2
   332
   333 					lda #'.'
   334 					sta (bp2),y
   335 					iny
   336
   337 					lda #13
   338 					jsr cpName
   339 8AC5			stp2
   340 					dey
   341 					tya
   342 8AC5			stop	ldy #0
   343 					sta (bp2),y
   344
   345 					ldx attr
   346 					rts
   347
   348 8AC5			cpName	sta ln
   349 8AC5			cp	lda @buf,x
   350 					cmp #' '
   351 					beq stp
   352 					sta (bp2),y
   353 					iny
   354 					inx
   355 					cpx ln	
   356 					bne cp
   357 8AC5			stp	rts
   358 				.endp
   359
  1260
  1261 8AC5				icl '6502\cpu6502_shortint.asm'		; mul / div -> SHORTINT
Source: cpu6502_shortint.asm
     1
     2 				/*
     3 					mulSHORTINT
     4 					divmulSHORTINT
     5 				*/
     5
     6
     7
     8 8AC5			.proc	mulSHORTINT
     9
    10 					jsr imulBYTE
    11
    12 					lda :STACKORIGIN-1,x
    13 					bpl @+
    14 						sec
    15 						lda eax+1
    16 						sbc :STACKORIGIN,x
    17 						sta eax+1
    18 8AC5			@
    19 					lda :STACKORIGIN,x
    20 					bpl @+
    21 						sec
    22 						lda eax+1
    23 						sbc :STACKORIGIN-1,x
    24 						sta eax+1
    25 8AC5			@
    26 					jmp movaBX_EAX
    27 				.endp
    28
    29
    30 8AC5			.proc	divmulSHORTINT
    31
    32 8AC5			MOD	mva #{jsr} _mod
    33
    34 					lda :STACKORIGIN,x		; divisor sign
    35 					spl
    36 					jsr negBYTE
    37
    38 8AC5			DIV	ldy <idivBYTE
    39 					lda >idivBYTE
    40
    41 8AC5			skp	sty addr
    42 					sta addr+1
    43
    44 					ldy #0
    45
    46 					lda :STACKORIGIN-1,x		; dividend sign
    47 					bpl @+
    48 					jsr negBYTE1
    49 					iny
    50
    51 8AC5			@	lda :STACKORIGIN,x		; divisor sign
    52 					bpl @+
    53 					jsr negBYTE
    54 					iny
    55
    56 8AC5			@	tya
    57 					and #1
    58 					pha
    59
    60 					jsr $ffff			; idiv ecx
    61 8AC5			addr	equ *-2
    62
    63 					jsr movaBX_EAX
    64
    65 8AC5			_mod	bit movZTMP_aBX			; mod
    66 					mva #{bit} _mod
    67
    68 					pla
    69 					seq
    70 					jmp negCARD1
    71
    72 					rts
    73 				.endp
  1262 8AC5				icl '6502\cpu6502_smallint.asm'		; mul / div -> SMALLINT
Source: cpu6502_smallint.asm
     1
     2 				/*
     3 					mulSMALLINT
     4 					divmulSMALLINT
     5 				*/
     5
     6
     7
     8 8AC5			.proc	mulSMALLINT
     9
    10 					jsr imulWORD
    11
    12 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    13 					bpl @+
    14 						sec
    15 						lda eax+2
    16 						sbc :STACKORIGIN,x
    17 						sta eax+2
    18 						lda eax+3
    19 						sbc :STACKORIGIN+STACKWIDTH,x
    20 						sta eax+3
    21 8AC5			@
    22 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    23 					bpl @+
    24 						sec
    25 						lda eax+2
    26 						sbc :STACKORIGIN-1,x
    27 						sta eax+2
    28 						lda eax+3
    29 						sbc :STACKORIGIN-1+STACKWIDTH,x
    30 						sta eax+3
    31 8AC5			@
    32 					jmp movaBX_EAX
    33 				.endp
    34
    35
    36 8AC5			.proc	divmulSMALLINT
    37
    38 8AC5			SHORTREAL
    39 					ldy <divSHORTREAL
    40 					lda >divSHORTREAL
    41 					bne skp
    42
    43 8AC5			MOD	mva #{jsr} _mod
    44
    45 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    46 					spl
    47 					jsr negWORD
    48
    49 8AC5			DIV	ldy <idivWORD
    50 					lda >idivWORD
    51
    52 8AC5			skp	sty addr
    53 					sta addr+1
    54
    55 					ldy #0
    56
    57 					lda :STACKORIGIN-1+STACKWIDTH,x	; dividend sign
    58 					bpl @+
    59 					jsr negWORD1
    60 					iny
    61 8AC5			@
    62 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    63 					bpl @+
    64 					jsr negWORD
    65 					iny
    66 8AC5			@
    67 					tya
    68 					and #1
    69 					pha
    70
    71 					jsr $ffff			; idiv cx
    72 8AC5			addr	equ *-2
    73
    74 					jsr movaBX_EAX
    75
    76 8AC5			_mod	bit movZTMP_aBX			; mod
    77 					mva #{bit} _mod
    78
    79 					pla
    80 					seq
    81 					jmp negCARD1
    82
    83 					rts
    84 				.endp
  1263 8AC5				icl '6502\cpu6502_integer.asm'		; mul / div -> INTEGER
Source: cpu6502_integer.asm
     1
     2 				/*
     3 					mulINTEGER
     4 					divmulINT
     5 				*/
     5
     6
     7 8AC5			.proc	mulINTEGER
     8
     9 					jsr imulCARD
    10
    11 					jmp movaBX_EAX
    12 				.endp
    13
    14
    15 8AC5			.proc	divmulINT
    16
    17 8AC5			REAL	ldy <divREAL
    18 					lda >divREAL
    19 					bne skp
    20
    21 8AC5			MOD	mva #{jsr} _mod
    22
    23 					lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    24 					spl
    25 					jsr negCARD
    26
    27 8AC5			DIV	ldy <idivCARD
    28 					lda >idivCARD
    29
    30 8AC5			skp	sty addr
    31 					sta addr+1
    32
    33 					ldy #0
    34
    35 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; dividend sign
    36 					bpl @+
    37 					jsr negCARD1
    38 					iny
    39
    40 8AC5			@	lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    41 					bpl @+
    42 					jsr negCARD
    43 					iny
    44
    45 8AC5			@	tya
    46 					and #1
    47 					pha
    48
    49 					jsr $ffff				; idiv ecx
    50 8AC5			addr	equ *-2
    51 					jsr movaBX_EAX
    52
    53 8AC5			_mod	bit movZTMP_aBX				; mod
    54 					mva #{bit} _mod
    55
    56 					pla
    57 					seq
    58 					jmp negCARD1
    59
    60 					rts
    61 				.endp
  1264
  1265 8AC5				icl '6502\cpu6502_byte.asm'		; mul / div -> BYTE
Source: cpu6502_byte.asm
     1
     2 				/*
     3 					fmulu_8
     4 					imulCL
     5 					imulBYTE
     6 					idivBYTE
     7 					idiv_AL_CL
     8 				*/
     8
     9
    10 				; Description: Unsigned 8-bit multiplication with unsigned 16-bit result.
    11 				;
    12 				; Input: 8-bit unsigned value in T1
    13 				;	 8-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 16-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 8AC5			.proc fmulu_8
    31
    32 = 00C2			t1	= eax
    33 = 00CA			t2	= ecx
    34
    35 = 00C2			product	= eax
    36
    37 					txa:tay
    38 				;		bcc :+
    39 						    lda T1
    40 						    sta sm1+1
    41 						    sta sm3+1
    42 						    eor #$ff
    43 						    sta sm2+1
    44 						    sta sm4+1
    45
    46 						ldx T2
    47 						sec
    48 8AC5			sm1:		lda square1_lo,x
    49 8AC5			sm2:		sbc square2_lo,x
    50 						sta PRODUCT+0
    51 8AC5			sm3:		lda square1_hi,x
    52 8AC5			sm4:		sbc square2_hi,x
    53
    54 						sta PRODUCT+1
    55
    56 					tya:tax
    57 						rts
    58 				.endp
    59
    60
    61 				/*
    62
    63 				 8 bit multiply and divide routines.
    64 				 Three 8 bit locations
    65 				 ACC, AUX and EXT must be set up,
    66 				 preferably on zero page.
    67
    68 				 MULTIPLY ROUTINE
    69
    70 				 EAX*ECX -> EAX (low,hi) 16 bit result
    71
    72 				*/
    72
    73
    74 8AC5			.proc	imulCL
    75
    76 8AC5 A9 00			lda #$00
    77
    78 8AC7 A0 09			LDY #$09
    79 8AC9 18				CLC
    80 8ACA 6A			LOOP	ROR @
    81 8ACB 66 C2			ROR eax
    82 8ACD 90 03			BCC MUL2
    83 8ACF 18				CLC		;DEC AUX above to remove CLC
    84 8AD0 65 CA			ADC ecx
    85 8AD2 88			MUL2	DEY
    86 8AD3 D0 F5			BNE LOOP
    87
    88 8AD5 85 C3			STA eax+1
    89
    90 8AD7 60				RTS
    91 				.endp
    92
    93
    94 8AD8			.proc	imulBYTE
    95
    96 					mva :STACKORIGIN,x ecx
    97 					mva :STACKORIGIN-1,x eax
    98
    99 					lda #$00
   100
   101 					sta eax+2
   102 					sta eax+3
   103
   104 					.ifdef fmulinit
   105 					jmp fmulu_8
   106 					els
   107 					jmp imulCL
   108 					eif
   109
   110 				.endp
   111
   112
   113 				.define	jsr_imodBYTE jsr idivBYTE
   114
   115 8AD8			.proc	idivBYTE
   116
   117 					mva :STACKORIGIN,x ecx
   118 					mva :STACKORIGIN-1,x eax
   119
   120 					jmp idivAL_CL
   121 				.endp
   122
   123
   124 				; DIVIDE ROUTINE (8 BIT)
   125 				; AL/CL -> ACC, remainder in ZTMP
   126
   127 8AD8			.proc idivAL_CL
   128
   129 				;	mva :STACKORIGIN,x cl
   130 				;	mva :STACKORIGIN-1,x al
   131
   132 					lda #$00
   133
   134 					sta eax+1
   135 					sta eax+2
   136 					sta eax+3
   137
   138 					STA ztmp+1
   139 					STA ztmp+2
   140 					STA ztmp+3
   141
   142 					LDY #$08
   143 8AD8			LOOP	ASL AL
   144 					ROL @
   145 					CMP CL
   146 					BCC DIV2
   147 					SBC CL
   148 					INC AL
   149 8AD8			DIV2
   150 					DEY
   151 					BNE LOOP
   152
   153 					STA ZTMP
   154
   155 					rts
   156 				.endp
   157
  1266 8AD8				icl '6502\cpu6502_word.asm'		; mul / div -> WORD
Source: cpu6502_word.asm
     1
     2 				/*
     3 					fmulu_16
     4 					imulCX
     5 					imulWORD
     6 					idivWORD
     7 					idivAX_CX
     8 				*/
     8
     9
    10 				; Description: Unsigned 16-bit multiplication with unsigned 32-bit result.
    11 				;
    12 				; Input: 16-bit unsigned value in T1
    13 				;	 16-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 32-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 				//.proc multiply_16bit_unsigned
    31 						; <T1 * <T2 = AAaa
    32 						; <T1 * >T2 = BBbb
    33 						; >T1 * <T2 = CCcc
    34 						; >T1 * >T2 = DDdd
    35 						;
    36 						;	AAaa
    37 						;     BBbb
    38 						;     CCcc
    39 						; + DDdd
    40 						; ----------
    41 						;   PRODUCT!
    42
    43 						; Setup T1 if changed
    44 8AD8			.proc	fmulu_16
    45
    46 = 00C2			t1	= eax
    47 = 00CA			t2	= ecx
    48
    49 = 00C2			product	= eax
    50
    51 					txa:pha
    52 				;		bcc @+
    53 						    lda T1+0
    54 						    sta sm1a+1
    55 						    sta sm3a+1
    56 						    sta sm5a+1
    57 						    sta sm7a+1
    58 						    eor #$ff
    59 						    sta sm2a+1
    60 						    sta sm4a+1
    61 						    sta sm6a+1
    62 						    sta sm8a+1
    63 						    lda T1+1
    64 						    sta sm1b+1
    65 						    sta sm3b+1
    66 						    sta sm5b+1
    67 						    sta sm7b+1
    68 						    eor #$ff
    69 						    sta sm2b+1
    70 						    sta sm4b+1
    71 						    sta sm6b+1
    72 						    sta sm8b+1
    73 				;@
    74 						; Perform <T1 * <T2 = AAaa
    75 						ldx T2+0
    76 						sec
    77 8AD8			sm1a:		lda square1_lo,x
    78 8AD8			sm2a:		sbc square2_lo,x
    79 						sta PRODUCT+0
    80 8AD8			sm3a:		lda square1_hi,x
    81 8AD8			sm4a:		sbc square2_hi,x
    82 						;sta _AA+1
    83 						tay
    84
    85 						; Perform >T1_hi * <T2 = CCcc
    86 						sec
    87 8AD8			sm1b:		lda square1_lo,x
    88 8AD8			sm2b:		sbc square2_lo,x
    89 						sta _cc+1
    90 8AD8			sm3b:		lda square1_hi,x
    91 8AD8			sm4b:		sbc square2_hi,x
    92 						sta _CC_+1
    93
    94 						; Perform <T1 * >T2 = BBbb
    95 						ldx T2+1
    96 						sec
    97 8AD8			sm5a:		lda square1_lo,x
    98 8AD8			sm6a:		sbc square2_lo,x
    99 						sta _bb+1
   100 8AD8			sm7a:		lda square1_hi,x
   101 8AD8			sm8a:		sbc square2_hi,x
   102 						sta _BB_+1
   103
   104 						; Perform >T1 * >T2 = DDdd
   105 						sec
   106 8AD8			sm5b:		lda square1_lo,x
   107 8AD8			sm6b:		sbc square2_lo,x
   108 						sta _dd+1
   109 8AD8			sm7b:		lda square1_hi,x
   110 8AD8			sm8b:		sbc square2_hi,x
   111 				;		sta PRODUCT+3
   112 						tax
   113
   114 						; Add the separate multiplications together
   115 						clc
   116 				;_AA:		lda #0
   117 						tya
   118 8AD8			_bb:		adc #0
   119 				;		sta PRODUCT+1
   120 						tay
   121 8AD8			_BB_:		lda #0
   122 8AD8			_CC_:		adc #0
   123 						sta PRODUCT+2
   124 						bcc @+
   125 				;		    inc PRODUCT+3
   126 						inx
   127 						    clc
   128 8AD8			@
   129 						tya
   130 8AD8			_cc:		adc #0
   131 				;		adc PRODUCT+1
   132 						sta PRODUCT+1
   133 8AD8			_dd:		lda #0
   134 						adc PRODUCT+2
   135 						sta PRODUCT+2
   136 						scc
   137 				;		    inc PRODUCT+3
   138 						inx
   139
   140 					stx PRODUCT+3
   141
   142 					pla:tax
   143
   144 					rts
   145 				.endp
   146
   147
   148 				/*
   149
   150 				 16 bit multiply and divide routines.
   151 				 Three 16 bit (two-byte) locations
   152 				 ACC, AUX and EXT must be set up,
   153 				 preferably on zero page.
   154
   155 				 MULTIPLY ROUTINE
   156
   157 				 EAX*ECX -> EAX (low,hi) 32 bit result
   158
   159 				*/
   159
   160
   161 8AD8			.proc	imulCX
   162
   163 					lda #$00
   164 					sta eax+3
   165
   166 					LDY #$11			; A = 0 !
   167 					CLC
   168 8AD8			LOOP	ROR eax+3
   169 					ROR @
   170 					ROR eax+1
   171 					ROR eax
   172 					BCC MUL2
   173 					CLC
   174 					ADC ecx
   175 					PHA
   176 					LDA ecx+1
   177 					ADC eax+3
   178 					STA eax+3
   179 					PLA
   180 8AD8			MUL2	DEY
   181 					BNE LOOP
   182
   183 					STA eax+2
   184
   185 					rts
   186 				.endp
   187
   188
   189 8AD8			.proc	imulWORD
   190
   191 					mva :STACKORIGIN,x ecx
   192 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   193
   194 					mva :STACKORIGIN-1,x eax
   195 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   196
   197 					.ifdef fmulinit
   198 					jmp fmulu_16
   199 					els
   200 					jmp imulCX
   201 					eif
   202 				.endp
   203
   204
   205 				.define	jsr_imodWORD jsr idivWORD
   206
   207 8AD8			.proc	idivWORD
   208
   209 					mva :STACKORIGIN,x ecx
   210 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   211
   212 					mva :STACKORIGIN-1,x eax
   213 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   214
   215 					jmp idivAX_CX
   216 				.endp
   217
   218
   219 				; DIVIDE ROUTINE (16 BIT)
   220 				; AX/CX -> ACC, remainder in ZTMP
   221
   222 8AD8			.proc	idivAX_CX
   223
   224 				;	jsr iniEAX_ECX_WORD
   225 8AD8			main
   226 					LDA #0
   227 					STA ztmp+1
   228 					STA ztmp+2
   229 					STA ztmp+3
   230
   231 					sta eax+2
   232 					sta eax+3
   233
   234 					.ifdef fmulinit
   235 					.rept 16
   236 					ASL ax
   237 					ROL ax+1
   238 					ROL @
   239 					ROL ztmp+1
   240 					tay
   241 					CMP cx
   242 					LDA ztmp+1
   243 					SBC cx+1
   244 					BCC @+
   245 					STA ztmp+1
   246 					tya
   247 					SBC cx
   248 					tay
   249 					INC ax
   250 				@	tya
   251 					.endr
   252
   253 					els
   254 					LDY #$10
   255
   256 8AD8			LOOP	ASL ax
   257 					ROL ax+1
   258 					ROL @
   259 					ROL ztmp+1
   260 					sta edx
   261 					CMP cx
   262 					LDA ztmp+1
   263 					SBC cx+1
   264 					BCC DIV2
   265 					STA ztmp+1
   266 					lda edx
   267 					SBC cx
   268 					sta edx
   269 					INC ax
   270 8AD8			DIV2	lda edx
   271 					DEY
   272 					BNE LOOP
   273 					eif
   274
   275 					STA ztmp
   276
   277 					rts
   278 				.endp
   279
  1267 8AD8				icl '6502\cpu6502_cardinal.asm'		; mul / div -> CARDINAL
Source: cpu6502_cardinal.asm
     1
     2 				/*
     3 					imulECX
     4 					imulCARD
     5 					idivCARD
     6 					idivEAX_ECX
     7 				*/
     7
     8
     9 				; *** MUL32: 32-bit multiply
    10 				; EAX * ECX -> ZTMP8-ZTMP11
    11 8AD8			.proc	imulECX
    12
    13 					lda #0
    14 					sta ZTMP10
    15 					sta ZTMP9
    16 					sta ZTMP8
    17
    18 					ldy #32
    19 8AD8			MUL320	lsr ZTMP10
    20 					ror ZTMP9
    21 					ror ZTMP8
    22 					ror @
    23 					ror eax+3
    24 					ror eax+2
    25 					ror eax+1
    26 					ror eax
    27 					bcc MUL321
    28 					clc
    29 					adc ecx
    30 					pha
    31 					lda ecx+1
    32 					adc ZTMP8
    33 					sta ZTMP8
    34 					lda ecx+2
    35 					adc ZTMP9
    36 					sta ZTMP9
    37 					lda ecx+3
    38 					adc ZTMP10
    39 					sta ZTMP10
    40 					pla
    41 8AD8			MUL321	dey
    42 				       	bpl MUL320
    43
    44 					rts
    45 				.endp
    46
    47
    48 8AD8			.proc	imulCARD
    49
    50 					jsr iniEAX_ECX_CARD
    51
    52 					jmp imulECX
    53 				.endp
    54
    55
    56 				.define	jsr_imodCARD jsr idivCARD
    57
    58 8AD8			.proc	idivCARD
    59
    60 					jsr iniEAX_ECX_CARD
    61
    62 					jmp idivEAX_ECX.CARD
    63 				.endp
    64
    65
    66 				; *** UDIV32: 32-bit unsigned division
    67 				; input: dividend at ZTMP0-ZTMP3
    68 				;        divisor at ZTMP4-ZTMP7
    69 				; output: result at ZTMP0-ZTMP3
    70 				;         remainder at ZTMP8-ZTMP11
    71 				; X,Y preserved
    72
    73 8AD8			.proc	idivEAX_ECX
    74
    75 8AD8			REAL	mva :STACKORIGIN-1+STACKWIDTH*2,x :STACKORIGIN-1+STACKWIDTH*3,x
    76 					mva :STACKORIGIN-1+STACKWIDTH,x :STACKORIGIN-1+STACKWIDTH*2,x
    77 					mva :STACKORIGIN-1,x :STACKORIGIN-1+STACKWIDTH,x
    78 					mva #$00 :STACKORIGIN-1,x
    79
    80 8AD8			CARD	;jsr iniEAX_ECX_CARD
    81
    82 8AD8			MAIN	LDA #0
    83 					STA ZTMP8
    84 					STA ZTMP9
    85 					STA ZTMP10
    86 					STA ZTMP11
    87
    88 					LDY #32
    89 8AD8			UDIV320	ASL eax
    90 					ROL eax+1
    91 					ROL eax+2
    92 					ROL eax+3
    93 					ROL ZTMP8
    94 					ROL ZTMP9
    95 					ROL ZTMP10
    96 					ROL ZTMP11
    97 							;do a subtraction
    98 					LDA ZTMP8
    99 					CMP ecx
   100 					LDA ZTMP9
   101 					SBC ecx+1
   102 					LDA ZTMP10
   103 					SBC ecx+2
   104 					LDA ZTMP11
   105 					SBC ecx+3
   106 					BCC UDIV321
   107 				 			;overflow, do the subtraction again, this time store the result
   108 					STA ecx+3	;we have the high byte already
   109 					LDA ZTMP8
   110 					SBC ecx		;byte 0
   111 					STA ZTMP8
   112 					LDA ZTMP9
   113 					SBC ecx+1
   114 					STA ZTMP9	;byte 1
   115 					LDA ZTMP10
   116 					SBC ecx+2
   117 					STA ZTMP10	;byte 2
   118 					INC eax		;set result bit
   119
   120 8AD8			UDIV321	DEY
   121 					BNE UDIV320
   122
   123 					rts
   124 				.endp
   125
  1268
  1269 8AD8				icl '6502\cpu6502_shortreal.asm'	; mul / div -> SHORTREAL	Q8.8
Source: cpu6502_shortreal.asm
     1 				; SHORTREAL	fixed-point Q8.8, 16bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulSHORTREAL
     6 					divSHORTREAL
     7 				*/
     7
     8
     9
    10 8AD8			.proc	mulSHORTREAL
    11
    12 					jsr imulWORD
    13
    14 					mva #0 eax+3
    15 					mva eax+1 eax
    16 					mva eax+2 eax+1
    17
    18 					ldy eax+3
    19
    20 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    21 					bpl @+
    22 					sec
    23 					lda eax+1
    24 					sbc :STACKORIGIN,x
    25 					sta eax+1
    26 					tya
    27 					sbc :STACKORIGIN+STACKWIDTH,x
    28 					tay
    29 8AD8			@
    30 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    31 					bpl @+
    32 					sec
    33 					lda eax+1
    34 					sbc :STACKORIGIN-1,x
    35 					sta eax+1
    36 					tya
    37 					sbc :STACKORIGIN-1+STACKWIDTH,x
    38 					tay
    39 8AD8			@
    40 					sty eax+2
    41
    42 					jmp movaBX_EAX
    43 				.endp
    44
    45
    46
    47 8AD8			.proc	divSHORTREAL
    48 					jsr iniEAX_ECX_WORD
    49
    50 					mva eax+1 eax+2
    51 					mva eax eax+1
    52 					lda #0
    53 					sta eax
    54 					sta eax+3
    55 					sta ecx+3
    56
    57 					jmp idivEAX_ECX.main
    58 				.endp
  1270 8AD8				icl '6502\cpu6502_real.asm'		; mul / div -> REAL		Q24.8
Source: cpu6502_real.asm
     1 				; REAL	fixed-point Q24.8, 32bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulREAL
     6 					divREAL
     7 				*/
     7
     8
     9
    10 8AD8			.proc	mulREAl
    11
    12 				;	jsr iniEAX_ECX_CARD
    13
    14 					mva :STACKORIGIN,x ecx0
    15 					mva :STACKORIGIN+STACKWIDTH,x ecx1
    16 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
    17 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
    18
    19 					mva :STACKORIGIN-1,x eax
    20 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
    21 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
    22 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
    23
    24 				;	jsr imul64				; imul ecx 64 bit
    25
    26 					lda #$00
    27 					sta edx		;Clear upper half of
    28 					sta edx+1	;product
    29 					sta edx+2
    30 					sta edx+3
    31
    32 					sta ztmp8
    33 					sta ztmp9
    34 					sta ztmp10
    35 					sta ztmp11
    36
    37 					ldy #$20	;Set binary count to 32
    38 8AD8			SHIFT_R	lsr eax+3	;Shift multiplyer right
    39 					ror eax+2
    40 					ror eax+1
    41 					ror eax
    42 					bcc ROTATE_R	;Go rotate right if c = 0
    43 					lda edx		;Get upper half of product
    44 					clc		;and add multiplicand to
    45 					adc #0		;it
    46 8AD8			ecx0	equ *-1
    47 					sta edx
    48 					lda edx+1
    49 					adc #0
    50 8AD8			ecx1	equ *-1
    51 					sta edx+1
    52 					lda edx+2
    53 					adc #0
    54 8AD8			ecx2	equ *-1
    55 					sta edx+2
    56 					lda edx+3
    57 					adc #0
    58 8AD8			ecx3	equ *-1
    59 8AD8			ROTATE_R  ror @		;Rotate partial product
    60 				        sta edx+3	;right
    61 				        ror edx+2
    62 				        ror edx+1
    63 				        ror edx
    64 				        ror ztmp11
    65 				        ror ztmp10
    66 				        ror ztmp9
    67 				        ror ztmp8
    68 				        dey		;Decrement bit count and
    69 				        bne SHIFT_R	;loop until 32 bits are
    70
    71 				;	mva ztmp8 eax
    72 					mva ztmp9 eax
    73 					mva ztmp10 eax+1
    74 					mva ztmp11 eax+2
    75
    76
    77 				;	mva eax+1 eax
    78 				;	mva eax+2 eax+1
    79 				;	mva eax+3 eax+2
    80
    81 					ldy edx
    82
    83 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; t1
    84 					bpl @+
    85 					sec
    86 					tya
    87 					sbc :STACKORIGIN,x
    88 					tay
    89 8AD8			@
    90 					lda :STACKORIGIN+STACKWIDTH*3,x		; t2
    91 					bpl @+
    92 					sec
    93 					tya
    94 					sbc :STACKORIGIN-1,x
    95 					tay
    96 8AD8			@
    97 					sty eax+3
    98
    99 					jmp movaBX_EAX
   100 				.endp
   101
   102
   103 				/*
   104 				;32 bit multiply with 64 bit product
   105
   106 				.proc	imul64
   107
   108 					lda #$00
   109 					sta edx		;Clear upper half of
   110 					sta edx+1	;product
   111 					sta edx+2
   112 					sta edx+3
   113
   114 					sta ztmp8
   115 					sta ztmp9
   116 					sta ztmp10
   117 					sta ztmp11
   118
   119 					ldy #$20	;Set binary count to 32
   120 				SHIFT_R	lsr eax+3	;Shift multiplyer right
   121 					ror eax+2
   122 					ror eax+1
   123 					ror eax
   124 					bcc ROTATE_R	;Go rotate right if c = 0
   125 					lda edx		;Get upper half of product
   126 					clc		;and add multiplicand to
   127 					adc ecx		;it
   128 					sta edx
   129 					lda edx+1
   130 					adc ecx+1
   131 					sta edx+1
   132 					lda edx+2
   133 					adc ecx+2
   134 					sta edx+2
   135 					lda edx+3
   136 					adc ecx+3
   137 				ROTATE_R  ror @		;Rotate partial product
   138 				        sta edx+3	;right
   139 				        ror edx+2
   140 				        ror edx+1
   141 				        ror edx
   142 				        ror ztmp11
   143 				        ror ztmp10
   144 				        ror ztmp9
   145 				        ror ztmp8
   146 				        dey		;Decrement bit count and
   147 				        bne SHIFT_R	;loop until 32 bits are
   148
   149 					mva ztmp8 eax
   150 					mva ztmp9 eax+1
   151 					mva ztmp10 eax+2
   152 					mva ztmp11 eax+3
   153
   154 					rts
   155 				.endp
   156 				*/
   156
   157
   158 				; 64bit / 32bit = 32bit
   159 				; eax = eax + edx
   160
   161 8AD8			.proc	divREAL
   162
   163 					mva :STACKORIGIN,x ecx0
   164 					sta ecx0_
   165 					mva :STACKORIGIN+STACKWIDTH,x ecx1
   166 					sta ecx1_
   167 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
   168 					sta ecx2_
   169 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
   170
   171 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+4
   172 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+3
   173 					mva :STACKORIGIN-1+STACKWIDTH,x eax+2
   174 					mva :STACKORIGIN-1,x eax+1
   175
   176 					lda #$00
   177 					sta eax
   178 					sta eax+5
   179 					sta eax+6
   180 					sta eax+7
   181
   182 					STA ZTMP8
   183 					STA ZTMP9
   184 					STA ZTMP10
   185 					STA ZTMP11
   186
   187 					LDY #64
   188 8AD8			UDIV320	ASL eax
   189 					ROL eax+1
   190 					ROL eax+2
   191 					ROL eax+3
   192 					ROL eax+4
   193 					ROL eax+5
   194 					ROL eax+6
   195 					ROL eax+7
   196
   197 					ROL ZTMP8
   198 					ROL ZTMP9
   199 					ROL ZTMP10
   200 					ROL ZTMP11
   201 							;do a subtraction
   202 					LDA ZTMP8
   203 					CMP #0
   204 8AD8			ecx0	equ *-1
   205 					LDA ZTMP9
   206 					SBC #0
   207 8AD8			ecx1	equ *-1
   208 					LDA ZTMP10
   209 					SBC #0
   210 8AD8			ecx2	equ *-1
   211 					LDA ZTMP11
   212 					SBC #0
   213 8AD8			ecx3	equ *-1
   214 					BCC UDIV321
   215 				 			;overflow, do the subtraction again, this time store the result
   216 					STA ecx3	;we have the high byte already
   217 					LDA ZTMP8
   218 					SBC #0		;byte 0
   219 8AD8			ecx0_	equ *-1
   220 					STA ZTMP8
   221 					LDA ZTMP9
   222 					SBC #0
   223 8AD8			ecx1_	equ *-1
   224 					STA ZTMP9	;byte 1
   225 					LDA ZTMP10
   226 					SBC #0
   227 8AD8			ecx2_	equ *-1
   228 					STA ZTMP10	;byte 2
   229
   230 					INC eax		;set result bit
   231
   232 8AD8			UDIV321	DEY
   233 					BNE UDIV320
   234
   235 					rts
   236 				.endp
   237
   238
   239 				/*
   240 				.proc	divREAL
   241
   242 					jsr iniEAX_ECX_CARD
   243
   244 					mva eax+3 eax+4
   245 					mva eax+2 eax+3
   246 					mva eax+1 eax+2
   247 					mva eax eax+1
   248
   249 					lda #$00
   250 					sta eax
   251 					sta eax+5
   252 					sta eax+6
   253 					sta eax+7
   254
   255 					STA ZTMP8
   256 					STA ZTMP9
   257 					STA ZTMP10
   258 					STA ZTMP11
   259
   260 					LDY #64
   261 				UDIV320	ASL eax
   262 					ROL eax+1
   263 					ROL eax+2
   264 					ROL eax+3
   265 					ROL eax+4
   266 					ROL eax+5
   267 					ROL eax+6
   268 					ROL eax+7
   269
   270 					ROL ZTMP8
   271 					ROL ZTMP9
   272 					ROL ZTMP10
   273 					ROL ZTMP11
   274 							;do a subtraction
   275 					LDA ZTMP8
   276 					CMP ecx
   277 					LDA ZTMP9
   278 					SBC ecx+1
   279 					LDA ZTMP10
   280 					SBC ecx+2
   281 					LDA ZTMP11
   282 					SBC ecx+3
   283 					BCC UDIV321
   284 				 			;overflow, do the subtraction again, this time store the result
   285 					STA ecx+3	;we have the high byte already
   286 					LDA ZTMP8
   287 					SBC ecx		;byte 0
   288 					STA ZTMP8
   289 					LDA ZTMP9
   290 					SBC ecx+1
   291 					STA ZTMP9	;byte 1
   292 					LDA ZTMP10
   293 					SBC ecx+2
   294 					STA ZTMP10	;byte 2
   295
   296 					INC eax		;set result bit
   297
   298 				UDIV321	DEY
   299 					BNE UDIV320
   300
   301 					rts
   302 				.endp
   303 				*/
   303
  1271 8AD8				icl '6502\cpu6502_single.asm'		; mul / div -> SINGLE		IEEE-754
Source: cpu6502_single.asm
     1 				; JAVA IEEE-32 (IEEE-754)
     2 				; David Schmenk
     3 				; https://sourceforge.net/projects/vm02/
     4 				; http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/src/
     5
     6 				/*
     7 					org eax
     8
     9 				FP1MAN0	.ds 1
    10 				FP1MAN1	.ds 1
    11 				FP1MAN2	.ds 1
    12 				FP1MAN3	.ds 1
    13
    14 					org ztmp8
    15
    16 				FP1SGN	.ds 1
    17 				FP1EXP	.ds 1
    18
    19 					org edx
    20
    21 				FP2MAN0	.ds 1
    22 				FP2MAN1	.ds 1
    23 				FP2MAN2	.ds 1
    24 				FP2MAN3	.ds 1
    25
    26 					org ztmp10
    27
    28 				FP2SGN	.ds 1
    29 				FP2EXP	.ds 1
    30
    31 					org ecx
    32
    33 				FPMAN0	.ds 1
    34 				FPMAN1	.ds 1
    35 				FPMAN2	.ds 1
    36 				FPMAN3	.ds 1
    37
    38 					org bp2
    39
    40 				FPSGN	.ds 1
    41 				FPEXP	.ds 1
    42
    43 				*/
    43
    44
    45 = 00CF			@rx	= bp+1
    46
    47 = 000A			MIN_EXPONENT	= 10
    48 = 00FF			MAX_EXPONENT	= 255
    49
    50
    51 8AD8			.proc	NEGINT
    52
    53 					LDA	#$00
    54 					SEC
    55
    56 8AD8			enter	SBC	FPMAN0
    57 					STA	FPMAN0
    58 					LDA	#$00
    59 					SBC	FPMAN1
    60 					STA	FPMAN1
    61 					LDA	#$00
    62 					SBC	FPMAN2
    63 					STA	FPMAN2
    64 					LDA	#$00
    65 					SBC	FPMAN3
    66 					STA	FPMAN3
    67 					RTS
    68 				.endp
    69
    70
    71 8AD8			.proc	FFRAC
    72 					inx
    73 					lda :STACKORIGIN-1,x
    74 					sta :STACKORIGIN,x
    75
    76 					lda :STACKORIGIN-1+STACKWIDTH,x
    77 					sta :STACKORIGIN+STACKWIDTH,x
    78
    79 					lda :STACKORIGIN-1+STACKWIDTH*2,x
    80 					sta :STACKORIGIN+STACKWIDTH*2,x
    81
    82 					lda :STACKORIGIN-1+STACKWIDTH*3,x
    83 					eor #$80
    84 					sta :STACKORIGIN+STACKWIDTH*3,x
    85
    86 					dex
    87
    88 					jsr F2I
    89 					jsr I2F
    90
    91 					lda :STACKORIGIN+STACKWIDTH*3,x
    92 					eor #$80
    93 					sta :STACKORIGIN+STACKWIDTH*3,x
    94
    95 					inx
    96
    97 					jsr FSUB
    98
    99 					dex
   100
   101 					rts
   102 				.endp
   103
   104
   105 8AD8			.proc	FROUND
   106 				;	LDA	#$00
   107 				;	STA	FP2SGN
   108
   109 					lda :STACKORIGIN,x
   110 					STA	FP2MAN0
   111 					lda :STACKORIGIN+STACKWIDTH,x
   112 					STA	FP2MAN1
   113 					lda :STACKORIGIN+STACKWIDTH*2,x
   114 					CMP	#$80		; SET CARRY FROM MSB
   115 					ORA	#$80		; SET HIDDEN BIT
   116 					STA	FP2MAN2
   117 					lda :STACKORIGIN+STACKWIDTH*3,x
   118 				;	EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   119 					ROL
   120 					STA	FP2EXP
   121 					LDA	#$00
   122 					STA	FPSGN
   123 					BCC	@+
   124 					SBC	FP2MAN0
   125 					STA	FP2MAN0
   126 					LDA	#$00
   127 					SBC	FP2MAN1
   128 					STA	FP2MAN1
   129 					LDA	#$00
   130 					SBC	FP2MAN2
   131 					STA	FP2MAN2
   132 					LDA	#$FF
   133 8AD8			@	STA	FP2MAN3
   134 					lda #$00
   135 					STA	FP1MAN0
   136 					STA	FP1MAN1
   137 					CMP	#$80		; SET CARRY FROM MSB
   138 					ORA	#$80		; SET HIDDEN BIT
   139 					STA	FP1MAN2
   140
   141 					lda :STACKORIGIN+STACKWIDTH*3,x
   142 					and #$80
   143 					ora #$3f		; 0.5 / -0.5
   144
   145 					inx
   146
   147 					jsr FSUB.enter
   148
   149 					dex
   150
   151 					rts
   152 				.endp
   153
   154
   155 8AD8			.proc	FSUB
   156 					LDA	#$80		; TOGGLE SIGN
   157 					BNE	@+
   158 8AD8			FADD:	LDA	#$00
   159 8AD8			@	STA	FP2SGN
   160 				;	stx @rx
   161
   162 					lda :STACKORIGIN,x
   163 					STA	FP2MAN0
   164 					lda :STACKORIGIN+STACKWIDTH,x
   165 					STA	FP2MAN1
   166 					lda :STACKORIGIN+STACKWIDTH*2,x
   167 					CMP	#$80		; SET CARRY FROM MSB
   168 					ORA	#$80		; SET HIDDEN BIT
   169 					STA	FP2MAN2
   170 					lda :STACKORIGIN+STACKWIDTH*3,x
   171 					EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   172 					ROL
   173 					STA	FP2EXP
   174 					LDA	#$00
   175 					STA	FPSGN
   176 					BCC	@+
   177 					SBC	FP2MAN0
   178 					STA	FP2MAN0
   179 					LDA	#$00
   180 					SBC	FP2MAN1
   181 					STA	FP2MAN1
   182 					LDA	#$00
   183 					SBC	FP2MAN2
   184 					STA	FP2MAN2
   185 					LDA	#$FF
   186 8AD8			@	STA	FP2MAN3
   187 					lda :STACKORIGIN-1,x
   188 					STA	FP1MAN0
   189 					lda :STACKORIGIN-1+STACKWIDTH,x
   190 					STA	FP1MAN1
   191 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   192 					CMP	#$80		; SET CARRY FROM MSB
   193 					ORA	#$80		; SET HIDDEN BIT
   194 					STA	FP1MAN2
   195 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   196 8AD8			enter	ROL
   197 					STA	FP1EXP
   198 					LDA	#$00
   199 					BCC	@+
   200 					SBC	FP1MAN0
   201 					STA	FP1MAN0
   202 					LDA	#$00
   203 					SBC	FP1MAN1
   204 					STA	FP1MAN1
   205 					LDA	#$00
   206 					SBC	FP1MAN2
   207 					STA	FP1MAN2
   208 					LDA	#$FF
   209 8AD8			@	STA	FP1MAN3
   210 					LDA	FP1EXP		; CALCULATE WHICH MANTISSA TO SHIFT
   211 					STA	FPEXP
   212 					SEC
   213 					SBC	FP2EXP
   214 					BEQ	FADDMAN
   215 					BCS	@+
   216 					EOR	#$FF
   217 					TAY
   218 					INY
   219 					LDA	FP2EXP
   220 					STA	FPEXP
   221 					LDA	FP1MAN3
   222 					CPY	#24		; KEEP SHIFT RANGE VALID
   223 					BCC	FP1SHFT
   224 					LDA	#$00
   225 					STA	FP1MAN3
   226 					STA	FP1MAN2
   227 					STA	FP1MAN1
   228 					STA	FP1MAN0
   229 					BEQ	FADDMAN
   230 8AD8			FP1SHFT:	CMP	#$80	; SHIFT FP1 DOWN
   231 					ROR
   232 					ROR	FP1MAN2
   233 					ROR	FP1MAN1
   234 					ROR	FP1MAN0
   235 					DEY
   236 					BNE	FP1SHFT
   237 					STA	FP1MAN3
   238 					JMP	FADDMAN
   239
   240 8AD8			@	TAY
   241 					LDA	FP2MAN3
   242 					CPY	#24		; KEEP SHIFT RANGE VALID
   243 					BCC	FP2SHFT
   244 					LDA	#$00
   245 					STA	FP2MAN3
   246 					STA	FP2MAN2
   247 					STA	FP2MAN1
   248 					STA	FP2MAN0
   249 					BEQ	FADDMAN
   250 8AD8			FP2SHFT:	CMP	#$80	; SHIFT FP2 DOWN
   251 					ROR
   252 					ROR	FP2MAN2
   253 					ROR	FP2MAN1
   254 					ROR	FP2MAN0
   255 					DEY
   256 					BNE	FP2SHFT
   257 					STA	FP2MAN3
   258 8AD8			FADDMAN:	LDA	FP1MAN0
   259 					CLC
   260 					ADC	FP2MAN0
   261 					STA	FPMAN0
   262 					LDA	FP1MAN1
   263 					ADC	FP2MAN1
   264 					STA	FPMAN1
   265 					LDA	FP1MAN2
   266 					ADC	FP2MAN2
   267 					STA	FPMAN2
   268 					LDA	FP1MAN3
   269 					ADC	FP2MAN3
   270 					STA	FPMAN3
   271 					BPL	FPNORM
   272
   273 					LDA	#$80
   274 					STA	FPSGN
   275
   276 					JSR	NEGINT
   277
   278 					jmp FPNORM
   279 				.endp
   280
   281
   282 8AD8			.proc	FPNORM
   283 					BEQ	FPNORMLEFT	; NORMALIZE FP, A = FPMANT3
   284 8AD8			FPNORMRIGHT:	INC	FPEXP
   285 					LSR
   286 					STA	FPMAN3
   287 					ROR	FPMAN2
   288 					ROR	FPMAN1
   289 					LDA	FPMAN0
   290 					ROR
   291 					ADC	#$00
   292 					STA	FPMAN0
   293 					LDA	FPMAN1
   294 					ADC	#$00
   295 					STA	FPMAN1
   296 					LDA	FPMAN2
   297 					ADC	#$00
   298 					STA	FPMAN2
   299 					LDA	FPMAN3
   300 					ADC	#$00
   301 					BNE	FPNORMRIGHT
   302 					LDA	FPEXP
   303 					ASL	FPMAN2
   304 					LSR
   305 					ORA	FPSGN
   306
   307 				;	ldx @rx
   308 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   309 					LDA	FPMAN2
   310 					ROR
   311 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   312
   313 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   314 					asl @
   315 					tay
   316 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   317 					spl
   318 					iny
   319 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   320 					bcc zero
   321 					cpy #MAX_EXPONENT
   322 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   323
   324 					LDA	FPMAN1
   325 					sta :STACKORIGIN-1+STACKWIDTH,x
   326 					LDA	FPMAN0
   327 					sta :STACKORIGIN-1,x
   328 					rts
   329
   330 8AD8			FPNORMLEFT:	LDA	FPMAN2
   331 					BNE	FPNORMLEFT1
   332 					LDA	FPMAN1
   333 					BNE	FPNORMLEFT8
   334 					LDA	FPMAN0
   335 					BNE	FPNORMLEFT16
   336
   337 				;	ldx @rx			; RESULT IS ZERO
   338 8AD8			zero	lda #0
   339
   340 					sta :STACKORIGIN-1,x
   341 					sta :STACKORIGIN-1+STACKWIDTH,x
   342 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   343 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   344 					rts
   345
   346 8AD8			FPNORMLEFT16:	TAY
   347 					LDA	FPEXP
   348 					SEC
   349 					SBC	#$10
   350 					STA	FPEXP
   351 					LDA	#$00
   352 					STA	FPMAN1
   353 					STA	FPMAN0
   354 					TYA
   355 					BNE	FPNORMLEFT1
   356 8AD8			FPNORMLEFT8:	TAY
   357 					LDA	FPMAN0
   358 					STA	FPMAN1
   359 					LDA	FPEXP
   360 					SEC
   361 					SBC	#$08
   362 					STA	FPEXP
   363 					LDA	#$00
   364 					STA	FPMAN0
   365 					TYA
   366 8AD8			FPNORMLEFT1:	BMI	FPNORMDONE
   367 8AD8			@	DEC	FPEXP
   368 					ASL	FPMAN0
   369 					ROL	FPMAN1
   370 					ROL
   371 					BPL	@-
   372 8AD8			FPNORMDONE:	ASL
   373 					TAY
   374 					LDA	FPEXP
   375 					LSR
   376 					ORA	FPSGN
   377
   378 				;	ldx @rx
   379 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   380 					TYA
   381 					ROR
   382 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   383
   384 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   385 					asl @
   386 					tay
   387 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   388 					spl
   389 					iny
   390 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   391 					bcc zero
   392 					cpy #MAX_EXPONENT
   393 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   394
   395 					LDA	FPMAN1
   396 					sta :STACKORIGIN-1+STACKWIDTH,x
   397 					LDA	FPMAN0
   398 					sta :STACKORIGIN-1,x
   399
   400 					rts
   401 				.endp
   402
   403
   404 8AD8			.proc	FMUL
   405
   406 					stx @rx
   407
   408 					lda :STACKORIGIN,x
   409 					STA	FP2MAN0
   410 					lda :STACKORIGIN+STACKWIDTH,x
   411 					STA	FP2MAN1
   412 					lda :STACKORIGIN+STACKWIDTH*2,x
   413 					CMP	#$80		; SET CARRY FROM MSB
   414 					ORA	#$80		; SET HIDDEN BIT
   415 					STA	FP2MAN2
   416 				 	lda :STACKORIGIN+STACKWIDTH*3,x
   417 					ROL
   418 					STA	FP2EXP
   419 					BNE	@+
   420
   421 				; MUL BY ZERO, RESULT ZERO
   422 				;	LDA	#$00
   423 8AD8			ZERO:	STA :STACKORIGIN-1,x
   424 					STA :STACKORIGIN-1+STACKWIDTH,x
   425 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   426 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   427 					rts
   428
   429 8AD8			@	LDA	#$00
   430 					ROR
   431 					STA	FPSGN
   432 					lda :STACKORIGIN-1,x
   433 					STA	FP1MAN0
   434 					lda :STACKORIGIN-1+STACKWIDTH,x
   435 					STA	FP1MAN1
   436 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   437 					CMP	#$80		; SET CARRY FROM MSB
   438 					ORA	#$80		; SET HIDDEN BIT
   439 					STA	FP1MAN2
   440 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   441 					ROL
   442 					STA	FP1EXP
   443 					BEQ	ZERO		; MUL BY ZERO, RESULT ZERO
   444
   445 					LDA	#$00
   446 					ROR
   447 					EOR	FPSGN
   448 					STA	FPSGN
   449 					LDA	FP1EXP
   450 					CLC			; ADD EXPONENTS
   451 					ADC	FP2EXP
   452 					SEC			; SUBTRACT BIAS
   453 					SBC	#$7F
   454 					STA	FPEXP
   455 					LDX	#$00
   456 					STX	FPMAN0
   457 					STX	FPMAN1
   458 					STX	FPMAN2
   459 					STX	FPMAN3
   460 					STX	TMP
   461 8AD8			FMULNEXTBYTE:	LDA	FP1MAN0,X
   462 					BNE	@+
   463 					LDX	FPMAN1		; SHORT CIRCUIT BYTE OF ZERO BITS
   464 					STX	FPMAN0
   465 					LDX	FPMAN2
   466 					STX	FPMAN1
   467 					LDX	FPMAN3
   468 					STX	FPMAN2
   469 					STA	FPMAN3
   470 					INC	TMP
   471 					LDX	TMP
   472 					CPX	#$03
   473 					BNE	FMULNEXTBYTE
   474
   475 					ldx @rx
   476 					LDA	FPMAN3
   477 					JMP	FPNORM
   478
   479 8AD8			@	EOR	#$FF
   480 					LDX	#$08
   481 8AD8			FMULTSTBITS:	LSR	FPMAN3
   482 					ROR	FPMAN2
   483 					ROR	FPMAN1
   484 					ROR	FPMAN0
   485 					LSR
   486 					BCS	FMULNEXTTST
   487 					TAY
   488 					LDA	FP2MAN0
   489 					ADC	FPMAN0
   490 					STA	FPMAN0
   491 					LDA	FP2MAN1
   492 					ADC	FPMAN1
   493 					STA	FPMAN1
   494 					LDA	FP2MAN2
   495 					ADC	FPMAN2
   496 					STA	FPMAN2
   497 					LDA	#$00
   498 					ADC	FPMAN3
   499 					STA	FPMAN3
   500 					TYA
   501 8AD8			FMULNEXTTST:	DEX
   502 					BNE	FMULTSTBITS
   503 					INC	TMP
   504 					LDX	TMP
   505 					CPX	#$03
   506 					BNE	FMULNEXTBYTE
   507
   508 					ldx @rx
   509 					LDA	FPMAN3
   510 					JMP	FPNORM
   511 				.endp
   512
   513
   514 8AD8			.proc	FDIV
   515
   516 					stx @rx
   517
   518 					lda :STACKORIGIN,x
   519 					STA	FP2MAN0
   520 					lda :STACKORIGIN+STACKWIDTH,x
   521 					STA	FP2MAN1
   522 					lda :STACKORIGIN+STACKWIDTH*2,x
   523 					CMP	#$80		; SET CARRY FROM MSB
   524 					ORA	#$80		; SET HIDDEN BIT
   525 					STA	FP2MAN2
   526 					lda :STACKORIGIN+STACKWIDTH*3,x
   527 					ROL
   528 					STA	FP2EXP
   529 					BNE	@+
   530
   531 				;	LDA	#$00
   532 8AD8			ZERO:	STA :STACKORIGIN-1,x
   533 					STA :STACKORIGIN-1+STACKWIDTH,x
   534 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   535 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   536 					rts
   537 				;	LDA	#23		; DIVIDE BY ZERO, ERROR
   538 				;	JMP	SYSTHROW
   539
   540 8AD8			@	LDA	#$00
   541 					ROR
   542 					STA	FPSGN
   543 					lda :STACKORIGIN-1,x
   544 					STA	FP1MAN0
   545 					lda :STACKORIGIN-1+STACKWIDTH,x
   546 					STA	FP1MAN1
   547 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   548 					CMP	#$80		; SET CARRY FROM MSB
   549 					ORA	#$80		; SET HIDDEN BIT
   550 					STA	FP1MAN2
   551 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   552 					ROL
   553 					STA	FP1EXP
   554 					BEQ	ZERO		; DIVIDE ZERO, RESULT ZERO
   555
   556 					LDA	#$00
   557 					STA	FP1MAN3
   558 					ROR
   559 					EOR	FPSGN
   560 					STA	FPSGN
   561 					LDA	FP1EXP
   562 					SEC			; SUBTRACT EXPONENTS
   563 					SBC	FP2EXP
   564 					CLC
   565 					ADC	#$7F		; ADD BACK BIAS
   566 					STA	FPEXP
   567
   568 					LDX	#24		; #BITS
   569 8AD8			FDIVLOOP:	LDA	FP1MAN0
   570 					SEC
   571 					SBC	FP2MAN0
   572 					STA	TMP
   573 					LDA	FP1MAN1
   574 					SBC	FP2MAN1
   575 					STA	TMP+1
   576 					LDA	FP1MAN2
   577 					SBC	FP2MAN2
   578 					TAY
   579 					LDA	FP1MAN3
   580 					SBC	#$00
   581 					BCC	FDIVNEXTBIT
   582 					STA	FP1MAN3
   583 					STY	FP1MAN2
   584 					LDA	TMP+1
   585 					STA	FP1MAN1
   586 					LDA	TMP
   587 					STA	FP1MAN0
   588 8AD8			FDIVNEXTBIT:	ROL	FPMAN0
   589 					ROL	FPMAN1
   590 					ROL	FPMAN2
   591 					ASL	FP1MAN0
   592 					ROL	FP1MAN1
   593 					ROL	FP1MAN2
   594 					ROL	FP1MAN3
   595 					DEX
   596 					BNE	FDIVLOOP
   597
   598 					ldx @rx
   599 					LDA	#$00
   600 					JMP	FPNORM
   601 				.endp
   602
   603
   604 8AD8			.proc	FCMPL
   605 8AD8			FCMPG:
   606 					CLV
   607
   608 					LDA	:STACKORIGIN+STACKWIDTH*3,X	; COMPARE SIGNS
   609 					AND	#$80
   610 					STA	FP2SGN
   611 					LDA	:STACKORIGIN-1+STACKWIDTH*3,X
   612 					AND	#$80
   613 					CMP	FP2SGN
   614 					BCC	FCMPGTSGN
   615 					BEQ	@+
   616 					BCS	FCMPLTSGN
   617 8AD8			@	LDA	:STACKORIGIN-1+STACKWIDTH*3,X	; COMPARE AS MAGNITUDE
   618 					CMP	:STACKORIGIN+STACKWIDTH*3,X
   619 					BCC	FCMPLT
   620 					BEQ	@+
   621 					BCS	FCMPGT
   622 8AD8			@	LDA	:STACKORIGIN-1+STACKWIDTH*2,X
   623 					CMP	:STACKORIGIN+STACKWIDTH*2,X
   624 					BCC	FCMPLT
   625 					BEQ	@+
   626 					BCS	FCMPGT
   627 8AD8			@	LDA	:STACKORIGIN-1+STACKWIDTH,X
   628 					CMP	:STACKORIGIN+STACKWIDTH,X
   629 					BCC	FCMPLT
   630 					BEQ	@+
   631 					BCS	FCMPGT
   632 8AD8			@	LDA	:STACKORIGIN-1,X
   633 					CMP	:STACKORIGIN,X
   634 					BCC	FCMPLT
   635 					BEQ	FCMPEQ
   636 					BCS	FCMPGT
   637 8AD8			FCMPEQ:	LDA #0			; EQUAL
   638 					RTS
   639
   640 8AD8			FCMPGT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   641 					BMI	FCMPLTSGN
   642 8AD8			FCMPGTSGN:	LDA	#$01	; GREATER THAN
   643 					RTS
   644
   645 8AD8			FCMPLT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   646 					BMI	FCMPGTSGN
   647 8AD8			FCMPLTSGN:	LDA	#$FF	; LESS THAN
   648 					RTS
   649 				.endp
   650
   651
   652 8AD8			.proc	F2I
   653
   654 					lda :STACKORIGIN,x
   655 					STA	FPMAN0
   656 					lda :STACKORIGIN+STACKWIDTH,x
   657 					STA	FPMAN1
   658 					lda :STACKORIGIN+STACKWIDTH*2,x
   659 					CMP	#$80		; SET CARRY FROM MSB
   660 					ORA	#$80		; SET HIDDEN BIT
   661 					STA	FPMAN2
   662 					lda :STACKORIGIN+STACKWIDTH*3,x
   663 					ROL	@
   664 					STA	FPEXP
   665 					LDA	#$00
   666 					ROR	@
   667 					STA	FPSGN
   668 					LDA	FPEXP		; CHECK FOR LESS THAN ONE
   669 					SEC
   670 					SBC	#$7F
   671 					BCS	@+
   672
   673 8AD8			ZERO:	LDA	#$00		; RETURN ZERO
   674 					STA :STACKORIGIN,x
   675 					STA :STACKORIGIN+STACKWIDTH,x
   676 					STA :STACKORIGIN+STACKWIDTH*2,x
   677 					STA :STACKORIGIN+STACKWIDTH*3,x
   678 					rts
   679
   680 8AD8			@	CMP	#23
   681 					BCS	F2ISHL
   682 					STA	FPEXP
   683 					LDA	#23
   684 					SEC
   685 					SBC	FPEXP
   686 					TAY			; SHIFT MANTISSA RIGHT
   687 					LDA	FPMAN2
   688 8AD8			F2ISHR:	LSR	@
   689 					ROR	FPMAN1
   690 					ROR	FPMAN0
   691 					DEY
   692 					BNE	F2ISHR
   693 					STA	FPMAN2
   694 					STY	FPMAN3
   695 8AD8			F2ICHKNEG:	LDA	FPSGN
   696 					BPL	@+		; CHECK FOR NEGATIVE
   697 					ASL	@		; LDA #$00; SEC
   698
   699 					JSR	NEGINT.enter
   700
   701 8AD8			@	LDA	FPMAN3
   702 					STA :STACKORIGIN+STACKWIDTH*3,x
   703 					LDA	FPMAN2
   704 					STA :STACKORIGIN+STACKWIDTH*2,x
   705 					LDA	FPMAN1
   706 					STA :STACKORIGIN+STACKWIDTH,x
   707 					LDA	FPMAN0
   708 					STA :STACKORIGIN,x
   709 					rts
   710
   711 8AD8			F2ISHL:	CMP	#32
   712 					BCC	@+
   713 					LDA	#$FF		; OVERFLOW, STORE MAXINT
   714 					STA	FPMAN0
   715 					STA	FPMAN1
   716 					STA	FPMAN2
   717 					LSR	@
   718 					STA	FPMAN3
   719 					BNE	F2ICHKNEG
   720 8AD8			@	SEC
   721 					SBC	#23
   722 					BNE	@+
   723 					STA	FPMAN3
   724 					BEQ	F2ICHKNEG
   725 8AD8			@	TAY			; SHIFT MANTISSA LEFT
   726 					LDA	#$00
   727 8AD8			@	ASL	FPMAN0
   728 					ROL	FPMAN1
   729 					ROL	FPMAN2
   730 					ROL	@
   731 					DEY
   732 					BNE	@-
   733 					STA	FPMAN3
   734 					BEQ	F2ICHKNEG
   735 				.endp
   736
   737
   738 8AD8			.proc	I2F
   739
   740 					lda :STACKORIGIN,x
   741 					STA	FPMAN0
   742 					lda :STACKORIGIN+STACKWIDTH,x
   743 					STA	FPMAN1
   744 					lda :STACKORIGIN+STACKWIDTH*2,x
   745 					STA	FPMAN2
   746 					lda :STACKORIGIN+STACKWIDTH*3,x
   747 					STA	FPMAN3
   748 					AND	#$80
   749 					STA	FPSGN
   750 					BPL	@+
   751 				;	LDX	#FPMAN0
   752 					JSR	NEGINT
   753 8AD8			@	LDA	#$7F+23
   754 					STA	FPEXP
   755
   756 					inx			; ten zabieg zapisze pod :STACKORIGIN,x
   757 								; zamiast :STACKORIGIN-1,x
   758 					LDA	FPMAN3
   759 					JSR	FPNORM
   760
   761 					dex
   762 					rts
   763 				.endp
   764
   765
   766 8AD8			.proc	I2F_m
   767
   768 					lda :STACKORIGIN-1,x
   769 					STA	FPMAN0
   770 					lda :STACKORIGIN-1+STACKWIDTH,x
   771 					STA	FPMAN1
   772 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   773 					STA	FPMAN2
   774 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   775
   776 					STA	FPMAN3
   777 					AND	#$80
   778 					STA	FPSGN
   779 					BPL	@+
   780 				;	LDX	#FPMAN0
   781 					JSR	NEGINT
   782 8AD8			@	LDA	#$7F+23
   783 					STA	FPEXP
   784
   785 					LDA	FPMAN3
   786 					JMP	FPNORM
   787 				.endp
  1272
  1273
  1274 8AD8			.proc	@printCHAR
  1275 					ldy :STACKORIGIN,x
  1276 					jmp @print
  1277 				.endp
  1278
  1279
  1280 8AD8			.proc	@printEOL
  1281 					ldy #eol
  1282 					jmp @print
  1283 				.endp
  1284
  1285
  1286 8AD8			.proc	@print (.byte y) .reg
  1287 8AD8 8A 48			txa:pha
  1288
  1289 8ADA 98				tya
  1290 8ADB 20 A0 8B			jsr @putchar
  1291
  1292 8ADE 68 AA			pla:tax
  1293 8AE0 60				rts
  1294 				.endp
  1295
  1296
  1297 8AE1			.proc	@printPCHAR (.word ya) .reg
  1298 					
  1299 					sta cndx0
  1300 					sty cndx1
  1301
  1302 					stx ctmp2
  1303
  1304 					lda #0
  1305 					sta ctmp0
  1306
  1307 8AE1			loop	
  1308 					ldy ctmp0
  1309 					lda (cndx0),y
  1310 					beq stop
  1311
  1312 					inc ndx0
  1313 					beq stop
  1314
  1315 					jsr @putchar
  1316
  1317 					jmp loop
  1318
  1319 8AE1			stop	
  1320 					ldx ctmp2
  1321 					rts
  1322 				.endp
  1323
  1324
  1325 8AE1			.proc	@printSTRING (.word ya) .reg
  1326 					sta ztmp
  1327 					sty ztmp+1
  1328
  1329 					stx ctmp2
  1330
  1331 					ldy #0
  1332 					sty ctmp0
  1333 					lda (ztmp),y
  1334 					sta ctmp3
  1335
  1336 					inw ztmp
  1337
  1338 8AE1			loop	
  1339 					ldy ctmp0
  1340 					lda (ztmp),y
  1341 				;	beq stop
  1342
  1343 					cpy ctmp1
  1344 					beq stop
  1345
  1346 					inc ctmp0
  1347
  1348 					jsr @putchar
  1349
  1350 					jmp loop
  1351
  1352 8AE1			stop	ldx ctmp2
  1353 					rts
  1354 				.endp
  1355
  1356
  1357 8AE1			.proc	@printBOOLEAN
  1358 					lda :STACKORIGIN,x
  1359 					beq _0
  1360
  1361 8AE1			_1	lda <_true
  1362 					ldy >_true
  1363 					jmp @printSTRING
  1364
  1365 8AE1			_0	lda <_false
  1366 					ldy >_false
  1367 					jmp @printSTRING
  1368
  1369 8AE1			_true	dta 4,c'TRUE'
  1370 8AE1			_false	dta 5,c'FALSE'
  1371 				.endp
  1372
  1373
  1374 8AE1			.proc	mov_BYTE_DX
  1375 					mva :STACKORIGIN,x dx
  1376 					mva #$00 dx+1
  1377 					sta dx+2
  1378 					sta dx+3
  1379
  1380 					rts
  1381 				.endp
  1382
  1383 8AE1			.proc	mov_WORD_DX
  1384 					mva :STACKORIGIN,x dx
  1385 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1386 					mva #$00 dx+2
  1387 					sta dx+3
  1388
  1389 					rts
  1390 				.endp
  1391
  1392 8AE1			.proc	mov_CARD_DX
  1393 8AE1 B5 80 85 C6			mva :STACKORIGIN,x dx
  1394 8AE5 B5 90 85 C7			mva :STACKORIGIN+STACKWIDTH,x dx+1
  1395 8AE9 B5 A0 85 C8			mva :STACKORIGIN+STACKWIDTH*2,x dx+2
  1396 8AED B5 B0 85 C9			mva :STACKORIGIN+STACKWIDTH*3,x dx+3
  1397
  1398 8AF1 60				rts
  1399 				.endp
  1400
  1401
  1402 8AF2			.proc	@printMINUS
  1403 8AF2 A0 2D			ldy #'-'
  1404 8AF4 20 5C 8B			jsr @printVALUE.pout
  1405
  1406 8AF7 4C AB 8A			jmp negCARD
  1407 				.endp
  1408
  1409
  1410 8AFA			.proc	@printSHORTREAL
  1411 					jsr @expandToCARD.SMALL
  1412 					jmp @printREAL
  1413 				.endp
  1414
  1415
  1416 8AFA			.proc	@FTOA
  1417
  1418 = 00C6			i	= edx
  1419 = 00CA			fra	= ecx
  1420 = 00C2			hlp	= eax
  1421
  1422 = 00D2			exp	= ztmp
  1423 = 00D3			b	= ztmp+1
  1424 = 00D4			sht	= ztmp+2
  1425
  1426 = 0440			bit	= @buf+64
  1427
  1428 					stx ctmp3
  1429
  1430 					mva :STACKORIGIN,x I
  1431 					sta :STACKORIGIN+9
  1432 					mva :STACKORIGIN+STACKWIDTH,x I+1
  1433 					sta :STACKORIGIN+STACKWIDTH+9
  1434 					mva :STACKORIGIN+STACKWIDTH*2,x I+2
  1435 					sta :STACKORIGIN+STACKWIDTH*2+9
  1436 					mva :STACKORIGIN+STACKWIDTH*3,x I+3
  1437 					sta :STACKORIGIN+STACKWIDTH*3+9	; Sign
  1438
  1439 					bpl skp
  1440
  1441 					ldy #'-'
  1442 					jsr @printVALUE.pout
  1443
  1444 8AFA			skp
  1445 				; optimize OK (test_3.pas), line = 32
  1446
  1447 					lda :STACKORIGIN+STACKWIDTH*3+9
  1448 					asl :STACKORIGIN+9
  1449 					rol :STACKORIGIN+STACKWIDTH+9
  1450 					rol :STACKORIGIN+STACKWIDTH*2+9
  1451 					rol @
  1452 					sta EXP				; Exponent
  1453
  1454 				; optimize OK (test_3.pas), line = 33
  1455
  1456 					lda I
  1457 					sta FRA
  1458 					lda I+1
  1459 					sta FRA+1
  1460 					lda I+2
  1461 					sta FRA+2
  1462 					lda I+3
  1463 					sta FRA+3
  1464 					asl FRA
  1465 					rol FRA+1
  1466 					rol FRA+2
  1467 					rol FRA+3
  1468
  1469 				; optimize OK (test_3.pas), line = 35
  1470
  1471 					lda EXP
  1472 					sub #$7F
  1473 					sta SHT
  1474
  1475 				; optimize OK (test_3.pas), line = 37
  1476
  1477 					ldx #$3f
  1478 					lda #0
  1479 					sta:rpl bit,x-
  1480
  1481 				; For
  1482
  1483 				; optimize OK (test_3.pas), line = 39
  1484
  1485 				;	sta B
  1486 					tax
  1487
  1488 				; optimize OK (test_3.pas), line = 39
  1489
  1490 8AFA			l_01D4
  1491 				;	lda B
  1492 				;	cmp #$17
  1493 					cpx #$17
  1494 					bcc *+7
  1495 					beq *+5
  1496
  1497 				; ForToDoProlog
  1498 					jmp l_01EE
  1499
  1500 				; optimize OK (test_3.pas), line = 40
  1501
  1502 				;	lda #$20
  1503 				;	add B
  1504 				;	tax
  1505
  1506 					lda FRA+2
  1507 					sta BIT+$20,x
  1508
  1509 				; optimize OK (test_3.pas), line = 41
  1510
  1511 					asl FRA
  1512 					rol FRA+1
  1513 					rol FRA+2
  1514 					rol FRA+3
  1515
  1516 				; ForToDoEpilog
  1517 8AFA			c_01D4
  1518 				;	inc B
  1519 					inx
  1520
  1521 					seq
  1522
  1523 				; WhileDoEpilog
  1524 					jmp l_01D4
  1525 8AFA			l_01EE
  1526 8AFA			b_01D4
  1527
  1528 				; optimize OK (test_3.pas), line = 44
  1529
  1530 					mva #$80 BIT+$1f
  1531
  1532 				; optimize OK (test_3.pas), line = 46
  1533
  1534 					mva #$00 I
  1535 					sta I+1
  1536 					sta I+2
  1537 					sta I+3
  1538
  1539 				; optimize OK (test_3.pas), line = 47
  1540
  1541 					sta FRA+1
  1542 					sta FRA+2
  1543 					sta FRA+3
  1544
  1545 					mva #$01 FRA
  1546
  1547 				; For
  1548
  1549 				; optimize OK (test_3.pas), line = 49
  1550
  1551 					lda SHT
  1552 					add #$1F
  1553 					sta B
  1554
  1555 				; optimize OK (test_3.pas), line = 49
  1556
  1557 					tay
  1558
  1559 8AFA			l_035B
  1560 				;	lda B
  1561 				;	cmp #$00
  1562 				;	bcs *+5
  1563
  1564 				; ForToDoProlog
  1565 				;	jmp l_0375
  1566
  1567 				; optimize OK (test_3.pas), line = 50
  1568
  1569 				;	ldy B
  1570 					lda BIT,y
  1571 					bpl l_03D7
  1572
  1573 				; optimize OK (test_3.pas), line = 50
  1574
  1575 					lda I				; Mantissa
  1576 					add FRA
  1577 					sta I
  1578 					lda I+1
  1579 					adc FRA+1
  1580 					sta I+1
  1581 					lda I+2
  1582 					adc FRA+2
  1583 					sta I+2
  1584 					lda I+3
  1585 					adc FRA+3
  1586 					sta I+3
  1587
  1588 				; IfThenEpilog
  1589 8AFA			l_03D7
  1590
  1591 				; optimize OK (test_3.pas), line = 52
  1592
  1593 					asl FRA
  1594 					rol FRA+1
  1595 					rol FRA+2
  1596 					rol FRA+3
  1597
  1598 				; ForToDoEpilog
  1599 8AFA			c_035B
  1600 				;	dec B
  1601 					dey
  1602
  1603 				;	lda B
  1604 				;	cmp #$ff
  1605 					cpy #$ff
  1606 					seq
  1607
  1608 				; WhileDoEpilog
  1609 					jmp l_035B
  1610 8AFA			l_0375
  1611 8AFA			b_035B
  1612
  1613 				; optimize OK (test_3.pas), line = 55
  1614
  1615 					mva #$00 FRA
  1616 					sta FRA+1
  1617 					sta FRA+2
  1618 					sta FRA+3
  1619
  1620 				; optimize OK (test_3.pas), line = 56
  1621
  1622 					sta EXP
  1623
  1624 					sta hlp
  1625 					sta hlp+1
  1626
  1627 					lda #$80
  1628 					sta hlp+2
  1629 				; For
  1630
  1631 				; optimize OK (test_3.pas), line = 58
  1632
  1633 					lda SHT
  1634 					add #$20
  1635 				;	sta B
  1636
  1637 					tay
  1638
  1639 				; optimize OK (test_3.pas), line = 58
  1640
  1641 					add #23
  1642 					sta ctmp3
  1643 				; To
  1644 8AFA			l_0508
  1645
  1646 				; ForToDoCondition
  1647
  1648 				; optimize OK (test_3.pas), line = 58
  1649
  1650 				;	lda B
  1651 				;	cmp #0
  1652 					cpy ctmp3
  1653
  1654 					bcc *+7
  1655 					beq *+5
  1656
  1657 				; ForToDoProlog
  1658 					jmp l_0534
  1659
  1660 				; optimize OK (test_3.pas), line = 59
  1661
  1662 				;	ldy B
  1663 					lda BIT,y
  1664 					bpl l_0596
  1665
  1666 				; optimize OK (test_3.pas), line = 59
  1667
  1668 					lda FRA
  1669 					add hlp
  1670 					sta FRA
  1671 					lda FRA+1
  1672 					adc hlp+1
  1673 					sta FRA+1
  1674 					lda FRA+2
  1675 					adc hlp+2
  1676 					sta FRA+2
  1677
  1678 				; IfThenEpilog
  1679 8AFA			l_0596
  1680
  1681 					lsr hlp+2
  1682 					ror hlp+1
  1683 					ror hlp
  1684
  1685 				; ForToDoEpilog
  1686 8AFA			c_0508
  1687 				;	inc B						; inc ptr byte [CounterAddress]
  1688 					iny
  1689
  1690 					seq
  1691
  1692 				; WhileDoEpilog
  1693 					jmp l_0508
  1694 8AFA			l_0534
  1695 8AFA			b_0508
  1696 8AFA				:3 mva fra+# fracpart+#
  1697
  1698 					mva #6 @float.afterpoint	; wymagana liczba miejsc po przecinku
  1699 					@float #500000
  1700
  1701 					ldx ctmp3
  1702
  1703 					rts
  1704 				.endp
  1705
  1706
  1707 8AFA			.proc	@printREAL
  1708
  1709 					stx ctmp3
  1710
  1711 					lda :STACKORIGIN+STACKWIDTH*3,x
  1712 					spl
  1713 					jsr @printMINUS
  1714
  1715 					jsr mov_CARD_DX
  1716
  1717 					mva dx+1 intpart		; intpart := uvalue shr 8
  1718 					mva dx+2 intpart+1
  1719 					mva dx+3 intpart+2
  1720 					mva #$00 intpart+3
  1721
  1722 					sta dx+3			; fracpart := uvalue and $FF (dx)
  1723 					sta dx+2
  1724 					sta dx+1
  1725
  1726 					sta fracpart
  1727 					sta fracpart+1
  1728
  1729 					lda dx
  1730 					sta fracpart+2
  1731
  1732 8AFA				:4 mva intpart+# dx+#		; integer part
  1733
  1734 					mva #4 @float.afterpoint		; wymagana liczba miejsc po przecinku
  1735 					@float #5000
  1736
  1737 					ldx ctmp3
  1738
  1739 					rts
  1740
  1741 8AFA 00 00 00 00		intpart		.dword
  1742
  1743 				.endp
  1744
  1745
  1746 8AFE			.proc	@float (.long axy) .reg
  1747 					cnt = ctmp0
  1748 					afterpoint = ctmp1
  1749 					 
  1750 					sty cx
  1751 					stx cx+1
  1752 					sta cx+2
  1753
  1754 					lda Pout_Flag       		; print integer part
  1755 					pha
  1756 					jsr @printVALUE
  1757 					pla
  1758 					sta Pout_Flag
  1759
  1760 					lda #0
  1761 					sta dx
  1762 					sta dx+1
  1763 					sta dx+2
  1764 					sta dx+3
  1765
  1766 8AFE			loop	lda fracpart+2
  1767 					bpl skp
  1768
  1769 					clc
  1770 				;	lda cx
  1771 				;	spl
  1772 				;	sec
  1773
  1774 					lda dx
  1775 					adc cx
  1776 					sta dx
  1777 					lda dx+1
  1778 					adc cx+1
  1779 					sta dx+1
  1780 					lda dx+2
  1781 					adc cx+2
  1782 					sta dx+2
  1783 				;	lda dx+3
  1784 				;	adc #0
  1785 				;	sta dx+3
  1786
  1787 8AFE			skp	lsr cx+2
  1788 					ror cx+1
  1789 					ror cx
  1790
  1791 					asl fracpart
  1792 					rol fracpart+1
  1793 					rol fracpart+2
  1794
  1795 					lda cx
  1796 					ora cx+1
  1797 					ora cx+2
  1798
  1799 					bne loop
  1800
  1801 					ldy #'.'
  1802 					jsr @printVALUE.pout
  1803
  1804 8AFE				:4 mva dx+# fracpart+#
  1805
  1806 					lda Pout_Flag
  1807 					pha
  1808
  1809 					lda #064   
  1810 					sta Pout_Flag
  1811 					jsr @printVALUE			; floating part length
  1812
  1813 					sta cnt
  1814
  1815 					pla
  1816 					sta Pout_Flag
  1817
  1818 8AFE			lp	
  1819 				  lda cnt
  1820 					cmp afterpoint 
  1821 					bcs ok
  1822
  1823 					ldy #'0'
  1824 					jsr @printVALUE.pout
  1825
  1826 					inc cnt
  1827 					bne lp
  1828
  1829 8AFE			ok	:4 mva fracpart+# dx+#
  1830 					jmp @printVALUE			; print floating part
  1831
  1832 				.endp
  1833
  1834
  1835 8AFE			.proc	@printSHORTINT
  1836
  1837 					lda :STACKORIGIN,x
  1838 					spl
  1839 					jsr @printMINUS
  1840
  1841 					jmp @printBYTE
  1842 				.endp
  1843
  1844
  1845 8AFE			.proc	@printSMALLINT
  1846
  1847 					lda :STACKORIGIN+STACKWIDTH,x
  1848 					spl
  1849 					jsr @printMINUS
  1850
  1851 					jmp @printWORD
  1852 				.endp
  1853
  1854
  1855 8AFE			.proc	@printINT
  1856
  1857 8AFE B5 B0			lda :STACKORIGIN+STACKWIDTH*3,x
  1858 8B00 10 03			spl
  1859 8B02 20 F2 8A			jsr @printMINUS
  1860
  1861 8B05 4C 08 8B			jmp @printCARD
  1862 				.endp
  1863
  1864
  1865 8B08			.proc	@printCARD
  1866 8B08 20 E1 8A			jsr mov_CARD_DX
  1867 8B0B 4C 0E 8B			jmp @printVALUE
  1868 				.endp
  1869
  1870
  1871 8B0E			.proc	@printWORD
  1872 					jsr mov_WORD_DX
  1873 					jmp @printVALUE
  1874 				.endp
  1875
  1876
  1877 8B0E			.proc	@printBYTE
  1878 					jsr mov_BYTE_DX
  1879 					jmp @printVALUE
  1880 				.endp
  1881
  1882
  1883 8B0E			.proc	@printVALUE
  1884 = 00EA			  limit = ctmp0
  1885 = 00EB				cnt = ctmp1
  1886 					
  1887 8B0E A5 C9			lda dx+3
  1888 8B10 D0 14			bne _32bit
  1889
  1890 8B12 A5 C8			lda dx+2
  1891 8B14 D0 0C			bne _24bit
  1892
  1893 8B16 A5 C7			lda dx+1
  1894 8B18 D0 04			bne _16bit
  1895
  1896 8B1A A9 03		_8bit	lda #3
  1897 8B1C D0 0A			bne l3
  1898
  1899 8B1E A9 05		_16bit	lda #5
  1900 8B20 D0 06			bne l3
  1901
  1902 8B22 A9 08		_24bit	lda #8
  1903 8B24 D0 02			bne l3
  1904
  1905 					; prints a 32 bit value to the screen (Graham)
  1906
  1907 8B26 A9 0A		_32bit	lda #10
  1908
  1909 8B28 85 EA		l3	sta limit
  1910
  1911 8B2A 86 ED			stx ctmp3
  1912
  1913 8B2C A2 00			ldx #0
  1914 8B2E 86 EB			stx cnt
  1915
  1916 8B30 20 71 8B		lp	jsr div10
  1917
  1918 8B33 9D 4E 02			sta temp_storage,x
  1919 8B36 E8				inx
  1920 8B37 E4 EA			cpx limit	
  1921 8B39 D0 F5			bne lp
  1922
  1923 					;ldx #9
  1924 8B3B CA				dex
  1925
  1926 8B3C BD 4E 02		l1	lda temp_storage,x
  1927 8B3F D0 03			bne l2
  1928 8B41 CA				dex		; skip leading zeros
  1929 8B42 D0 F8			bne l1
  1930
  1931 8B44 BD 4E 02		l2	lda temp_storage,x
  1932 8B47 09 30			ora #$30
  1933 8B49 A8				tay
  1934
  1935 8B4A 20 5C 8B			jsr pout
  1936 8B4D E6 EB			inc cnt
  1937
  1938 8B4F CA				dex
  1939 8B50 10 F2			bpl l2
  1940
  1941 8B52 A9 00 8D 68 02		mva #0 Pout_Flag
  1942
  1943 8B57 A5 EB			lda cnt	
  1944
  1945 8B59 A6 ED			ldx ctmp3
  1946 8B5B 60				rts
  1947
  1948 				; jmp instruction either replaceed by bit, rts, or jmp
  1949 				; replace with bit flag???
  1950 8B5C			pout
  1951 8B5C 2C 68 02			BIT pout_flag
  1952 8B5F 30 05			BMI No_POUT 
  1953 8B61 70 0D			BVS Exit_POUT
  1954 8B63 4C D8 8A		  JMP @print
  1955 8B66			No_POUT
  1956 				;;; pout	   
  1957 				;	sty @buf+1
  1958 				;pbuf	equ *-2
  1959 				;	inc pbuf
  1960
  1961 8B66 48				PHA
  1962 8B67 98				TYA
  1963 8B68 A4 EE			LDY cndx0
  1964 8B6A 99 00 04			STA @buf,Y
  1965 8B6D 68			  PLA
  1966 8B6E E6 EE		  INC cndx0
  1967 8B70			Exit_POUT
  1968 8B70 60				RTS
  1969
  1970 				;;; tmp	.byte 0,0,0,0,0,0,0,0,0,0
  1971
  1972 				.endp
  1973
  1974
  1975 				; divides a 32 bit value by 10
  1976 				; remainder is returned in akku
  1977
  1978 8B71			.proc	div10
  1979 8B71 A0 20		        ldy #32		; 32 bits
  1980 8B73 A9 00		        lda #0
  1981 8B75 18			        clc
  1982 8B76 2A			l4      rol @
  1983 8B77 C9 0A		        cmp #10
  1984 8B79 90 02		        bcc skip
  1985 8B7B E9 0A		        sbc #10
  1986 8B7D 26 C6		skip    rol dx
  1987 8B7F 26 C7		        rol dx+1
  1988 8B81 26 C8		        rol dx+2
  1989 8B83 26 C9		        rol dx+3
  1990 8B85 88			        dey
  1991 8B86 10 EE		        bpl l4
  1992
  1993 8B88 60				rts
  1994 				.endp
  1995
  1996
  1997 8B89			.proc	@hexStr
  1998
  1999 = 00C6			Value	= edx
  2000 = 00CA			Digits	= ecx
  2001
  2002 					ldx Digits
  2003 					cpx #32
  2004 					scc
  2005 					ldx #32
  2006
  2007 					stx Digits
  2008
  2009 					lda Value
  2010 					jsr hex
  2011 					lda Value+1
  2012 					jsr hex
  2013 					lda Value+2
  2014 					jsr hex
  2015 					lda Value+3
  2016 					jsr hex
  2017
  2018 					lda Digits
  2019 					sta @buf
  2020 					rts
  2021
  2022 8B89			hex	pha
  2023 					and #$f
  2024 					jsr put
  2025 					pla
  2026 8B89				:4 lsr @
  2027 8B89			put	tay
  2028 					lda thex,y
  2029 					sta @buf,x
  2030 					dex
  2031 					rts
  2032
  2033 8B89			thex	dta c'0123456789ABCDEF'
  2034 				.endp
  2035
  2036
  2037 8B89			.proc	@ValueToStr (.word ya) .reg
  2038 				  
  2039 8B89 85 F0			sta cndx2 ;adr
  2040 8B8B 84 F1			sty cndx3 ;adr+1
  2041
  2042 8B8D A9 80 8D 68 02		mva #128 Pout_Flag
  2043 					;;;mva <@buf+1 @printVALUE.pbuf
  2044 8B92 A9 01 85 EE			mva <@buf+1 cndx0
  2045
  2046 8B96 20 76 8C			JSR Call_Subroutine
  2047 				;adr	equ *-2
  2048
  2049 					;ldy @printVALUE.pbuf
  2050 8B99 A4 EE			ldy cndx0
  2051 8B9B 88				dey
  2052 8B9C 8C 00 04			sty @buf
  2053
  2054 8B9F 60				rts
  2055 				.endp
  2056
  2057
  2058 				;	ecx	isSign
  2059 				;	edx	Result
  2060
  2061 8BA0			.proc	@StrToInt (.word ya) .reg
  2062 				  len	= ctmp0        
  2063 					sta bp2
  2064 					sty bp2+1
  2065
  2066 					ldy #0
  2067 					sty MAIN.SYSTEM.IOResult
  2068 					sty edx
  2069 					sty edx+1
  2070 					sty edx+2
  2071 					sty edx+3
  2072
  2073 					lda (bp2),y
  2074 					beq stop
  2075 					sta len
  2076
  2077 					inw bp2
  2078
  2079 					lda (bp2),y
  2080 					cmp #'-'
  2081 					sne
  2082 					iny
  2083
  2084 					sty ecx
  2085
  2086 8BA0			l1	lda (bp2),y
  2087
  2088 					CLC
  2089 					ADC #$FF-'9'	; make m = $FF
  2090 					ADC #'9'-'0'+1	; carry set if in range n to m
  2091 					bcs ok
  2092
  2093 					lda #106	; Invalid numeric format
  2094 					sta MAIN.SYSTEM.IOResult
  2095
  2096 					rts		; reg Y contains the index of the character in S which prevented the conversion
  2097
  2098 8BA0			ok	jsr fmul10
  2099
  2100 					lda (bp2),y
  2101 					sub #$30
  2102 					sta ztmp
  2103
  2104 					lda #$00
  2105 					sta ztmp+1
  2106 					sta ztmp+2
  2107 					sta ztmp+3
  2108
  2109 					jsr fmul10.add32bit
  2110
  2111 					iny
  2112 					cpy len	
  2113 					bne l1
  2114
  2115 					lda ecx
  2116 					beq stop
  2117
  2118 					jsr negEDX
  2119
  2120 8BA0			stop	ldy #0		; reg Y = 0 conversion successful
  2121 					rts
  2122 				.endp
  2123
  2124
  2125 8BA0			.proc	negEDX
  2126 					lda #$00	; minus
  2127 					sub edx
  2128 					sta edx
  2129
  2130 					lda #$00
  2131 					sbc edx+1
  2132 					sta edx+1
  2133
  2134 					lda #$00
  2135 					sbc edx+2
  2136 					sta edx+2
  2137
  2138 					lda #$00
  2139 					sbc edx+3
  2140 					sta edx+3
  2141
  2142 					rts
  2143 				.endp
  2144
  2145
  2146 8BA0			.proc	fmul10
  2147 					asl edx		;multiply by 2
  2148 					rol edx+1	;temp store in ZTMP
  2149 					rol edx+2
  2150 					rol edx+3
  2151
  2152 					lda edx
  2153 					sta ztmp
  2154 					lda edx+1
  2155 					sta ztmp+1
  2156 					lda edx+2
  2157 					sta ztmp+2
  2158 					lda edx+3
  2159 					sta ztmp+3
  2160
  2161 					asl edx
  2162 					rol edx+1
  2163 					rol edx+2
  2164 					rol edx+3
  2165
  2166 					asl edx
  2167 					rol edx+1
  2168 					rol edx+2
  2169 					rol edx+3
  2170
  2171 8BA0			add32bit
  2172 					lda edx
  2173 					add ztmp
  2174 					sta edx
  2175 					lda edx+1
  2176 					adc ztmp+1
  2177 					sta edx+1
  2178 					lda edx+2
  2179 					adc ztmp+2
  2180 					sta edx+2
  2181 					lda edx+3
  2182 					adc ztmp+3
  2183 					sta edx+3
  2184
  2185 					rts
  2186 				.endp
  2187
  2188
  2189 8BA0			.proc	@trunc
  2190
  2191 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2192 					spl
  2193 					jsr negCARD
  2194
  2195 					mva :STACKORIGIN+STACKWIDTH,x :STACKORIGIN,x
  2196 					mva :STACKORIGIN+STACKWIDTH*2,x :STACKORIGIN+STACKWIDTH,x
  2197 					mva :STACKORIGIN+STACKWIDTH*3,x :STACKORIGIN+STACKWIDTH*2,x
  2198 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2199
  2200 					tya
  2201 					spl
  2202 					jsr negCARD
  2203
  2204 					rts
  2205 				.endp
  2206
  2207
  2208 8BA0			.proc	@round
  2209
  2210 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2211 					spl
  2212 					jsr negCARD
  2213
  2214 					lda :STACKORIGIN,x
  2215 				//	add #$80
  2216 					cmp #$80
  2217 					lda :STACKORIGIN+STACKWIDTH,x
  2218 					adc #0
  2219 					sta :STACKORIGIN,x
  2220 					lda :STACKORIGIN+STACKWIDTH*2,x
  2221 					adc #0
  2222 					sta :STACKORIGIN+STACKWIDTH,x
  2223 					lda :STACKORIGIN+STACKWIDTH*3,x
  2224 					adc #0
  2225 					sta :STACKORIGIN+STACKWIDTH*2,x
  2226
  2227 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2228
  2229 					tya
  2230 					spl
  2231 					jsr negCARD
  2232
  2233 					rts
  2234 				.endp
  2235
  2236
  2237 8BA0			.proc	@frac
  2238
  2239 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2240 					spl
  2241 					jsr negCARD
  2242
  2243 					lda #$00
  2244 					sta :STACKORIGIN+STACKWIDTH,x
  2245 					sta :STACKORIGIN+STACKWIDTH*2,x
  2246 					sta :STACKORIGIN+STACKWIDTH*3,x
  2247
  2248 					tya
  2249 					spl
  2250 					jsr negCARD
  2251
  2252 					rts
  2253 				.endp
  2254
  2255
  2256 8BA0			.proc	@int
  2257
  2258 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2259 					spl
  2260 					jsr negCARD
  2261
  2262 					lda #$00
  2263 					sta :STACKORIGIN,x
  2264
  2265 					tya
  2266 					spl
  2267 					jsr negCARD
  2268
  2269 					rts
  2270 				.endp
  2271
  2272
  2273 				;----------------------------;
  2274 				; Biblioteka procedur        ;
  2275 				; graficznych                ;
  2276 				;----------------------------;
  2277 				; Autorzy:                   ;
  2278 				;  Slawomir 'SERO' Ritter,   ;
  2279 				;  Jakub Cebula,             ;
  2280 				;  Winfried Hofacker         ;
  2281 				;----------------------------;
  2282 				; Wersja:1.1 DATA:09.01.2008 ;
  2283 				;----------------------------;
  2284
  2285 = 0003			@open	= $03		; Otworz kanal
  2286 = 000C			@close	= $0c		; Zamknij kanal
  2287
  2288 = 0007			@IDget	= $07		; Narysuj punkt
  2289 = 0009			@IDput	= $09		; Narysuj punkt
  2290 = 0011			@IDdraw	= $11		; Narysuj linie
  2291 = 0012			@IDfill	= $12		; Wypelnij obszar
  2292
  2293
  2294 				;------------------------;
  2295 				;Wy:.Y-numer bledu (1-OK);
  2296 				;   f(N)=1-wystapil blad ;
  2297 				;------------------------;
  2298 8BA0			.proc	@COMMAND
  2299 8BA0			scrchn	equ ctmp0
  2300 8BA0			colscr	equ ctmp1
  2301
  2302
  2303
  2304 					ldx	scrchn
  2305 				;;scrchn	equ *-1
  2306
  2307 					sta	iocom,x
  2308
  2309 					lda	colscr
  2310 				;; colscr	equ *-1
  2311 					sta	atachr
  2312
  2313 					jmp	ciov
  2314 				.endp
  2315
  2316 				;------------------------;
  2317 				; Ustaw tryb ekranu      ;
  2318 				;------------------------;
  2319 				;We:.X-numer kanalu      ;
  2320 				;      (normalnie 0)     ;
  2321 				;   .Y-numer trybu (O.S.);
  2322 				;   .A-Ustawiony bit nr :;
  2323 				;     5-Nie kasowanie    ;
  2324 				;       pamieci ekranu   ;
  2325 				;     4-Obecnosc okna    ;
  2326 				;       tekstowego       ;
  2327 				;     2-Odczyt z ekranu  ;
  2328 				;------------------------;
  2329 				;Wy:SCRCHN-numer kanalu  ;
  2330 				;  .Y-numer bledu (1-OK) ;
  2331 				;   f(N)=1 wystapil blad ;
  2332 				;------------------------;
  2333 8BA0			@GRAPHICS .proc (.byte x,y,a) .reg
  2334
  2335 					sta	byte1
  2336 					sty	byte2
  2337
  2338 					stx	@COMMAND.scrchn
  2339
  2340 					lda	#@close
  2341 					jsr	xcio
  2342
  2343 					lda	#0		; =opcje
  2344 8BA0			byte1	equ	*-1
  2345 					ora	#8		; +zapis na ekranie
  2346 					sta	ioaux1,x
  2347
  2348 					lda	#0
  2349 8BA0			byte2	equ	*-1
  2350 					sta	ioaux2,x	;=nr.trybu
  2351
  2352 					mwa	#sname	ioadr,x
  2353
  2354 					lda	#@open
  2355
  2356 8BA0			xcio	sta iocom,x
  2357 					jmp ciov
  2358
  2359 8BA0			sname	dta c'S:',$9b
  2360
  2361 					.endp
  2362
  2363
  2364 8BA0			.proc	@ata2int
  2365 				        asl
  2366 				        php
  2367 				        cmp #2*$60
  2368 				        bcs @+
  2369 				        sbc #2*$20-1
  2370 				        bcs @+
  2371 				        adc #2*$60
  2372 8BA0			@       plp
  2373 				        ror
  2374 					rts
  2375 				.endp
  2376
  2377
  2378 				/*
  2379 				  PUT CHAR
  2380
  2381 				  Procedura wyprowadza znak na ekran na pozycji X/Y kursora okreslonej przez zmienne odpowiednio
  2382 				  COLCRS ($55-$56) i ROWCRS ($54). Zaklada sie, ze obowiazuja przy tym domyslne ustawienia OS-u,
  2383 				  to jest ekran jest w trybie Graphics 0, a kanal IOCB 0 jest otwarty dla edytora ekranowego.
  2384
  2385 				  Wyprowadzenie znaku polega na zaladowaniu jego kodu ATASCII do akumulatora i wykonaniu rozkazu
  2386 				  JSR PUTCHR.
  2387 				*/
  2387
  2388
  2389 8BA0			.proc	@putchar (.byte a) .reg
  2390
  2391 8BA0 2C A0 8B		vbxe	bit *
  2392
  2393 8BA3 A2 00			ldx #$00
  2394 					.ifdef MAIN.CRT.TextAttr
  2395 					ora MAIN.CRT.TextAttr
  2396 					.endif
  2397 8BA5 A8				tay
  2398 8BA6 BD 47 03			lda icputb+1,x
  2399 8BA9 48				pha
  2400 8BAA BD 46 03			lda icputb,x
  2401 8BAD 48				pha
  2402 8BAE 98				tya
  2403
  2404 8BAF 60				rts
  2405
  2406 				.endp
  2407
  2408
  2409 				/*
  2410 				  GETLINE
  2411
  2412 				  Program czeka, az uzytkownik wpisze ciag znak�w z klawiatury i nacisnie klawisz RETURN.
  2413 				  Znaki podczas wpisywania sa wyswietlane na ekranie, dzialaja tez normalne znaki kontrolne
  2414 				  (odczyt jest robiony z edytora ekranowego).
  2415
  2416 				  Wywolanie funkcji polega na zaladowaniu adresu, pod jaki maja byc wpisane znaki,
  2417 				  do rejestr�w A/Y (mlodszy/starszy) i wykonaniu rozkazu JSR GETLINE.
  2418
  2419 				*/
  2419
  2420
  2421 8BB0			.proc	@GetLine
  2422
  2423 					stx ctmp3
  2424
  2425 					ldx #0
  2426
  2427 					stx MAIN.SYSTEM.EoLn
  2428
  2429 					mwa	#@buf+1	icbufa,x
  2430
  2431 					mwa	#$ff	icbufl,x	; maks. wielkosc tekstu
  2432
  2433 					mva	#$05	iccmd,x
  2434
  2435 					jsr	ciov
  2436
  2437 					dew icbufl
  2438 					mva icbufl @buf			; length
  2439
  2440 					ldx @buf+1
  2441 					cpx #EOL
  2442 					bne skp
  2443
  2444 					ldx #TRUE
  2445 					stx MAIN.SYSTEM.EoLn
  2446 8BB0			skp
  2447 					ldx ctmp3
  2448 					rts
  2449 				.endp
  2450
  2451
  2452 8BB0			.proc	@GetKey
  2453
  2454 8BB0			getk	lda kbcodes	; odczytaj kbcodes
  2455 					cmp #255		; czy jest znak?
  2456 					beq getk	; nie: czekaj
  2457 					ldy #255		; daj zna�, �e klawisz
  2458 					sty kbcodes	; zosta� odebrany
  2459 					tay		; kod klawisza jako indeks
  2460 					lda (keydef),y	; do tablicy w ROM-ie
  2461
  2462 					rts
  2463 				.endp
  2464
  2465
  2466 8BB0			.proc	@moveSTRING (.word ya) .reg
  2467
  2468 					sta @move.dst
  2469 					sty @move.dst+1
  2470
  2471 					mva :STACKORIGIN,x @move.src
  2472 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2473
  2474 					ldy #$00
  2475 					lda (@move.src),y
  2476 					add #1
  2477 					sta @move.cnt
  2478 					scc
  2479 					iny
  2480 					sty @move.cnt+1
  2481
  2482 					jmp @move
  2483 				.endp
  2484
  2485
  2486 8BB0			.proc	@moveSTRING_1 (.word ya) .reg
  2487
  2488 					sta @move.dst
  2489 					sty @move.dst+1
  2490
  2491 					mva :STACKORIGIN,x @move.src
  2492 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2493
  2494 					ldy #$00
  2495 					lda (@move.src),y
  2496 				;	add #1
  2497 					sta @move.cnt
  2498 					sty @move.cnt+1
  2499
  2500 					inw @move.src
  2501
  2502 					jmp @move
  2503 				.endp
  2504
  2505
  2506 				; Ullrich von Bassewitz, 2003-08-20
  2507 				; Performance increase (about 20%) by
  2508 				; Christian Krueger, 2009-09-13
  2509
  2510 8BB0			.proc	@moveu		; assert Y = 0
  2511
  2512 = 00C6			ptr1	= edx
  2513 = 00CA			ptr2	= ecx
  2514 = 00C2			ptr3	= eax
  2515
  2516 8BB0 86 ED			stx ctmp3
  2517
  2518 8BB2 A0 00			ldy	#0
  2519
  2520 8BB4 A6 C3			ldx     ptr3+1		; Get high byte of n
  2521 8BB6 F0 13			beq     L2		; Jump if zero
  2522
  2523 				L1:     .rept 2		; Unroll this a bit to make it faster...
  2524 					LDA     (PTR1),Y	
  2525 					STA     (PTR2),Y
  2526 					INY
  2527 					.ENDR
  2527 					.endr
Source: REPT
  2524 8BB8 B1 C6			LDA     (PTR1),Y	
  2524 8BBA 91 CA			STA     (PTR2),Y
  2524 8BBC C8				INY
  2524 8BBD B1 C6			LDA     (PTR1),Y	
  2524 8BBF 91 CA			STA     (PTR2),Y
  2524 8BC1 C8				INY
Source: cpu6502.asm
  2528
  2529 8BC2 D0 F4			bne     L1
  2530 8BC4 E6 C7			inc     ptr1+1
  2531 8BC6 E6 CB			inc     ptr2+1
  2532 8BC8 CA				dex			; Next 256 byte block
  2533 8BC9 D0 ED			bne	L1		; Repeat if any
  2534
  2535 					; the following section could be 10% faster if we were able to copy
  2536 					; back to front - unfortunately we are forced to copy strict from
  2537 					; low to high since this function is also used for
  2538 					; memmove and blocks could be overlapping!
  2539 					; {
  2540 8BCB			L2:				; assert Y = 0
  2541 8BCB A6 C2			ldx     ptr3		; Get the low byte of n
  2542 8BCD F0 08			beq     done		; something to copy
  2543
  2544 8BCF B1 C6		L3:     lda     (ptr1),Y	; copy a byte
  2545 8BD1 91 CA			sta     (ptr2),Y
  2546 8BD3 C8				iny
  2547 8BD4 CA				dex
  2548 8BD5 D0 F8			bne     L3
  2549
  2550 					; }
  2551
  2552 8BD7 A6 ED		done	ldx ctmp3
  2553
  2554 8BD9 60				rts
  2555 				.endp
  2556
  2557
  2558 8BDA			@move	.proc (.word ptr1, ptr2, ptr3) .var
  2559
  2560 = 00C6			ptr1	= edx
  2561 = 00CA			ptr2	= ecx
  2562 = 00C2			ptr3	= eax
  2563
  2564 = 00C6			src	= ptr1
  2565 = 00CA			dst	= ptr2
  2566 = 00C2			cnt	= ptr3
  2567
  2568 8BDA A5 CB C5 C7 D0 04 + 	cpw ptr2 ptr1
  2569 8BE4 B0 03			scs
  2570 8BE6 4C B0 8B			jmp @moveu
  2571
  2572 8BE9 86 ED			stx ctmp3
  2573
  2574 				; Copy downwards. Adjust the pointers to the end of the memory regions.
  2575
  2576 8BEB A5 C7			lda     ptr1+1
  2577 8BED 18 65 C3			add     ptr3+1
  2578 8BF0 85 C7			sta     ptr1+1
  2579
  2580 8BF2 A5 CB			lda     ptr2+1
  2581 8BF4 18 65 C3			add     ptr3+1
  2582 8BF7 85 CB			sta     ptr2+1
  2583
  2584 				; handle fractions of a page size first
  2585
  2586 8BF9 A4 C2			ldy     ptr3		; count, low byte
  2587 8BFB D0 06			bne     @entry		; something to copy?
  2588 8BFD F0 0B			beq     PageSizeCopy	; here like bra...
  2589
  2590 8BFF			@copyByte:
  2591 8BFF B1 C6			lda     (ptr1),y
  2592 8C01 91 CA			sta     (ptr2),y
  2593 8C03			@entry:
  2594 8C03 88				dey
  2595 8C04 D0 F9			bne     @copyByte
  2596 8C06 B1 C6			lda     (ptr1),y	; copy remaining byte
  2597 8C08 91 CA			sta     (ptr2),y
  2598
  2599 8C0A			PageSizeCopy:			; assert Y = 0
  2600 8C0A A6 C3			ldx     ptr3+1		; number of pages
  2601 8C0C F0 1D			beq     done		; none? -> done
  2602
  2603 8C0E			@initBase:
  2604 8C0E C6 C7			dec     ptr1+1		; adjust base...
  2605 8C10 C6 CB			dec     ptr2+1
  2606 8C12 88				dey			; in entry case: 0 -> FF
  2607 8C13 B1 C6			lda     (ptr1),y	; need to copy this 'intro byte'
  2608 8C15 91 CA			sta     (ptr2),y	; to 'land' later on Y=0! (as a result of the '.repeat'-block!)
  2609 8C17 88				dey			; FF ->FE
  2610 8C18			@copyBytes:
  2611 					.rept 2		; Unroll this a bit to make it faster...
  2612 					LDA     (PTR1),Y
  2613 					STA     (PTR2),Y
  2614 					DEY
  2615 					.ENDR
  2615 					.endr
Source: REPT
  2612 8C18 B1 C6			LDA     (PTR1),Y
  2612 8C1A 91 CA			STA     (PTR2),Y
  2612 8C1C 88				DEY
  2612 8C1D B1 C6			LDA     (PTR1),Y
  2612 8C1F 91 CA			STA     (PTR2),Y
  2612 8C21 88				DEY
Source: cpu6502.asm
  2616 8C22			@copyEntry:			; in entry case: 0 -> FF
  2617 8C22 D0 F4			bne     @copyBytes
  2618 8C24 B1 C6			lda     (ptr1),y	; Y = 0, copy last byte
  2619 8C26 91 CA			sta     (ptr2),y
  2620 8C28 CA				dex			; one page to copy less
  2621 8C29 D0 E3			bne     @initBase	; still a page to copy?
  2622
  2623 8C2B A6 ED		done	ldx ctmp3
  2624
  2625 8C2D 60				rts
  2626 				.endp
  2627
  2628
  2629 				; Ullrich von Bassewitz, 29.05.1998
  2630 				; Performance increase (about 20%) by
  2631 				; Christian Krueger, 12.09.2009, slightly improved 12.01.2011
  2632
  2633 8C2E			.proc	@fill (.word ptr1, ptr3 .byte ptr2) .var
  2634
  2635 = 00C6			ptr1 = edx
  2636 = 00CA			ptr3 = ecx
  2637 = 00C2			ptr2 = eax
  2638
  2639 8C2E 86 ED			stx ctmp3
  2640
  2641 8C30 A6 C2			ldx ptr2
  2642
  2643 8C32 A0 00			ldy #0
  2644
  2645 8C34 46 CB		        lsr	ptr3+1          ; divide number of
  2646 8C36 66 CA		        ror	ptr3            ; bytes by two to increase
  2647 8C38 90 09		        bcc	evenCount       ; speed (ptr3 = ptr3/2)
  2648 8C3A			oddCount:
  2649 								; y is still 0 here
  2650 8C3A 8A			        txa			; restore fill value
  2651 8C3B 91 C6		        sta	(ptr1),y	; save value and increase
  2652 8C3D E6 C6		        inc	ptr1		; dest. pointer
  2653 8C3F D0 02		        bne	evenCount
  2654 8C41 E6 C7		        inc	ptr1+1
  2655 8C43			evenCount:
  2656 8C43 A5 C6			lda	ptr1		; build second pointer section
  2657 8C45 18				clc
  2658 8C46 65 CA			adc	ptr3		; ptr2 = ptr1 + (length/2) <- ptr3
  2659 8C48 85 C2			sta     ptr2
  2660 8C4A A5 C7			lda     ptr1+1
  2661 8C4C 65 CB			adc     ptr3+1
  2662 8C4E 85 C3			sta     ptr2+1
  2663
  2664 8C50 8A			        txa			; restore fill value
  2665 8C51 A6 CB		        ldx	ptr3+1		; Get high byte of n
  2666 8C53 F0 13		        beq	L2		; Jump if zero
  2667
  2668 				; Set 256/512 byte blocks
  2669 								; y is still 0 here
  2670 				L1:	.rept 2		; Unroll this a bit to make it faster
  2671 					STA	(PTR1),Y	
  2672 					STA	(PTR2),Y	
  2673 					INY
  2674 					.ENDR
  2674 					.endr
Source: REPT
  2671 8C55 91 C6			STA	(PTR1),Y	
  2671 8C57 91 C2			STA	(PTR2),Y	
  2671 8C59 C8				INY
  2671 8C5A 91 C6			STA	(PTR1),Y	
  2671 8C5C 91 C2			STA	(PTR2),Y	
  2671 8C5E C8				INY
Source: cpu6502.asm
  2675 8C5F D0 F4		        bne	L1
  2676 8C61 E6 C7		        inc	ptr1+1
  2677 8C63 E6 C3		        inc	ptr2+1
  2678 8C65 CA			        dex                     ; Next 256 byte block
  2679 8C66 D0 ED		        bne	L1              ; Repeat if any
  2680
  2681 				; Set the remaining bytes if any
  2682
  2683 8C68 A4 CA		L2:	ldy	ptr3            ; Get the low byte of n
  2684 8C6A F0 07			beq	leave           ; something to set? No -> leave
  2685
  2686 8C6C 88			L3:	dey
  2687 8C6D 91 C6			sta	(ptr1),y	; set bytes in low
  2688 8C6F 91 C2			sta	(ptr2),y	; and high section
  2689 8C71 D0 F9			bne     L3		; flags still up to date from dey!
  2690
  2691 8C73 A6 ED		leave	ldx ctmp3
  2692
  2693 8C75 60				rts			; return
  2694 				.endp
  2695
  2696
  2697 				/*
  2698 				 add strings
  2699 				 result -> @buf
  2700 				*/
  2700
  2701 8C76			.proc	@addString(.word ya) .reg
  2702
  2703 					sta ztmp
  2704 					sty ztmp+1
  2705
  2706 					stx ctmp3
  2707
  2708 					ldx @buf
  2709 					inx
  2710 					beq stop
  2711
  2712 					ldy #0
  2713 					lda (ztmp),y
  2714 					sta ile
  2715 					beq stop
  2716
  2717 					iny
  2718
  2719 8C76			load	lda (ztmp),y
  2720 					sta @buf,x
  2721
  2722 					iny
  2723 					inx
  2724 					beq stop
  2725 					dec ile
  2726 					bne load
  2727
  2728 8C76			stop	dex
  2729 					stx @buf
  2730
  2731 					ldx ctmp3
  2732
  2733 					rts
  2734
  2735 8C76			ile	brk
  2736 				.endp
  2737
  2738
  2739 				/* ----------------------------------------------------------------------- */
  2740
  2741
  2742 8C76			.proc	@AllocMem(.word ztmp .word ztmp+2) .var
  2743
  2744 					jsr swap
  2745
  2746 					adw spoint ztmp+2
  2747
  2748 					rts
  2749
  2750 8C76			swap	txa:pha
  2751
  2752 					mwa spoint bp2
  2753
  2754 					ldx #0
  2755 					ldy #0
  2756
  2757 8C76			loop	cpy ztmp+2
  2758 					bne @+
  2759 					cpx ztmp+3
  2760 					beq stop
  2761
  2762 8C76			@	lda (bp2),y
  2763 					pha
  2764
  2765 					lda (ztmp),y
  2766 					sta (bp2),y
  2767
  2768 					pla
  2769 					sta (ztmp),y
  2770
  2771 					iny
  2772 					bne loop
  2773
  2774 					inc ztmp+1
  2775 					inc bp2+1
  2776 					inx
  2777
  2778 					jmp loop
  2779
  2780 8C76			stop	pla:tax
  2781
  2782 					rts
  2783
  2784 8C76			spoint	dta a(PROGRAMSTACK)
  2785 				.endp
  2786
  2787
  2788 8C76			.proc	@FreeMem(.word ztmp .word ztmp+2) .var
  2789
  2790 					sbw @AllocMem.spoint ztmp+2
  2791
  2792 					jmp @AllocMem.swap
  2793 				.endp
  2794
  2795
  2796 				/* ----------------------------------------------------------------------- */
  2797
  2798
  2799 8C76			.proc	@vbxe_detect
  2800
  2801 					ldy #.sizeof(detect)-1
  2802 					mva:rpl copy,y detect,y-
  2803
  2804 					jmp detect
  2805
  2806 8C76			copy
  2807 0400				.local	detect,@buf
  2808 				;
  2809 				; 2009 by KMK/DLT
  2810 				;
  2811 					lda #0
  2812 					sta fxptr
  2813
  2814 				        lda #$d6
  2815 				        sta fxptr+1
  2816 				        ldy #FX_MEMB
  2817 				        jsr ?clr
  2818
  2819 				        jsr ?try
  2820 				        bcc ok
  2821
  2822 				        inc fxptr+1
  2823
  2824 					jsr ?try
  2825 					bcc ok
  2826
  2827 					lda #0
  2828 					sta fxptr+1
  2829 					rts
  2830
  2831 0400			?try    ldx $4000
  2832 				        jsr ?chk
  2833 				        bcc ?ret
  2834 				        inx
  2835 				        stx $4000
  2836 				        jsr ?chk
  2837 				        dec $4000
  2838 0400			?ret    rts
  2839
  2840 0400			ok	ldy	#VBXE_MINOR		; get core minor version
  2841 					lda	(fxptr),y
  2842 					rts
  2843
  2844 0400			?chk    lda #$80
  2845 				        jsr _vbxe_write
  2846 				        cpx $4000
  2847 				        bne ?fnd
  2848 				        sec
  2849 0400			        .byte $24
  2850 0400			?fnd    clc
  2851 0400			?clr    lda #$00
  2852 0400			_vbxe_write
  2853 				        sta (fxptr),y
  2854 				        rts
  2855
  2856 				/*
  2857 					lda	#0
  2858 					ldx	#0xd6
  2859 					sta	0xd640			; make sure it isn't coincidence
  2860 					lda	0xd640
  2861 					cmp	#0x10			; do we have major version here?
  2862 					beq	VBXE_Detected		; if so, then VBXE is detected
  2863 					lda	#0
  2864 					inx
  2865 					sta	0xd740			; no such luck, try other location
  2866 					lda	0xd740
  2867 					cmp	#0x10
  2868 					beq	VBXE_Detected
  2869 					ldx 	#0  			; not here, so not present or FX core version too low
  2870 					stx	fxptr+1
  2871 					stx	fxptr
  2872
  2873 					sec
  2874 					rts
  2875
  2876 				VBXE_Detected
  2877 					stx	fxptr+1
  2878 					lda	#0
  2879 					sta	fxptr
  2880
  2881 					ldy	#VBXE_MINOR		; get core minor version
  2882 					lda	(fxptr),y
  2883
  2884 					clc
  2885 					rts	 			; x - page of vbxe
  2886 				*/
  2886
  2887
  2888 					.endl
  2889
  2890 				.endp
  2891
  2892
  2893 8C76			.proc	@setxdl(.byte a) .reg
  2894 					idx = ctmp0
  2895 					asl @
  2896 					sta idx
  2897
  2898 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000
  2899
  2900 					ldy idx
  2901
  2902 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2903 					and msk,y
  2904 					ora val,y
  2905 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2906
  2907 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2908 					and msk+1,y
  2909 					ora val+1,y
  2910 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2911
  2912 					fxs FX_MEMS #0
  2913 					rts
  2914
  2915 8C76			msk	.array [6] .word
  2916 					[e@xdl.mapon]  = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2917 					[e@xdl.mapoff] = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2918 					[e@xdl.ovron]  = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2919 					[e@xdl.ovroff] = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2920 					[e@xdl.hr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2921 					[e@xdl.lr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2922 					.enda
  2923
  2924 8C76			val	.array [6] .word
  2925 					[e@xdl.mapon]  = XDLC_MAPON
  2926 					[e@xdl.mapoff] = XDLC_MAPOFF
  2927 					[e@xdl.ovron]  = XDLC_GMON
  2928 					[e@xdl.ovroff] = XDLC_OVOFF
  2929 					[e@xdl.hr]     = XDLC_GMON|XDLC_HR
  2930 					[e@xdl.lr]     = XDLC_GMON|XDLC_LR
  2931 					.enda
  2932
  2933 				.endp
  2934
  2935
  2936 8C76			.proc	@vbxe_init
  2937
  2938 					fxs FX_MEMC #%1000+>MAIN.SYSTEM.VBXE_WINDOW	; $b000..$bfff (4K window), cpu on, antic off
  2939 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000	; enable VBXE BANK #0
  2940
  2941 					ldx #.sizeof(s@xdl)-1
  2942 					mva:rpl xdlist,x MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW,x-
  2943
  2944 					jsr cmapini		; init color map
  2945
  2946 					fxsa FX_P1		; A = 0
  2947 					fxsa FX_P2
  2948 					fxsa FX_P3
  2949
  2950 					fxsa FX_IRQ_CONTROL
  2951 					fxsa FX_BLITTER_START
  2952
  2953 					fxsa FX_XDL_ADR0	; XDLIST PROGRAM ADDRES (VBXE_XDLADR = $0000) = bank #0
  2954 					fxsa FX_XDL_ADR1
  2955 					fxsa FX_XDL_ADR2
  2956
  2957 					sta colpf0s
  2958
  2959 					fxs FX_P0 #$ff
  2960
  2961 					mwa #@vbxe_cmap @putchar.vbxe+1
  2962 					mva #{jsr*} @putchar.vbxe
  2963
  2964 					fxs FX_VIDEO_CONTROL #VC_XDL_ENABLED|VC_XCOLOR	;|VC_NO_TRANS
  2965
  2966 					rts
  2967
  2968 8C76			cmapini	lda colpf1s
  2969 					and #$0f
  2970 					sta colpf1s
  2971
  2972 					lda #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2973 					sta ztmp
  2974
  2975 					mva #4 ztmp+1
  2976
  2977 8C76			loop	fxs FX_MEMS ztmp
  2978
  2979 					lda >MAIN.SYSTEM.VBXE_WINDOW
  2980 					sta bp+1
  2981
  2982 					ldx #16
  2983 					ldy #0
  2984
  2985 8C76			lop	mva #$00	(bp),y+
  2986 					mva colpf1s	(bp),y+
  2987 					mva colpf2s	(bp),y+
  2988 					mva #%00010000	(bp),y+		; overlay palette #1
  2989 					bne lop
  2990
  2991 					inc bp+1
  2992 					dex
  2993 					bne lop
  2994
  2995 					inc ztmp
  2996
  2997 					dec ztmp+1
  2998 					bne loop
  2999
  3000 					fxs FX_MEMS #$00		; disable VBXE BANK
  3001 					rts
  3002
  3003 				xdlist	dta s@xdl [0] (XDLC_RPTL, 24-1,\
  3004 					XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,\	;|XDLC_GMON,\
  3005 					192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,\
  3006 					MAIN.SYSTEM.VBXE_MAPADR, $100,\
  3007 					0, 0, 7, 7, %00010001, $ff)
  3007 8C76			XDLIST	DTA S@XDL [0] (XDLC_RPTL, 24-1,	XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,	192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,	MAIN.SYSTEM.VBXE_MAPADR, $100,	0, 0, 7, 7, %00010001, $ff)
  3008 				.endp
  3009
  3010
  3011 8C76			.proc	@vbxe_cmap
  3012
  3013 					pha
  3014
  3015 					cmp #eol
  3016 					beq stop
  3017
  3018 					cmp #$7d		; clrscr
  3019 					bne skp
  3020
  3021 					jsr @vbxe_init.cmapini
  3022 					jmp stop
  3023
  3024 8C76			skp	lda rowcrs
  3025 					pha
  3026 8C76				:4 lsr @
  3027 					add #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  3028 					fxsa FX_MEMS
  3029
  3030 					pla
  3031 					and #$0f
  3032 					add >MAIN.SYSTEM.VBXE_WINDOW
  3033 					sta bp+1
  3034
  3035 					lda colcrs
  3036 					asl @
  3037 					asl @
  3038 					tay
  3039 					mva colpf0s (bp),y
  3040 					iny
  3041 					mva colpf1s (bp),y
  3042 					iny
  3043 					mva colpf2s (bp),y
  3044
  3045 					fxs FX_MEMS #$00
  3046
  3047 8C76			stop	pla
  3048
  3049 					rts
  3050 				.endp
  3051
  3052
  3053 				/* ----------------------------------------------------------------------- */
  3054
  3055
  3056 				/*
  3057 				.proc	@cmdline (.byte a) .reg
  3058
  3059 				parno	= ctmp0
  3060 				idpar	= ctmp1
  3061 				lbuf = cndx0
  3062 				hbuf = cndx1
  3063
  3064
  3065 					stx ctmp3
  3066
  3067 					sta idpar
  3068
  3069 					lda #0
  3070 					sta parno
  3071
  3072 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3073 					lsr
  3074 					bcc _no_command_line
  3075
  3076 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3077 					cmp #$c0
  3078 					bcs _no_command_line
  3079
  3080 					ldy #$03
  3081 					lda (dosvec),y
  3082 					cmp #{jmp}
  3083 					bne _no_command_line
  3084
  3085 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3086 					lda (dosvec),y
  3087 					sta lbuf
  3088 					iny
  3089 					lda (dosvec),y
  3090 					sta hbuf
  3091
  3092 					adw dosvec #3 cndx2
  3093
  3094 				loop	lda #0
  3095 					sta @buf
  3096 					JSR Call_Subroutine
  3097 					;jsr $ffff
  3098 				;;zcr	equ *-2
  3099 					beq stop
  3100
  3101 					lda idpar
  3102 					bne skp
  3103
  3104 					ldy #33			; ParamStr(0)
  3105 				_par0	lda (dosvec),y
  3106 					sta @buf-33+1,y
  3107 					iny
  3108 					cpy #36
  3109 					bne _par0
  3110
  3111 					lda #3
  3112 					sta @buf
  3113 					bne stop
  3114
  3115 				skp	ldy #36
  3116 				_cp	lda (dosvec),y
  3117 					sta @buf-36+1,y
  3118 					iny
  3119 					cmp #$9b
  3120 					bne _cp
  3121
  3122 					tya
  3123 					sub #37
  3124 					sta @buf
  3125
  3126 					inc parno
  3127 					lda parno
  3128 				;;; parno	equ *-1
  3129 					cmp idpar
  3130 				;;; idpar	equ *-1
  3131
  3132 					bne loop
  3133
  3134 				stop	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3135 					lda lbuf
  3136 				;; lbuf	equ *-1
  3137 					sta (dosvec),y
  3138 					iny
  3139 					lda hbuf
  3140 				;; hbuf	equ *-1
  3141 					sta (dosvec),y
  3142
  3143 				_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3144
  3145 					lda parno
  3146
  3147 					ldx ctmp3
  3148
  3149 					rts
  3150 				.endp
  3151 				*/
  3151
  3152
  3153
  3154 8C76			.proc	@CmdLine (.byte a) .reg
  3155 				  arg_len = ctmp0 
  3156 					lbuf = ctmp1	
  3157 					parno	= ctmp2
  3158 					idpar	= cndx0
  3159 					hbuf = cndx1	
  3160 					
  3161 					stx ctmp3
  3162
  3163 					sta idpar
  3164
  3165 					lda #0
  3166 					sta parno
  3167 					sta loop+1
  3168
  3169 					lda	#{jsr*}
  3170 					sta	res
  3171
  3172 				; Get filename from SpartaDOS...
  3173 8C76			get_param
  3174 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3175 					lsr
  3176 					bcc no_sparta
  3177
  3178 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3179 					cmp #$c0
  3180 					bcs no_sparta
  3181
  3182 					ldy #$03
  3183 					lda (dosvec),y
  3184 					cmp #{jmp}
  3185 					bne no_sparta
  3186
  3187 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3188 					lda (dosvec),y
  3189 					sta lbuf
  3190 					iny
  3191 					lda (dosvec),y
  3192 					sta hbuf
  3193
  3194 					adw dosvec #33 tmp
  3195
  3196 					ldy #0
  3197 8C76			fnm	lda (tmp),y
  3198 					iny
  3199 					cmp #$9b
  3200 					bne fnm
  3201
  3202 					tya			; remove .COM
  3203 					sub #5
  3204 					tay
  3205 					lda #0
  3206 					sta (tmp),y
  3207 					tay
  3208
  3209 					lda	#3
  3210 					sta	loop+1
  3211 					add	dosvec
  3212 					sta	cndx2 ;get_adr
  3213 					lda	#0
  3214 					adc	dosvec+1
  3215 					sta	cndx3 ;get_adr+1
  3216
  3217 					jmp	_ok
  3218
  3219 8C76			no_sparta
  3220 					mwa #next get_adr
  3221
  3222 					lda	#{bit*}
  3223 					sta	res
  3224
  3225 				; ... or channel #0
  3226 					lda	MAIN.IOCB@COPY+2	; command
  3227 					cmp	#5			; read line
  3228 					bne	_no_command_line
  3229 					lda	MAIN.IOCB@COPY+3	; status
  3230 					bmi	_no_command_line
  3231 				; don't assume the line is EOL-terminated
  3232 				; DOS II+/D overwrites the EOL with ".COM"
  3233 				; that's why we rely on the length
  3234 					lda	MAIN.IOCB@COPY+9	; length hi
  3235 					bne	_no_command_line
  3236 					ldx	MAIN.IOCB@COPY+8	; length lo
  3237 					beq	_no_command_line
  3238 					inx:inx
  3239 					stx	arg_len
  3240 				; give access to three bytes before the input buffer
  3241 				; in DOS II+/D the device prompt ("D1:") is there
  3242 					lda	MAIN.IOCB@COPY+4
  3243 					sub	#3
  3244 					sta	tmp
  3245 					lda	MAIN.IOCB@COPY+5
  3246 					sbc	#0
  3247 					sta	tmp+1
  3248
  3249 					lda	#0
  3250 					ldy	arg_len
  3251 					sta	(tmp),y
  3252
  3253
  3254 8C76			loop	ldy	#0
  3255
  3256 8C76			_ok	ldx	#0
  3257
  3258 8C76			lprea	lda	(tmp),y
  3259 					sta	@buf+1,x
  3260
  3261 					beq	stop
  3262
  3263 					cmp	#$9b
  3264 					beq	stop
  3265 					cmp	#' '
  3266 					beq	stop
  3267
  3268 					iny
  3269 					inx
  3270 					cpx #32
  3271 					bne lprea
  3272
  3273 8C76			stop	lda parno
  3274 					cmp idpar
  3275 					beq found
  3276 					JSR Call_Subroutine
  3277 					;jsr $ffff		; sty loop+1
  3278 				;get_adr	equ *-2
  3279 					beq found
  3280
  3281 					inc parno
  3282 					bne loop
  3283
  3284 8C76			found	lda #0	;+$9b
  3285 					sta @buf+1,x
  3286 					stx @buf
  3287
  3288 8C76			res	jsr sdxres
  3289
  3290 8C76			_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3291
  3292 					lda parno
  3293
  3294 					ldx ctmp3
  3295
  3296 					rts
  3297
  3298
  3299 8C76			sdxres	
  3300 				  ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3301 					lda lbuf
  3302 					sta (dosvec),y
  3303 					iny
  3304 					lda hbuf
  3305 				;;; hbuf	equ *-1
  3306 					sta (dosvec),y
  3307 					rts
  3308
  3309
  3310 8C76			_next	iny
  3311 8C76			next	lda (tmp),y
  3312 					beq _eol
  3313 					cmp #' '
  3314 					beq _next
  3315
  3316 					cmp #$9b
  3317 					beq _eol
  3318
  3319 					sty loop+1
  3320 					rts
  3321
  3322 8C76			_eol	lda #0
  3323 					rts
  3324
  3325 				.endp
  3326
  3327
  3328 				/* ----------------------------------------------------------------------- */
  3329
  3330 				/*
  3331 				.proc	@rstsnd
  3332 					lda #0
  3333 					sta $d208
  3334 					sta $d218
  3335
  3336 					ldy #3
  3337 					sty $d20f
  3338 					sty $d21f
  3339 					rts
  3340 				.endp
  3341 				*/
  3341
  3342
  3343 				;	ert (*>$3fff) .and (*<$8000)
  3344
  3345
  3346 				/* ----------------------------------------------------------------------- */
  3347
  3348
  3349 8C76			.proc	@xmsBank
  3350
  3351 = 00C2			ptr3 = eax			; position	(4)
  3352
  3353 					mva ptr3+3 ztmp+1	; position shr 14
  3354 					mva ptr3+2 ztmp
  3355 					lda ptr3+1
  3356
  3357 					.rept 6
  3358 					LSR ZTMP+1
  3359 					ROR ZTMP
  3360 					ROR @
  3361 					.ENDR
  3361 					.endr
Source: REPT
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
  3358 					LSR ZTMP+1
  3358 					ROR ZTMP
  3358 					ROR @
Source: cpu6502.asm
  3362
  3363 					tax			; index to bank
  3364
  3365 					lda portb
  3366 					and #1
  3367 					ora main.misc.adr.banks,x
  3368 					sta portb
  3369
  3370 					lda ptr3 		; offset
  3371 					sta ztmp
  3372 					lda ptr3+1
  3373 					and #$3f
  3374 					ora #$40
  3375 					sta ztmp+1
  3376
  3377 					rts
  3378 				.endp
  3379
  3380
  3381 8C76			.proc	@xmsReadBuf (.word ptr1, ptr2) .var
  3382 					src = cndx2
  3383 					max = ctmp0
  3384 = 00C6			ptr1 = dx	; buffer	(2)
  3385
  3386 = 00CA			ptr2 = cx	; count		(2)
  3387 = 00CC			pos = cx+2	; position	(2) pointer
  3388
  3389 = 00C2			ptr3 = eax	; position	(4)
  3390
  3391 					txa:pha
  3392
  3393 					ldy #0
  3394 					lda (pos),y
  3395 					sta ptr3
  3396 					iny
  3397 					lda (pos),y
  3398 					sta ptr3+1
  3399 					iny
  3400 					lda (pos),y
  3401 					sta ptr3+2
  3402 					iny
  3403 					lda (pos),y
  3404 					sta ptr3+3
  3405
  3406 					lda ptr2+1
  3407 					beq lp2
  3408
  3409 8C76			lp1	jsr @xmsBank
  3410
  3411 					lda ztmp+1
  3412 					cmp #$7f
  3413 					bne skp
  3414 					lda ztmp
  3415 					beq skp
  3416
  3417 					lda #0
  3418 					jsr nextBank
  3419 					jmp skp2
  3420
  3421 8C76			skp	ldy #0
  3422 					mva:rne (ztmp),y @buf,y+
  3423
  3424 8C76			skp2	lda portb
  3425 					and #1
  3426 					ora #$fe
  3427 					sta portb
  3428
  3429 					ldy #0
  3430 					mva:rne @buf,y (dx),y+
  3431
  3432 					inc dx+1	// inc(dx, $100)
  3433
  3434 					inl ptr3+1	// inc(position, $100)
  3435
  3436 					dec ptr2+1
  3437 					bne lp1
  3438
  3439 8C76			lp2	jsr @xmsBank
  3440
  3441 					lda ztmp+1		; zakonczenie kopiowania
  3442 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3443 					bne skp_
  3444
  3445 					lda ztmp
  3446 					add ptr2
  3447 					bcc skp_
  3448
  3449 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3450 					jsr nextBank
  3451 					jmp skp3
  3452
  3453 8C76			skp_	ldy #0
  3454 8C76			mv	lda (ztmp),y
  3455 					sta @buf,y
  3456 					iny
  3457 					cpy ptr2
  3458 					bne mv
  3459
  3460 8C76			skp3	lda portb
  3461 					and #1
  3462 					ora #$fe
  3463 					sta portb
  3464
  3465 					ldy #0
  3466 8C76			lp3	lda @buf,y
  3467 					sta (dx),y
  3468 					iny
  3469 					cpy ptr2
  3470 					bne lp3
  3471
  3472 					jmp @xmsUpdatePosition
  3473
  3474 8C76			.local	nextBank
  3475
  3476 					sta max
  3477
  3478 					mwa ztmp src
  3479
  3480 					ldy #0
  3481 8C76			mv0	
  3482 				  lda (src),y
  3483 					sta @buf,y
  3484 					iny
  3485 					inc ztmp
  3486 					bne mv0
  3487
  3488 					lda portb
  3489 					and #1
  3490 					ora main.misc.adr.banks+1,x
  3491 					sta portb
  3492
  3493 					ldx #0
  3494 8C76			mv1	
  3495 				  cpy max
  3496 					beq stp
  3497 					lda $4000,x
  3498 					sta @buf,y
  3499 					inx
  3500 					iny
  3501 					bne mv1
  3502 8C76			stp	rts
  3503 				.endl
  3504
  3505 				.endp
  3506
  3507
  3508 8C76			.proc	@xmsWriteBuf (.word ptr1, ptr2) .var
  3509 = 00EE			dst	= cndx0
  3510 = 00EB			max	= ctmp1
  3511 				 
  3512 = 00C6			ptr1 = dx	; buffer	(2)
  3513
  3514 = 00CA			ptr2 = cx	; count		(2)
  3515 = 00CC			pos = cx+2	; position	(2) pointer
  3516
  3517 = 00C2			ptr3 = eax	; position	(4)
  3518
  3519 					txa:pha
  3520
  3521 					ldy #0			; przepisz POSITION spod wskaznika
  3522 					lda (pos),y
  3523 					sta ptr3
  3524 					iny
  3525 					lda (pos),y
  3526 					sta ptr3+1
  3527 					iny
  3528 					lda (pos),y
  3529 					sta ptr3+2
  3530 					iny
  3531 					lda (pos),y
  3532 					sta ptr3+3
  3533
  3534 8C76			lp1	lda portb		; wylacz dodatkowe banki
  3535 					and #1
  3536 					ora #$fe
  3537 					sta portb
  3538
  3539 					ldy #0			; przepisz 256b z BUFFER do @BUF
  3540 					mva:rne (dx),y @buf,y+
  3541
  3542 					jsr @xmsBank		; wlacz dodatkowy bank
  3543
  3544 					lda ptr2+1
  3545 					beq lp2
  3546
  3547 					lda ztmp+1		; jesli przekraczamy granice banku $7FFF
  3548 					cmp #$7f
  3549 					bne skp
  3550 					lda ztmp
  3551 					beq skp
  3552
  3553 					lda #0			; to realizuj wyjatek NEXTBANK, kopiuj 256b
  3554 					jsr nextBank
  3555 					jmp skp2
  3556
  3557 8C76			skp	mva:rne @buf,y (ztmp),y+
  3558
  3559 8C76			skp2	inc dx+1		// inc(dx, $100)
  3560
  3561 					inl ptr3+1		// inc(position, $100)
  3562
  3563 					dec ptr2+1
  3564 					bne lp1
  3565
  3566 8C76			lp2	lda ztmp+1		; zakonczenie kopiowania
  3567 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3568 					bne skp_
  3569
  3570 					lda ztmp
  3571 					add ptr2
  3572 					bcc skp_
  3573
  3574 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3575 					jsr nextBank
  3576 					jmp quit
  3577
  3578 8C76			skp_	ldy #0
  3579 8C76			lp3	lda @buf,y
  3580 					sta (ztmp),y
  3581
  3582 					iny
  3583 					cpy ptr2
  3584 					bne lp3
  3585
  3586 8C76			quit	lda portb
  3587 					and #1
  3588 					ora #$fe
  3589 					sta portb
  3590
  3591 					jmp @xmsUpdatePosition
  3592
  3593 8C76			.local	nextBank
  3594 				  
  3595 					sta max
  3596
  3597 					mwa ztmp dst
  3598
  3599 					ldy #0
  3600 8C76			mv0	lda @buf,y
  3601 					sta (dst),y
  3602 					
  3603 					iny
  3604 					inc ztmp
  3605 					bne mv0
  3606
  3607 					lda portb
  3608 					and #1
  3609 					ora main.misc.adr.banks+1,x
  3610 					sta portb
  3611
  3612 					ldx #0
  3613 8C76			mv1	cpy max
  3614 					beq stp
  3615 					lda @buf,y
  3616 					sta $4000,x
  3617 					inx
  3618 					iny
  3619 					bne mv1
  3620 8C76			stp	rts
  3621 				.endl
  3622
  3623 				.endp
  3624
  3625
  3626 8C76			.proc	@xmsAddPosition
  3627
  3628 8C76				.use @xmsReadBuf
  3629
  3630 					add ptr3
  3631 					sta ptr3
  3632 					lda #$00
  3633 					adc ptr3+1
  3634 					sta ptr3+1
  3635 					lda #$00
  3636 					adc ptr3+2
  3637 					sta ptr3+2
  3638 					lda #$00
  3639 					adc ptr3+3
  3640 					sta ptr3+3
  3641
  3642 					rts
  3643 				.endp
  3644
  3645
  3646 8C76			.proc	@xmsUpdatePosition
  3647
  3648 8C76				.use @xmsReadBuf
  3649
  3650 					tya
  3651 					jsr @xmsAddPosition
  3652
  3653 					ldy #0
  3654 					lda ptr3
  3655 					sta (pos),y
  3656 					iny
  3657 					lda ptr3+1
  3658 					sta (pos),y
  3659 					iny
  3660 					lda ptr3+2
  3661 					sta (pos),y
  3662 					iny
  3663 					lda ptr3+3
  3664 					sta (pos),y
  3665
  3666 					pla:tax
  3667 					rts
  3668 				.endp
  3669
  3670
  3671 				/* ----------------------------------------------------------------------- */
  3672
  3673
  3674 8C76			.proc	@ClrScr
  3675
  3676 					ldx #$00
  3677 					lda #$0c
  3678 					jsr xcio
  3679
  3680 					mwa #ename ioadr,x
  3681
  3682 					mva #$0c ioaux1,x
  3683 					mva #$00 ioaux2,x
  3684
  3685 					lda #$03
  3686
  3687 8C76			xcio	sta iocom,x
  3688 					jmp ciov
  3689
  3690 8C76			ename	.byte 'E:',$9b
  3691
  3692 				.endp
  3693
  3694
  3695 				/* ----------------------------------------------------------------------- */
  3696
  3697 8C76			Call_Subroutine
  3698 8C76 6C F0 00				JMP (cndx2)
  3699
  3700
  3701
  3702 					opt l+
  2319
  2320 				; -----------------------------------------------------------
  2321
  2322 				.macro UNITINITIALIZATION
  2323 				
  2324 					.ifdef MAIN.SYSTEM.@UnitInit
  2325 					jsr MAIN.SYSTEM.@UnitInit
  2326 					eif
  2327 				
  2328 					.ifdef MAIN.ATARI.@UnitInit
  2329 					jsr MAIN.ATARI.@UnitInit
  2330 					eif
  2331 				
  2332 					.ifdef MAIN..@UnitInit
  2333 					jsr MAIN..@UnitInit
  2334 					eif
  2335 				
  2336 					.ifdef MAIN.B_SYSTEM.@UnitInit
  2337 					jsr MAIN.B_SYSTEM.@UnitInit
  2338 					eif
  2339 				
  2340 					.ifdef MAIN.SYSUTILS.@UnitInit
  2341 					jsr MAIN.SYSUTILS.@UnitInit
  2342 					eif
  2343 				
  2344 					.ifdef MAIN..@UnitInit
  2345 					jsr MAIN..@UnitInit
  2346 					eif
  2347 				
  2348 					.ifdef MAIN.B_CRT.@UnitInit
  2349 					jsr MAIN.B_CRT.@UnitInit
  2350 					eif
  2351 				.endm
  2352
  2353 					ift .SIZEOF(MAIN.SYSTEM) > 0
  2354 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  2354 				SYSTEM: $82A3..$82F1
  2355 					eif
  2356
  2357 					ift .SIZEOF(MAIN.ATARI) > 0
  2358 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
  2359 					eif
  2360
  2361 					ift .SIZEOF(MAIN.B_SYSTEM) > 0
  2362 					.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
  2362 				B_SYSTEM: $82F2..$82FE
  2363 					eif
  2364
  2365 					ift .SIZEOF(MAIN.SYSUTILS) > 0
  2366 					.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
  2366 				SYSUTILS: $82FF..$8335
  2367 					eif
  2368
  2369 					ift .SIZEOF(MAIN.B_CRT) > 0
  2370 					.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
  2370 				B_CRT: $8336..$858D
  2371 					eif
  2372
  2373 					.print 'CODE: ',CODEORIGIN,'..',*-1
  2373 				CODE: $8000..$8C78
  2374
  2375 					org $A000
  2376
  2377 A000			DATAORIGIN
  2378
  2379 A000-A346> 28 00 18 00 + .by  $28 $00 $18 $00 $0C $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2380 A018 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2381 A030 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2382 A048 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2383 A060 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2384 A078 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2385 A090 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2386 A0A8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2387 A0C0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2388 A0D8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2389 A0F0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2390 A108 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2391 A120 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2392 A138 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2393 A150 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2394 A168 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2395 A180 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2396 A198 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2397 A1B0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2398 A1C8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2399 A1E0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2400 A1F8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2401 A210 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2402 A228 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2403 A240 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2404 A258 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2405 A270 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2406 A288 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2407 A2A0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2408 A2B8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2409 A2D0 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2410 A2E8 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2411 A300 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2412 A318 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2413 A330 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $00 $00  $9A $10 $00 $00 $00 $4C $1D $7C  $15 $AC $0D $C4 $09 $F4 $01
  2414
  2415 = 0347			VARINITSIZE	= *-DATAORIGIN
  2416 = 0354			VARDATASIZE	= 852
  2417
  2418 = A354			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  2419
  2420 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  2420 				DATA: $A000..$A354
  2421
  2422 02E0-02E1> 76 82			run START
  2423
  2424 				; -----------------------------------------------------------
  2425
  2426 				.macro	STATICDATA
  2427 				.by  $00 $00 $28 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $21 $34  $21 $32 $29 $00 $18 $0D $22 $29
  2428 				.by  $34 $00 $36 $25 $32 $33 $29 $2F  $2E $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $28 $00 $30 $32
  2429 				.by  $2F $27 $32 $21 $2D $2D $29 $2E  $27 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $30 $25
  2430 				.by  $34 $25 $32 $00 $2A $0E $00 $2D  $25 $39 $25 $32 $00 $00 $28 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2431 				.by  $00 $00 $00 $00 $00 $08 $39 $2F  $35 $32 $00 $2E $21 $2D $25 $00  $23 $2F $35 $2C $24 $00 $22 $25
  2432 				.by  $00 $28 $25 $32 $25 $09 $00 $00  $28 $00 $27 $32 $21 $30 $28 $29  $23 $33 $00 $00 $00 $00 $00 $00
  2433 				.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  2434 				.by  $00 $00 $28 $00 $33 $2F $35 $2E  $24 $00 $21 $2E $24 $00 $2D $35  $33 $29 $23 $00 $00 $00 $00 $00
  2435 				.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $08 $33 $23 $2F
  2436 				.by  $32 $25 $00 $1A $00 $00 $13 $34  $2F $24 $21 $39 $33 $00 $28 $29  $27 $28 $00 $33 $23 $2F $32 $25
  2437 				.by  $33 $0E $00 $02 $00 $1A $00 $15  $30 $32 $25 $33 $33 $00 $33 $34  $21 $32 $34 $00 $34 $2F $00 $22
  2438 				.by  $25 $27 $29 $2E $0E $00 $06 $33  $23 $2F $32 $25 $1A $00 $06 $2C  $29 $36 $25 $33 $1A $00 $6C $6A
  2439 				.by  $3B $FF $FF $6B $2B $2A $6F $FF  $70 $75 $9B $69 $2D $3D $76 $FF  $63 $FF $FF $62 $78 $7A $34 $FF
  2440 				.by  $33 $36 $1B $35 $32 $31 $2C $20  $2E $6E $FF $6D $2F $81 $72 $FF  $65 $79 $7F $74 $77 $71 $39 $FF
  2441 				.by  $30 $37 $7E $38 $3E $FF $66 $68  $64 $FF $82 $67 $73 $61 $4C $4A  $3A $FF $FF $4B $5C $5E $4F $FF
  2442 				.by  $50 $55 $FF $49 $5F $7C $56 $FF  $43 $FF $FF $42 $58 $5A $24 $FF  $23 $26 $FF $25 $22 $21 $5B $3B
  2443 				.by  $5D $4E $FF $4D $3F $FF $52 $FF  $45 $59 $FF $54 $57 $51 $28 $FF  $29 $27 $FF $40 $FF $FF $46 $48
  2444 				.by  $44 $FF $FF $47 $53 $41 $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  2445 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  2446 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  2447 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  2448 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
  2449 				.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $70 $C0  $44 $00 $AC $04 $04 $04 $04 $04
  2450 				.by  $04 $84 $00 $44 $00 $08 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04
  2451 				.by  $00 $04 $00 $04 $00 $04 $00 $04  $00 $04 $00 $04 $00 $04 $00 $04  $41 $1E $82 $70 $70 $44 $00 $08
  2452 				.by  $10 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04
  2453 				.by  $04 $04 $04 $41 $53 $82
  2454 				.endm
  2455
  2456 					end
